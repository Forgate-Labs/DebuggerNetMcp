---
phase: 08-stack-trace-and-dotnet-test
plan: 02
type: execute
wave: 2
depends_on: [08-01]
files_modified:
  - src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs
  - src/DebuggerNetMcp.Mcp/DebuggerTools.cs
  - tests/DebuggerNetMcp.Tests/UnitTest1.cs
autonomous: true
requirements: [DTEST-01, DTEST-02]

must_haves:
  truths:
    - "debug_launch_test accepts a test project path, builds it, launches dotnet test with VSTEST_HOST_DEBUG=1, parses the testhost PID from stdout, and attaches — returning state='attached'"
    - "A breakpoint set inside a [Fact] method in the xUnit test project is hit and debug_variables returns the test's local variables"
    - "DisconnectAsync kills the dotnet test vstest runner process when cleaning up a test session"
    - "The xUnit test project has a [Fact] method with debuggable local variables for manual verification"
  artifacts:
    - path: "src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs"
      provides: "LaunchTestAsync method + _dotnetTestProcess field + DisconnectAsync cleanup"
      contains: "LaunchTestAsync"
    - path: "src/DebuggerNetMcp.Mcp/DebuggerTools.cs"
      provides: "debug_launch_test MCP tool"
      contains: "debug_launch_test"
    - path: "tests/DebuggerNetMcp.Tests/UnitTest1.cs"
      provides: "[Fact] test with local variables for debugger verification"
      contains: "BP-DTEST"
  key_links:
    - from: "src/DebuggerNetMcp.Mcp/DebuggerTools.cs"
      to: "src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs"
      via: "LaunchTestAsync call in debug_launch_test tool"
      pattern: "LaunchTestAsync"
    - from: "DotnetDebugger.LaunchTestAsync"
      to: "DotnetDebugger.AttachAsync"
      via: "Calls AttachAsync(testhostPid) after parsing PID from stdout"
      pattern: "AttachAsync.*testhostPid"
    - from: "DotnetDebugger.DisconnectAsync"
      to: "_dotnetTestProcess"
      via: "Kill vstest runner on disconnect to prevent hanging dotnet test"
      pattern: "_dotnetTestProcess"
---

<objective>
Implement `LaunchTestAsync` in DotnetDebugger (DTEST-01) and the `debug_launch_test` MCP tool (DTEST-01/02), then add a [Fact] method with local variables to the xUnit test project for breakpoint verification.

Purpose: Enables Claude Code to debug xUnit test methods directly — set a breakpoint in a [Fact], launch via debug_launch_test, and inspect test-local variables.
Output: LaunchTestAsync method + debug_launch_test tool + debuggable [Fact] test.
</objective>

<execution_context>
@/home/eduardo/.claude/get-shit-done/workflows/execute-plan.md
@/home/eduardo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-stack-trace-and-dotnet-test/08-RESEARCH.md
@.planning/phases/08-stack-trace-and-dotnet-test/08-01-SUMMARY.md

Key existing code:
@src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs
@src/DebuggerNetMcp.Mcp/DebuggerTools.cs
@tests/DebuggerNetMcp.Tests/UnitTest1.cs
@tests/DebuggerNetMcp.Tests/DebuggerNetMcp.Tests.csproj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add LaunchTestAsync to DotnetDebugger + DisconnectAsync cleanup</name>
  <files>src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs</files>
  <action>
**Step A — Add `_dotnetTestProcess` field**

Add a private field near the other `_process`/`_launchedPid` fields (around line 33):
```csharp
private System.Diagnostics.Process? _dotnetTestProcess;
```

**Step B — Add `LaunchTestAsync` method**

Add a new public method `LaunchTestAsync` after `AttachAsync`. The method:
1. Calls `DisconnectAsync` first (same cleanup pattern as `LaunchAsync`) to clear any prior session
2. Runs `dotnet build "{projectPath}" -c Debug` synchronously via `Process.Start` — wait for exit, throw if non-zero exit code
3. Starts `dotnet test "{projectPath}" --no-build` with `VSTEST_HOST_DEBUG=1` in env, stdout redirected, `UseShellExecute=false`
4. Stores the process in `_dotnetTestProcess`
5. Reads stdout lines with `ReadLineAsync` using a 25-second timeout CancellationTokenSource — looking for the pattern `"Process Id:\s*(\d+)"` using `System.Text.RegularExpressions.Regex`
6. If no PID found within timeout, kills `_dotnetTestProcess` and throws `InvalidOperationException("Failed to get testhost PID from dotnet test output within timeout")`
7. Calls `await AttachAsync(testhostPid, ct)` — this reuses all existing attach infrastructure

```csharp
public async Task<(uint Pid, string ProcessName)> LaunchTestAsync(
    string projectPath,
    string? filter = null,
    CancellationToken ct = default)
{
    await DisconnectAsync(ct);

    // Step 1: Build
    var buildPsi = new System.Diagnostics.ProcessStartInfo("dotnet",
        $"build \"{projectPath}\" -c Debug")
    {
        UseShellExecute = false,
        RedirectStandardOutput = false,
    };
    using var buildProc = System.Diagnostics.Process.Start(buildPsi)!;
    await buildProc.WaitForExitAsync(ct);
    if (buildProc.ExitCode != 0)
        throw new InvalidOperationException($"dotnet build failed with exit code {buildProc.ExitCode}");

    // Step 2: Launch dotnet test with VSTEST_HOST_DEBUG=1
    string testArgs = $"test \"{projectPath}\" --no-build";
    if (!string.IsNullOrEmpty(filter))
        testArgs += $" --filter \"{filter}\"";

    var testPsi = new System.Diagnostics.ProcessStartInfo("dotnet", testArgs)
    {
        RedirectStandardOutput = true,
        RedirectStandardError = false,
        UseShellExecute = false,
    };
    testPsi.Environment["VSTEST_HOST_DEBUG"] = "1";

    _dotnetTestProcess = System.Diagnostics.Process.Start(testPsi)!;

    // Step 3: Parse testhost PID from stdout
    using var timeoutCts = new CancellationTokenSource(TimeSpan.FromSeconds(25));
    using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(ct, timeoutCts.Token);

    uint testhostPid = 0;
    try
    {
        string? line;
        while ((line = await _dotnetTestProcess.StandardOutput.ReadLineAsync(linkedCts.Token)) != null)
        {
            var match = System.Text.RegularExpressions.Regex.Match(line, @"Process Id:\s*(\d+)");
            if (match.Success)
            {
                testhostPid = uint.Parse(match.Groups[1].Value);
                break;
            }
        }
    }
    catch (OperationCanceledException) when (timeoutCts.IsCancellationRequested)
    {
        _dotnetTestProcess.Kill(entireProcessTree: true);
        _dotnetTestProcess = null;
        throw new InvalidOperationException(
            "Failed to get testhost PID from dotnet test output within 25 seconds. " +
            "Ensure the project is a valid xUnit test project.");
    }

    if (testhostPid == 0)
    {
        _dotnetTestProcess.Kill(entireProcessTree: true);
        _dotnetTestProcess = null;
        throw new InvalidOperationException("Failed to get testhost PID from dotnet test output.");
    }

    // Step 4: Attach to testhost — reuses all existing attach infrastructure
    return await AttachAsync(testhostPid, ct);
}
```

**Step C — Update `DisconnectAsync`**

In the existing `DisconnectAsync` method, add cleanup of `_dotnetTestProcess` INSIDE the `DispatchAsync` lambda, after `_process = null`:
```csharp
// Kill the vstest runner if this was a test session
if (_dotnetTestProcess is { HasExited: false })
{
    try { _dotnetTestProcess.Kill(entireProcessTree: true); } catch { }
}
_dotnetTestProcess = null;
```

IMPORTANT: The `_dotnetTestProcess` is the `dotnet test` parent process (vstest runner), not testhost. When we disconnect from testhost (the ICorDebug process), the vstest runner will hang waiting for testhost. We must kill it.
  </action>
  <verify>dotnet build src/DebuggerNetMcp.Core/ -c Release 2>&1 | tail -5</verify>
  <done>Core project builds; LaunchTestAsync method exists; _dotnetTestProcess field exists; DisconnectAsync kills _dotnetTestProcess.</done>
</task>

<task type="auto">
  <name>Task 2: Add debug_launch_test MCP tool + xUnit test with locals</name>
  <files>src/DebuggerNetMcp.Mcp/DebuggerTools.cs
tests/DebuggerNetMcp.Tests/UnitTest1.cs</files>
  <action>
**Step A — Add debug_launch_test tool to DebuggerTools.cs**

Add the tool after the `Attach` method (around line 118), following the exact same pattern as `Attach`:

```csharp
[McpServerTool(Name = "debug_launch_test"),
 Description("Launch an xUnit test project under debug mode using VSTEST_HOST_DEBUG, " +
             "attach to the testhost process, and return the process info. " +
             "After calling this, set breakpoints with debug_set_breakpoint then call debug_continue.")]
public async Task<string> LaunchTest(
    [Description("Absolute path to the xUnit test project directory or .csproj file")]
    string projectPath,
    [Description("Optional test filter expression passed to --filter (e.g. 'FullyQualifiedName~MyTest')")]
    string? filter = null)
{
    using var cts = CreateToolCts();
    return await RunAndWait("debug_launch_test", async ct =>
    {
        var (pid, processName) = await _debugger.LaunchTestAsync(projectPath, filter, ct);
        return JsonSerializer.Serialize(new
        {
            success = true,
            state = "attached",
            pid,
            processName,
            note = "testhost attached — set breakpoints then call debug_continue"
        });
    }, cts.Token);
}
```

**Step B — Update UnitTest1.cs with a debuggable [Fact] method**

Replace the contents of `tests/DebuggerNetMcp.Tests/UnitTest1.cs` with a test that has meaningful local variables for breakpoint verification:

```csharp
namespace DebuggerNetMcp.Tests;

public class MathTests
{
    // BP-DTEST: Set breakpoint on the line with "int result = a + b;" to test DTEST-01/02
    [Fact]
    public void AddTwoNumbers_ReturnsCorrectSum()
    {
        int a = 21;
        int b = 21;
        int result = a + b; // BP-DTEST
        string label = "sum";
        Assert.Equal(42, result);
    }

    [Fact]
    public void MultiplyNumbers_ReturnsProduct()
    {
        int x = 6;
        int y = 7;
        int product = x * y; // BP-DTEST-2
        Assert.Equal(42, product);
    }
}
```

**Step C — Bump ServerVersion**

In `DebuggerTools.cs`, check the current `ServerVersion` constant (line 11) and increment it to the next minor version to reflect this feature addition (e.g. if it's 0.8.0 after plan 01, keep as-is since plan 01 already incremented it; if plan 01 has not been run yet and it's still the old value, increment once to the new minor version).

Actually: check the current value and increment by one minor version if not already done by plan 01. The key rule from MEMORY.md: "sempre incrementar versão ao mudar qualquer um dos dois projetos."
  </action>
  <verify>dotnet build src/DebuggerNetMcp.Mcp/ -c Release 2>&1 | tail -5</verify>
  <done>Release build succeeds; debug_launch_test tool exists in DebuggerTools.cs; UnitTest1.cs has MathTests with BP-DTEST markers; `dotnet test tests/DebuggerNetMcp.Tests/` passes (empty test bodies don't fail).</done>
</task>

</tasks>

<verification>
After both tasks:
1. `dotnet build src/DebuggerNetMcp.Mcp/ -c Release` completes without errors
2. `dotnet test tests/DebuggerNetMcp.Tests/ --no-build` — tests pass (AddTwoNumbers, MultiplyNumbers both have real assertions that should pass with the given values: 21+21=42, 6*7=42)
3. Inspect DebuggerTools.cs — confirm `debug_launch_test` tool exists
4. Inspect DotnetDebugger.cs — confirm LaunchTestAsync calls AttachAsync, _dotnetTestProcess field, DisconnectAsync cleanup
5. Manual smoke test (if DTEST-02 required): `debug_launch_test` with the DebuggerNetMcp.Tests project path, set BP on "int result = a + b;", continue — breakpoint should be hit and debug_variables should show a=21, b=21
</verification>

<success_criteria>
- LaunchTestAsync: builds project, launches dotnet test with VSTEST_HOST_DEBUG=1, parses PID from stdout (regex), calls AttachAsync — returns same shape as AttachAsync
- DisconnectAsync kills _dotnetTestProcess to prevent vstest runner hanging
- debug_launch_test MCP tool accepts projectPath + optional filter, returns { success, state:"attached", pid, processName }
- UnitTest1.cs has MathTests with BP-DTEST commented breakpoint locations and assertions that pass
- Release build passes
- dotnet test passes (42==42)
</success_criteria>

<output>
After completion, create `.planning/phases/08-stack-trace-and-dotnet-test/08-02-SUMMARY.md`
</output>
