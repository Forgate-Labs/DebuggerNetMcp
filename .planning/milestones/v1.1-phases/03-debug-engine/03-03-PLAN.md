---
phase: 03-debug-engine
plan: 03
type: execute
wave: 3
depends_on:
  - "03-01"
  - "03-02"
files_modified:
  - src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs
autonomous: true
requirements:
  - ENGINE-04
  - ENGINE-08

must_haves:
  truths:
    - "DotnetDebugger.LaunchAsync builds the target app with dotnet build -c Debug, then launches it via CreateProcessForLaunch + RegisterForRuntimeStartup"
    - "DotnetDebugger.AttachAsync connects to a running process via RegisterForRuntimeStartup with existing PID"
    - "The dedicated ICorDebug thread starts in the constructor and all ICorDebug calls happen on it"
    - "Channel<DebugEvent> is created with AllowSynchronousContinuations=false, SingleWriter=true"
    - "KeepAlive is called before RegisterForRuntimeStartup to prevent GC collection of the callback delegate"
    - "LaunchAsync resolves when the CreateProcess callback fires (ICorDebugProcess available)"
    - "DisconnectAsync terminates the session and completes the event channel"
  artifacts:
    - path: "src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs"
      provides: "Debug engine core: launch, attach, disconnect, event channel, dedicated thread"
      min_lines: 150
      contains: "Channel.CreateUnbounded"
  key_links:
    - from: "src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs"
      to: "src/DebuggerNetMcp.Core/Interop/DbgShimInterop.cs"
      via: "DbgShimInterop.Load() in constructor; CreateProcessForLaunch, RegisterForRuntimeStartup, ResumeProcess, CloseResumeHandle called in LaunchAsync"
      pattern: "DbgShimInterop\\."
    - from: "src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs"
      to: "src/DebuggerNetMcp.Core/Engine/ManagedCallbackHandler.cs"
      via: "new ManagedCallbackHandler(_eventChannel.Writer) in constructor; SetManagedHandler in RuntimeStartupCallback"
      pattern: "new ManagedCallbackHandler"
    - from: "src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs"
      to: "System.Threading.Channels.Channel<DebugEvent>"
      via: "Channel.CreateUnbounded; async callers use WaitForEventAsync"
      pattern: "Channel\\.CreateUnbounded"
---

<objective>
Implement the core `DotnetDebugger.cs` class: constructor, dedicated ICorDebug thread, Channel bridge, LaunchAsync, AttachAsync, DisconnectAsync, and WaitForEventAsync. This is the structural skeleton that all other engine methods (breakpoints, stepping, inspection) will be added to in Plans 04 and 05.

Purpose: The dedicated thread + Channel pattern is the highest-risk architectural piece. Getting it right here ensures Plans 04 and 05 can add methods safely. The SIGSEGV kernel 6.12+ fix (KeepAlive before RegisterForRuntimeStartup) must be baked into this plan.

Output: DotnetDebugger.cs with launch/attach/disconnect wired correctly; builds clean.
</objective>

<execution_context>
@/home/eduardo/.claude/get-shit-done/workflows/execute-plan.md
@/home/eduardo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-debug-engine/03-RESEARCH.md
@.planning/phases/02-interop-engine-foundation/02-02-SUMMARY.md
@src/DebuggerNetMcp.Core/Interop/DbgShimInterop.cs
@src/DebuggerNetMcp.Core/Interop/ICorDebug.cs
@src/DebuggerNetMcp.Core/Engine/ManagedCallbackHandler.cs
@src/DebuggerNetMcp.Core/Engine/Models.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DotnetDebugger.cs core — channel, thread, launch, attach, disconnect</name>
  <files>src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs</files>
  <action>
Create `src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs` implementing the engine scaffold.

**Critical invariants (all must be respected — from research):**
1. `Channel.CreateUnbounded<DebugEvent>` with `AllowSynchronousContinuations = false` — prevents deadlock when reader continuation runs on callback thread
2. `DbgShimInterop.KeepAlive(callback)` MUST be called BEFORE `RegisterForRuntimeStartup` — prevents GC collecting the delegate before native code fires it (kernel 6.12+ SIGSEGV fix)
3. The dedicated thread (`_debugThread`) is `new Thread(...) { IsBackground = true, Name = "ICorDebug-Dispatch" }` — NOT Task.Run
4. `ICorDebugProcess` is obtained from the `CreateProcess` callback via `_callbackHandler.OnProcessCreated`, NOT from `LaunchAsync` directly
5. `LaunchAsync` runs `dotnet build -c Debug` first via `Process.Start`, waits for it to exit 0
6. `LaunchAsync` uses `bSuspendProcess: true` in `CreateProcessForLaunch` and calls `ResumeProcess` + `CloseResumeHandle` after `RegisterForRuntimeStartup`

**Implementation:**

```csharp
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Threading.Channels;
using DebuggerNetMcp.Core.Interop;

namespace DebuggerNetMcp.Core.Engine;

/// <summary>
/// The .NET debug engine. Wraps ICorDebug via libdbgshim.so to launch/attach to managed processes,
/// set breakpoints, step, and inspect variables.
///
/// Thread model: All ICorDebug API calls happen on the dedicated _debugThread.
/// Async public methods dispatch work to _debugThread via _commandChannel and
/// await TaskCompletionSource results. This prevents COM apartment violations.
///
/// Event model: ICorDebug callbacks post events to _eventChannel (Channel&lt;DebugEvent&gt;).
/// Callers consume events via WaitForEventAsync.
/// </summary>
public sealed class DotnetDebugger : IAsyncDisposable
{
    // -----------------------------------------------------------------------
    // Infrastructure
    // -----------------------------------------------------------------------

    private readonly Channel<DebugEvent> _eventChannel;
    private readonly Channel<Action> _commandChannel;
    private readonly ManagedCallbackHandler _callbackHandler;
    private readonly Thread _debugThread;

    private ICorDebug? _corDebug;
    private ICorDebugProcess? _process;
    private int _nextBreakpointId = 1;

    // Pending breakpoints: set before the module loads
    private readonly List<PendingBreakpoint> _pendingBreakpoints = new();

    // Active breakpoints: ICorDebugFunctionBreakpoint instances by ID
    private readonly Dictionary<int, ICorDebugFunctionBreakpoint> _activeBreakpoints = new();

    // Loaded modules: module name → ICorDebugModule
    private readonly Dictionary<string, ICorDebugModule> _loadedModules = new(StringComparer.OrdinalIgnoreCase);

    public DotnetDebugger(string? dbgShimPath = null)
    {
        // Event channel: single writer (callback thread), multiple readers (MCP tools)
        _eventChannel = Channel.CreateUnbounded<DebugEvent>(new UnboundedChannelOptions
        {
            SingleWriter = true,
            SingleReader = false,
            AllowSynchronousContinuations = false  // CRITICAL: prevents deadlock
        });

        // Command channel: MCP tool threads enqueue work; _debugThread executes it
        _commandChannel = Channel.CreateUnbounded<Action>(new UnboundedChannelOptions
        {
            SingleWriter = false,
            SingleReader = true,
            AllowSynchronousContinuations = false
        });

        _callbackHandler = new ManagedCallbackHandler(_eventChannel.Writer);
        _callbackHandler.OnProcessCreated = process => _process = process;
        _callbackHandler.OnModuleLoaded = OnModuleLoaded;

        // Load libdbgshim.so (throws FileNotFoundException if not found)
        DbgShimInterop.Load(dbgShimPath);

        // Start the dedicated ICorDebug dispatch thread
        _debugThread = new Thread(DebugThreadLoop)
        {
            IsBackground = true,
            Name = "ICorDebug-Dispatch"
        };
        _debugThread.Start();
    }

    // -----------------------------------------------------------------------
    // Public API — Launch, Attach, Disconnect
    // -----------------------------------------------------------------------

    /// <summary>
    /// Builds the target .NET project (-c Debug) then launches it under the debugger.
    /// Returns when ICorDebug is initialized and the process has been created
    /// (i.e., the CreateProcess callback has fired).
    /// </summary>
    /// <param name="projectPath">Path to the .csproj or directory containing one.</param>
    /// <param name="appDllPath">Path to the compiled .dll to run (e.g. bin/Debug/net9.0/App.dll).</param>
    /// <param name="ct">Cancellation token.</param>
    public async Task LaunchAsync(string projectPath, string appDllPath,
        CancellationToken ct = default)
    {
        // Step 1: dotnet build -c Debug
        await BuildProjectAsync(projectPath, ct);

        // Step 2: Launch under debugger via command channel (must run on debug thread)
        var tcs = new TaskCompletionSource(TaskCreationOptions.RunContinuationsAsynchronously);
        await DispatchAsync(() =>
        {
            try
            {
                LaunchUnderDebugger(appDllPath);
                tcs.SetResult();
            }
            catch (Exception ex)
            {
                tcs.SetException(ex);
            }
        }, ct);

        await tcs.Task.WaitAsync(ct);
    }

    /// <summary>
    /// Attaches to a running .NET process by PID.
    /// </summary>
    public async Task AttachAsync(uint processId, CancellationToken ct = default)
    {
        var tcs = new TaskCompletionSource(TaskCreationOptions.RunContinuationsAsynchronously);
        await DispatchAsync(() =>
        {
            try
            {
                AttachToProcess(processId);
                tcs.SetResult();
            }
            catch (Exception ex)
            {
                tcs.SetException(ex);
            }
        }, ct);

        await tcs.Task.WaitAsync(ct);
    }

    /// <summary>
    /// Stops the debug session and terminates the debuggee if still running.
    /// </summary>
    public async Task DisconnectAsync(CancellationToken ct = default)
    {
        await DispatchAsync(() =>
        {
            try
            {
                _process?.Stop(0);
                _process?.Terminate(0);
            }
            catch { /* process may already be gone */ }
        }, ct);

        // Complete command channel to stop the debug thread
        _commandChannel.Writer.TryComplete();
    }

    /// <summary>
    /// Waits for the next debug event from the ICorDebug callback thread.
    /// </summary>
    public async Task<DebugEvent> WaitForEventAsync(CancellationToken ct = default)
    {
        return await _eventChannel.Reader.ReadAsync(ct);
    }

    // -----------------------------------------------------------------------
    // IAsyncDisposable
    // -----------------------------------------------------------------------

    public async ValueTask DisposeAsync()
    {
        await DisconnectAsync();
        if (_debugThread.IsAlive)
            _debugThread.Join(TimeSpan.FromSeconds(2));
    }

    // -----------------------------------------------------------------------
    // Private: Launch + Attach (run on debug thread via DispatchAsync)
    // -----------------------------------------------------------------------

    private void LaunchUnderDebugger(string appDllPath)
    {
        // Create a RuntimeStartupCallback delegate
        RuntimeStartupCallback callback = OnRuntimeStarted;

        // CRITICAL: KeepAlive BEFORE RegisterForRuntimeStartup (kernel 6.12+ SIGSEGV fix)
        DbgShimInterop.KeepAlive(callback);

        string cmdLine = $"dotnet \"{appDllPath}\"";
        int hr = DbgShimInterop.CreateProcessForLaunch(
            cmdLine,
            bSuspendProcess: true,
            IntPtr.Zero,
            null,
            out uint pid,
            out IntPtr resumeHandle);

        if (hr != 0)
            throw new InvalidOperationException($"CreateProcessForLaunch failed: HRESULT 0x{hr:X8}");

        hr = DbgShimInterop.RegisterForRuntimeStartup(pid, callback, IntPtr.Zero, out _);
        if (hr != 0)
        {
            DbgShimInterop.CloseResumeHandle(resumeHandle);
            throw new InvalidOperationException($"RegisterForRuntimeStartup failed: HRESULT 0x{hr:X8}");
        }

        DbgShimInterop.ResumeProcess(resumeHandle);
        DbgShimInterop.CloseResumeHandle(resumeHandle);
    }

    private void AttachToProcess(uint processId)
    {
        RuntimeStartupCallback callback = OnRuntimeStarted;
        DbgShimInterop.KeepAlive(callback);  // CRITICAL: same GC guard for attach

        int hr = DbgShimInterop.RegisterForRuntimeStartup(processId, callback, IntPtr.Zero, out _);
        if (hr != 0)
            throw new InvalidOperationException($"RegisterForRuntimeStartup failed: HRESULT 0x{hr:X8}");
    }

    private void OnRuntimeStarted(IntPtr pCordb, IntPtr parameter, int hr)
    {
        if (hr != 0)
        {
            _eventChannel.Writer.TryWrite(new ExceptionEvent("StartupError",
                $"Runtime startup failed: HRESULT 0x{hr:X8}", 0, true));
            return;
        }

        _corDebug = (ICorDebug)Marshal.GetObjectForIUnknown(pCordb);
        _corDebug.Initialize();
        _corDebug.SetManagedHandler(_callbackHandler);
        // ICorDebugProcess arrives separately via CreateProcess callback
    }

    // -----------------------------------------------------------------------
    // Private: Module loading (invoked from callback thread via OnModuleLoaded)
    // -----------------------------------------------------------------------

    private void OnModuleLoaded(ICorDebugModule module)
    {
        // Get module name
        module.GetName(256, out uint nameLen, out IntPtr namePtr);
        string moduleName = Marshal.PtrToStringUni(namePtr) ?? string.Empty;
        _loadedModules[moduleName] = module;

        // Resolve any pending breakpoints for this module
        for (int i = _pendingBreakpoints.Count - 1; i >= 0; i--)
        {
            var pending = _pendingBreakpoints[i];
            if (moduleName.EndsWith(pending.DllName, StringComparison.OrdinalIgnoreCase))
            {
                try
                {
                    ResolveBreakpoint(module, pending.Id, pending.MethodToken, pending.ILOffset);
                    _pendingBreakpoints.RemoveAt(i);
                }
                catch { /* log and keep pending */ }
            }
        }
    }

    // ResolveBreakpoint is implemented in Plan 04
    private partial void ResolveBreakpoint(ICorDebugModule module, int id, int methodToken, int ilOffset);

    // -----------------------------------------------------------------------
    // Private: Build
    // -----------------------------------------------------------------------

    private static async Task BuildProjectAsync(string projectPath, CancellationToken ct)
    {
        var psi = new ProcessStartInfo("dotnet", $"build \"{projectPath}\" -c Debug")
        {
            RedirectStandardOutput = true,
            RedirectStandardError = true,
            UseShellExecute = false
        };

        using var buildProcess = Process.Start(psi)
            ?? throw new InvalidOperationException("Failed to start dotnet build");

        await buildProcess.WaitForExitAsync(ct);

        if (buildProcess.ExitCode != 0)
        {
            string err = await buildProcess.StandardError.ReadToEndAsync(ct);
            throw new InvalidOperationException($"dotnet build failed (exit {buildProcess.ExitCode}):\n{err}");
        }
    }

    // -----------------------------------------------------------------------
    // Private: Debug thread loop + command dispatch
    // -----------------------------------------------------------------------

    private void DebugThreadLoop()
    {
        // Process commands until the command channel is completed
        while (_commandChannel.Reader.TryRead(out var action))
            action();

        // Drain remaining commands when channel is closed
        while (_commandChannel.Reader.TryRead(out var action))
            action();
    }

    /// <summary>
    /// Enqueues an action onto the dedicated debug thread and waits for it to be dequeued.
    /// The action runs synchronously on the debug thread.
    /// </summary>
    private async Task DispatchAsync(Action action, CancellationToken ct)
    {
        await _commandChannel.Writer.WriteAsync(action, ct);
    }

    // -----------------------------------------------------------------------
    // Private: Pending breakpoint record
    // -----------------------------------------------------------------------

    private record PendingBreakpoint(int Id, string DllName, int MethodToken, int ILOffset);
}
```

**Notes on implementation:**
- `ResolveBreakpoint` is declared as `partial` here and will be implemented as a regular private method in Plan 04 (which extends the same file). If C# partial methods cause issues (partial methods require partial class), declare it as a regular private method stub instead that throws `NotImplementedException`, then replace it in Plan 04.
- If `ICorDebugModule.GetName` uses `IntPtr` signature (from Plan 02-02 SYSLIB1051 fix), adapt accordingly. Check `ICorDebug.cs` for the actual signature.
- `DebugThreadLoop` must continuously drain the command channel. The current implementation uses a simple `while (TryRead)` loop but this creates a busy-spin. Replace with an async approach:

```csharp
private void DebugThreadLoop()
{
    // Block the thread waiting for commands, processing them one at a time
    var reader = _commandChannel.Reader;
    while (true)
    {
        // Use GetAwaiter().GetResult() to block synchronously on the thread
        // (this IS the dedicated thread; blocking here is intentional)
        Action? action = null;
        try
        {
            var valueTask = reader.ReadAsync();
            action = valueTask.IsCompleted
                ? valueTask.Result
                : valueTask.AsTask().GetAwaiter().GetResult();
        }
        catch (ChannelClosedException)
        {
            break;  // command channel completed — exit thread
        }
        catch (OperationCanceledException)
        {
            break;
        }

        try { action?.Invoke(); }
        catch (Exception) { /* swallow — action must handle its own errors via TCS */ }
    }
}
```

Build, check for 0 errors. Fix any namespace or type conflicts.
  </action>
  <verify>
    Run: `dotnet build /home/eduardo/Projects/DebuggerNetMcp/DebuggerNetMcp.sln`
    Expected: Exit code 0, 0 errors, 0 warnings
    Run: `grep "Channel.CreateUnbounded" /home/eduardo/Projects/DebuggerNetMcp/src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs`
    Expected: at least 1 match
    Run: `grep "AllowSynchronousContinuations = false" /home/eduardo/Projects/DebuggerNetMcp/src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs`
    Expected: at least 1 match
    Run: `grep "KeepAlive" /home/eduardo/Projects/DebuggerNetMcp/src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs`
    Expected: at least 1 match (before RegisterForRuntimeStartup)
    Run: `grep "ICorDebug-Dispatch" /home/eduardo/Projects/DebuggerNetMcp/src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs`
    Expected: 1 match
  </verify>
  <done>
    DotnetDebugger.cs exists and compiles.
    LaunchAsync: builds project, calls CreateProcessForLaunch with bSuspendProcess=true, calls KeepAlive before RegisterForRuntimeStartup, resumes and closes handle.
    AttachAsync: calls KeepAlive before RegisterForRuntimeStartup with existing PID.
    Dedicated thread named "ICorDebug-Dispatch" created in constructor with IsBackground=true.
    Channel created with AllowSynchronousContinuations=false.
    WaitForEventAsync delegates to _eventChannel.Reader.ReadAsync.
    dotnet build exits 0.
  </done>
</task>

</tasks>

<verification>
- `dotnet build DebuggerNetMcp.sln` exits 0
- DotnetDebugger.cs has Channel.CreateUnbounded with AllowSynchronousContinuations=false
- DotnetDebugger.cs has DbgShimInterop.KeepAlive called before RegisterForRuntimeStartup
- Thread named "ICorDebug-Dispatch" with IsBackground=true
- WaitForEventAsync returns Task&lt;DebugEvent&gt;
</verification>

<success_criteria>
- DotnetDebugger.cs is a complete, compilable class (no stubs that cause build errors)
- Launch sequence follows: build → CreateProcessForLaunch → KeepAlive → RegisterForRuntimeStartup → ResumeProcess → CloseResumeHandle
- Attach sequence: KeepAlive → RegisterForRuntimeStartup
- OnRuntimeStarted extracts ICorDebug via Marshal.GetObjectForIUnknown, calls Initialize + SetManagedHandler
- ICorDebugProcess captured from CreateProcess callback via OnProcessCreated hook
- Clean build 0 warnings
</success_criteria>

<output>
After completion, create `.planning/phases/03-debug-engine/03-03-SUMMARY.md`
</output>
