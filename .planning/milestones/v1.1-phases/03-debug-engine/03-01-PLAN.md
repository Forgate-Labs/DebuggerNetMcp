---
phase: 03-debug-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/DebuggerNetMcp.Core/Interop/ICorDebug.cs
  - src/DebuggerNetMcp.Core/Interop/IMetaDataImport.cs
autonomous: true
requirements:
  - ENGINE-08

must_haves:
  truths:
    - "ICorDebugClass.GetToken(out uint pToken) is callable from managed code"
    - "IMetaDataImportMinimal exposes EnumFields, GetFieldProps, CloseEnum with the real IMetaDataImport GUID"
    - "dotnet build exits 0 with 0 warnings after the additions"
  artifacts:
    - path: "src/DebuggerNetMcp.Core/Interop/IMetaDataImport.cs"
      provides: "Minimal IMetaDataImport interface for object field enumeration"
      contains: "[Guid(\"7DAC8207-D3AE-4C75-9B67-92801A497D44\")]"
    - path: "src/DebuggerNetMcp.Core/Interop/ICorDebug.cs"
      provides: "Extended ICorDebugClass stub with GetToken"
      contains: "GetToken(out uint pToken)"
  key_links:
    - from: "src/DebuggerNetMcp.Core/Interop/IMetaDataImport.cs"
      to: "src/DebuggerNetMcp.Core/Engine/VariableReader.cs"
      via: "IMetaDataImportMinimal used in Phase 3 ReadObject"
      pattern: "IMetaDataImportMinimal"
    - from: "src/DebuggerNetMcp.Core/Interop/ICorDebug.cs"
      to: "src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs"
      via: "ICorDebugClass.GetToken called during field enumeration"
      pattern: "GetToken"
---

<objective>
Extend the Phase 2 COM interop stubs with the two missing pieces required for object field inspection and the dedicated-thread architecture: (1) add `GetToken(out uint pToken)` to the `ICorDebugClass` stub in `ICorDebug.cs`, and (2) create a new `IMetaDataImportMinimal` interface in its own file declaring the 4 methods needed to enumerate and name fields of an object type.

Purpose: Phase 3 DotnetDebugger and VariableReader need these two pieces to implement `ReadObject` field enumeration. Without `ICorDebugClass.GetToken`, the typedef token cannot be retrieved. Without `IMetaDataImportMinimal`, field names cannot be mapped from tokens to strings.

Output: Extended `ICorDebug.cs` + new `IMetaDataImport.cs`, both compiling cleanly.
</objective>

<execution_context>
@/home/eduardo/.claude/get-shit-done/workflows/execute-plan.md
@/home/eduardo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-interop-engine-foundation/02-02-SUMMARY.md
@src/DebuggerNetMcp.Core/Interop/ICorDebug.cs
@src/DebuggerNetMcp.Core/DebuggerNetMcp.Core.csproj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ICorDebugClass.GetToken and create IMetaDataImportMinimal</name>
  <files>
    src/DebuggerNetMcp.Core/Interop/ICorDebug.cs
    src/DebuggerNetMcp.Core/Interop/IMetaDataImport.cs
  </files>
  <action>
**Part A — Extend ICorDebugClass in ICorDebug.cs:**

Find the `ICorDebugClass` stub interface (it currently has the GUID `[Guid("CC7BCAF4-8A68-11D2-983C-0000F808342D")]` and an empty body). Add ONE method to it:

```csharp
[GeneratedComInterface]
[Guid("CC7BCAF4-8A68-11D2-983C-0000F808342D")]
internal partial interface ICorDebugClass
{
    void GetModule(out ICorDebugModule pModule);
    void GetToken(out uint pTypeDef);
    void GetParameterizedType(uint elementType, uint nTypeArgs, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] ICorDebugType[] ppTypeArgs, out ICorDebugType ppType);
}
```

If `ICorDebugClass` is currently empty (no methods), replace its body with just `GetToken`:

```csharp
[GeneratedComInterface]
[Guid("CC7BCAF4-8A68-11D2-983C-0000F808342D")]
internal partial interface ICorDebugClass
{
    void GetToken(out uint pTypeDef);
}
```

**IMPORTANT:** Do not add methods that require interface types that don't exist yet (ICorDebugType). Add ONLY `GetToken(out uint pTypeDef)` as the single method. This keeps the vtable minimal and avoids pulling in unneeded stubs.

**Part B — Create IMetaDataImport.cs:**

Create `src/DebuggerNetMcp.Core/Interop/IMetaDataImport.cs` with the following EXACT content. Use the real IMetaDataImport GUID. Declare only the 4 methods needed for field enumeration, in the same vtable order as the real interface. The real IMetaDataImport has ~70 methods; we declare a minimal subset but the GUID must match exactly for `Marshal.GetObjectForIUnknown` to succeed via COM QI.

**CRITICAL:** `[GeneratedComInterface]` with a partial interface declaration that has fewer methods than the real COM vtable is UNSAFE — the source generator will produce an incorrect vtable. Instead, declare this interface WITHOUT `[GeneratedComInterface]` and use it only as a cast target after `Marshal.GetObjectForIUnknown`. Use a raw `ComInterfaceMarshaller` approach: declare it as a plain C# interface with `[ComImport]` + `[Guid]` + `[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]`.

```csharp
using System.Runtime.InteropServices;

namespace DebuggerNetMcp.Core.Interop;

/// <summary>
/// Minimal subset of IMetaDataImport used for field enumeration during object variable inspection.
/// Uses [ComImport] (not [GeneratedComInterface]) because the real interface has ~70 methods;
/// declaring a partial vtable with [GeneratedComInterface] would produce an incorrect vtable layout.
/// The real IMetaDataImport GUID is used so Marshal.GetObjectForIUnknown returns the correct RCW.
/// </summary>
[ComImport]
[Guid("7DAC8207-D3AE-4C75-9B67-92801A497D44")]
[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
internal interface IMetaDataImportMinimal
{
    // vtable slot 0 (after IUnknown): CloseEnum
    void CloseEnum(IntPtr hEnum);

    // vtable slot 1: CountEnum
    void CountEnum(IntPtr hEnum, out uint pulCount);

    // vtable slot 2: ResetEnum
    void ResetEnum(IntPtr hEnum, uint ulPos);

    // vtable slot 3: EnumTypeDefs
    void EnumTypeDefs(ref IntPtr phEnum,
        [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] uint[] rTypeDefs,
        uint cMax,
        out uint pcTypeDefs);

    // vtable slot 4: EnumInterfaceImpls
    void EnumInterfaceImpls(ref IntPtr phEnum,
        uint td,
        [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] uint[] rImpls,
        uint cMax,
        out uint pcImpls);

    // vtable slot 5: EnumTypeRefs
    void EnumTypeRefs(ref IntPtr phEnum,
        [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] uint[] rTypeRefs,
        uint cMax,
        out uint pcTypeRefs);

    // vtable slot 6: FindTypeDefByName
    void FindTypeDefByName(
        [MarshalAs(UnmanagedType.LPWStr)] string szTypeDef,
        uint tkEnclosingClass,
        out uint ptd);

    // vtable slot 7: GetScopeProps
    void GetScopeProps(
        IntPtr szName,
        uint cchName,
        out uint pchName,
        out Guid pmvid);

    // vtable slot 8: GetModuleFromScope
    void GetModuleFromScope(out uint pmd);

    // vtable slot 9: GetTypeDefProps
    void GetTypeDefProps(
        uint td,
        IntPtr szTypeDef,
        uint cchTypeDef,
        out uint pchTypeDef,
        out uint pdwTypeDefFlags,
        out uint ptkExtends);

    // vtable slot 10: GetInterfaceImplProps
    void GetInterfaceImplProps(uint iiImpl, out uint pClass, out uint ptkIface);

    // vtable slot 11: GetTypeRefProps
    void GetTypeRefProps(
        uint tr,
        out uint ptkResolutionScope,
        IntPtr szName,
        uint cchName,
        out uint pchName);

    // vtable slot 12: ResolveTypeRef
    void ResolveTypeRef(uint tr, in Guid riid, out object ppIScope, out uint ptd);

    // vtable slot 13: EnumMembers
    void EnumMembers(ref IntPtr phEnum, uint cl,
        [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] uint[] rMembers,
        uint cMax, out uint pcTokens);

    // vtable slot 14: EnumMembersWithName
    void EnumMembersWithName(ref IntPtr phEnum, uint cl,
        [MarshalAs(UnmanagedType.LPWStr)] string szName,
        [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] uint[] rMembers,
        uint cMax, out uint pcTokens);

    // vtable slot 15: EnumMethods
    void EnumMethods(ref IntPtr phEnum, uint cl,
        [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] uint[] rMethods,
        uint cMax, out uint pcTokens);

    // vtable slot 16: EnumMethodsWithName
    void EnumMethodsWithName(ref IntPtr phEnum, uint cl,
        [MarshalAs(UnmanagedType.LPWStr)] string szName,
        [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] uint[] rMethods,
        uint cMax, out uint pcTokens);

    // vtable slot 17: EnumFields  ← the one we actually call
    void EnumFields(ref IntPtr phEnum, uint cl,
        [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] uint[] rFields,
        uint cMax, out uint pcTokens);

    // vtable slot 18: EnumFieldsWithName
    void EnumFieldsWithName(ref IntPtr phEnum, uint cl,
        [MarshalAs(UnmanagedType.LPWStr)] string szName,
        [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] uint[] rFields,
        uint cMax, out uint pcTokens);

    // vtable slot 19: EnumParams
    void EnumParams(ref IntPtr phEnum, uint mb,
        [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] uint[] rParams,
        uint cMax, out uint pcTokens);

    // vtable slot 20: EnumMemberRefs
    void EnumMemberRefs(ref IntPtr phEnum, uint tkParent,
        [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] uint[] rMemberRefs,
        uint cMax, out uint pcTokens);

    // vtable slot 21: EnumMethodImpls
    void EnumMethodImpls(ref IntPtr phEnum, uint td,
        [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] uint[] rMethodBody,
        [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] uint[] rMethodDecl,
        uint cMax, out uint pcTokens);

    // vtable slot 22: EnumPermissionSets
    void EnumPermissionSets(ref IntPtr phEnum, uint tk, uint dwActions,
        [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] uint[] rPermission,
        uint cMax, out uint pcTokens);

    // vtable slot 23: FindMember
    void FindMember(uint td,
        [MarshalAs(UnmanagedType.LPWStr)] string szName,
        IntPtr pvSigBlob, uint cbSigBlob, out uint pmb);

    // vtable slot 24: FindMethod
    void FindMethod(uint td,
        [MarshalAs(UnmanagedType.LPWStr)] string szName,
        IntPtr pvSigBlob, uint cbSigBlob, out uint pmb);

    // vtable slot 25: FindField  ← used for named field lookup
    void FindField(uint td,
        [MarshalAs(UnmanagedType.LPWStr)] string szName,
        IntPtr pvSigBlob, uint cbSigBlob, out uint pmb);

    // vtable slot 26: FindMemberRef
    void FindMemberRef(uint td,
        [MarshalAs(UnmanagedType.LPWStr)] string szName,
        IntPtr pvSigBlob, uint cbSigBlob, out uint pmr);

    // vtable slot 27: GetMethodProps
    void GetMethodProps(uint mb, out uint pClass,
        IntPtr szMethod, uint cchMethod, out uint pchMethod,
        out uint pdwAttr, out IntPtr ppvSigBlob, out uint pcbSigBlob,
        out uint pulCodeRVA, out uint pdwImplFlags);

    // vtable slot 28: GetMemberRefProps
    void GetMemberRefProps(uint mr, out uint ptk,
        IntPtr szMember, uint cchMember, out uint pchMember,
        out IntPtr ppvSigBlob, out uint pbSig);

    // vtable slot 29: EnumProperties
    void EnumProperties(ref IntPtr phEnum, uint td,
        [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] uint[] rProperties,
        uint cMax, out uint pcProperties);

    // vtable slot 30: EnumEvents
    void EnumEvents(ref IntPtr phEnum, uint td,
        [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] uint[] rEvents,
        uint cMax, out uint pcEvents);

    // vtable slot 31: GetEventProps
    void GetEventProps(uint ev, out uint pClass,
        IntPtr szEvent, uint cchEvent, out uint pchEvent,
        out uint pdwEventFlags, out uint ptkEventType,
        out uint pmdAddOn, out uint pmdRemoveOn, out uint pmdFire,
        [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 11)] uint[] rmdOtherMethod,
        uint cMax, out uint pcOtherMethod);

    // vtable slot 32: EnumMethodSemantics
    void EnumMethodSemantics(ref IntPtr phEnum, uint mb,
        [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] uint[] rEventProp,
        uint cMax, out uint pcEventProp);

    // vtable slot 33: GetMethodSemantics
    void GetMethodSemantics(uint mb, uint tkEventProp, out uint pdwSemanticsFlags);

    // vtable slot 34: GetClassLayout
    void GetClassLayout(uint td, out uint pdwPackSize,
        IntPtr rFieldOffset, uint cMax, out uint pcFieldOffset, out uint pulClassSize);

    // vtable slot 35: GetFieldMarshal
    void GetFieldMarshal(uint tk, out IntPtr ppvNativeType, out uint pcbNativeType);

    // vtable slot 36: GetRVA
    void GetRVA(uint tk, out uint pulCodeRVA, out uint pdwImplFlags);

    // vtable slot 37: GetPermissionSetProps
    void GetPermissionSetProps(uint pm, out uint pdwAction,
        out IntPtr ppvPermission, out uint pcbPermission);

    // vtable slot 38: GetSigFromToken
    void GetSigFromToken(uint mdSig, out IntPtr ppvSig, out uint pcbSig);

    // vtable slot 39: GetModuleRefProps
    void GetModuleRefProps(uint mur, IntPtr szName, uint cchName, out uint pchName);

    // vtable slot 40: EnumModuleRefs
    void EnumModuleRefs(ref IntPtr phEnum,
        [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] uint[] rModuleRefs,
        uint cMax, out uint pcModuleRefs);

    // vtable slot 41: GetTypeSpecFromToken
    void GetTypeSpecFromToken(uint typespec, out IntPtr ppvSig, out uint pcbSig);

    // vtable slot 42: GetNameFromToken
    void GetNameFromToken(uint tk, out IntPtr pszUtf8NamePtr);

    // vtable slot 43: EnumUnresolvedMethods
    void EnumUnresolvedMethods(ref IntPtr phEnum,
        [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] uint[] rMethods,
        uint cMax, out uint pcTokens);

    // vtable slot 44: GetUserString
    void GetUserString(uint stk, IntPtr szString, uint cchString, out uint pchString);

    // vtable slot 45: GetPinvokeMap
    void GetPinvokeMap(uint tk, out uint pdwMappingFlags,
        IntPtr szImportName, uint cchImportName, out uint pchImportName,
        out uint pmrImportDLL);

    // vtable slot 46: EnumSignatures
    void EnumSignatures(ref IntPtr phEnum,
        [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] uint[] rSignatures,
        uint cMax, out uint pcSignatures);

    // vtable slot 47: EnumTypeSpecs
    void EnumTypeSpecs(ref IntPtr phEnum,
        [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] uint[] rTypeSpecs,
        uint cMax, out uint pcTypeSpecs);

    // vtable slot 48: EnumUserStrings
    void EnumUserStrings(ref IntPtr phEnum,
        [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] uint[] rStrings,
        uint cMax, out uint pcStrings);

    // vtable slot 49: GetParamForMethodIndex
    void GetParamForMethodIndex(uint md, uint ulParamSeq, out uint ppd);

    // vtable slot 50: EnumCustomAttributes
    void EnumCustomAttributes(ref IntPtr phEnum, uint tk, uint tkType,
        [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] uint[] rCustomAttributes,
        uint cMax, out uint pcCustomAttributes);

    // vtable slot 51: GetCustomAttributeProps
    void GetCustomAttributeProps(uint cv, out uint ptkObj, out uint ptkType,
        out IntPtr ppBlob, out uint pcbSize);

    // vtable slot 52: FindTypeRef
    void FindTypeRef(uint tkResolutionScope,
        [MarshalAs(UnmanagedType.LPWStr)] string szName, out uint ptr);

    // vtable slot 53: GetMemberProps  ← useful for GetFieldProps fallback
    void GetMemberProps(uint mb, out uint pClass,
        IntPtr szMember, uint cchMember, out uint pchMember,
        out uint pdwAttr, out IntPtr ppvSigBlob, out uint pcbSigBlob,
        out uint pulCodeRVA, out uint pdwImplFlags,
        out uint pdwCPlusTypeFlag, out IntPtr ppValue, out uint pcchValue);

    // vtable slot 54: GetFieldProps  ← the one we actually call for field names
    void GetFieldProps(uint mb, out uint pClass,
        IntPtr szField, uint cchField, out uint pchField,
        out uint pdwAttr, out IntPtr ppvSigBlob, out uint pcbSigBlob,
        out uint pdwCPlusTypeFlag, out IntPtr ppValue, out uint pcchValue);

    // vtable slot 55: GetPropertyProps
    void GetPropertyProps(uint prop, out uint pClass,
        IntPtr szProperty, uint cchProperty, out uint pchProperty,
        out uint pdwPropFlags, out IntPtr ppvSig, out uint pbSig,
        out uint pdwCPlusTypeFlag, out IntPtr ppDefaultValue, out uint pcchDefaultValue,
        out uint pmdSetter, out uint pmdGetter,
        [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 14)] uint[] rmdOtherMethod,
        uint cMax, out uint pcOtherMethod);

    // vtable slot 56: GetParamProps
    void GetParamProps(uint tk, out uint pmd, out uint pulSequence,
        IntPtr szName, uint cchName, out uint pchName,
        out uint pdwAttr, out uint pdwCPlusTypeFlag,
        out IntPtr ppValue, out uint pcchValue);

    // vtable slot 57: GetCustomAttributeByName
    void GetCustomAttributeByName(uint tkObj,
        [MarshalAs(UnmanagedType.LPWStr)] string szName,
        out IntPtr ppData, out uint pcbData);

    // vtable slot 58: IsValidToken
    [return: MarshalAs(UnmanagedType.Bool)]
    bool IsValidToken(uint tk);

    // vtable slot 59: GetNestedClassProps
    void GetNestedClassProps(uint tdNestedClass, out uint ptdEnclosingClass);

    // vtable slot 60: GetNativeCallConvFromSig
    void GetNativeCallConvFromSig(IntPtr pvSig, uint cbSig, out uint pCallConv);

    // vtable slot 61: IsGlobal
    void IsGlobal(uint pd, out int pbGlobal);
}
```

After creating the file, run `dotnet build /home/eduardo/Projects/DebuggerNetMcp/DebuggerNetMcp.sln` and verify it exits 0 with 0 errors. If there are compilation errors in `IMetaDataImport.cs` due to marshalling attributes on the placeholder methods, simplify any problematic method signature by replacing complex array/out params with `IntPtr` placeholders — the only methods we will ACTUALLY CALL at runtime are: `EnumFields` (slot 17), `GetFieldProps` (slot 54), `CloseEnum` (slot 0). All other methods just need to exist to maintain the correct vtable offset; their parameter types don't need to be semantically correct for the RCW to work.
  </action>
  <verify>
    Run: `dotnet build /home/eduardo/Projects/DebuggerNetMcp/DebuggerNetMcp.sln`
    Expected: Exit code 0, 0 errors, 0 warnings
    Check: `grep "GetToken" /home/eduardo/Projects/DebuggerNetMcp/src/DebuggerNetMcp.Core/Interop/ICorDebug.cs` should match
    Check: `grep "IMetaDataImportMinimal" /home/eduardo/Projects/DebuggerNetMcp/src/DebuggerNetMcp.Core/Interop/IMetaDataImport.cs` should match
    Check: `grep "7DAC8207" /home/eduardo/Projects/DebuggerNetMcp/src/DebuggerNetMcp.Core/Interop/IMetaDataImport.cs` should match
  </verify>
  <done>
    ICorDebug.cs has `GetToken(out uint pTypeDef)` on ICorDebugClass.
    IMetaDataImport.cs exists with IMetaDataImportMinimal using real IMetaDataImport GUID.
    dotnet build exits 0 with 0 errors.
  </done>
</task>

</tasks>

<verification>
- `dotnet build DebuggerNetMcp.sln` exits 0, 0 errors, 0 warnings
- `grep "GetToken" src/DebuggerNetMcp.Core/Interop/ICorDebug.cs` returns a match
- `grep "IMetaDataImportMinimal" src/DebuggerNetMcp.Core/Interop/IMetaDataImport.cs` returns a match
- `grep "7DAC8207" src/DebuggerNetMcp.Core/Interop/IMetaDataImport.cs` returns a match
</verification>

<success_criteria>
- ICorDebugClass stub has GetToken method
- IMetaDataImportMinimal interface exists with correct GUID and sufficient vtable methods to reach EnumFields (slot 17) and GetFieldProps (slot 54)
- Solution builds clean with 0 warnings
</success_criteria>

<output>
After completion, create `.planning/phases/03-debug-engine/03-01-SUMMARY.md`
</output>
