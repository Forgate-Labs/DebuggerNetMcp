---
phase: 03-debug-engine
plan: 05
type: execute
wave: 5
depends_on:
  - "03-04"
files_modified:
  - src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs
  - src/DebuggerNetMcp.Core/Engine/VariableReader.cs
autonomous: true
requirements:
  - ENGINE-07

must_haves:
  truths:
    - "GetStackTraceAsync returns a list of StackFrameInfo with method name, source file, line, and IL offset"
    - "GetLocalsAsync returns local variable names (from PDB) and values (from ICorDebugILFrame.GetLocalVariable) at the current breakpoint"
    - "EvaluateAsync returns an EvalResult with the string representation of the expression result"
    - "VariableReader.ReadObject enumerates object fields using IMetaDataImportMinimal.EnumFields + GetFieldProps"
  artifacts:
    - path: "src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs"
      provides: "Inspection methods: GetStackTraceAsync, GetLocalsAsync, EvaluateAsync"
      contains: "GetStackTraceAsync"
    - path: "src/DebuggerNetMcp.Core/Engine/VariableReader.cs"
      provides: "ReadObject implementation using IMetaDataImportMinimal for field names"
      contains: "IMetaDataImportMinimal"
  key_links:
    - from: "src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs"
      to: "src/DebuggerNetMcp.Core/Engine/VariableReader.cs"
      via: "VariableReader.ReadValue called in GetLocalsAsync for each local variable"
      pattern: "VariableReader\\.ReadValue"
    - from: "src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs"
      to: "src/DebuggerNetMcp.Core/Engine/PdbReader.cs"
      via: "PdbReader.FindLocation (or local name lookup) called to get variable names by slot index"
      pattern: "PdbReader\\."
    - from: "src/DebuggerNetMcp.Core/Engine/VariableReader.cs"
      to: "src/DebuggerNetMcp.Core/Interop/IMetaDataImport.cs"
      via: "IMetaDataImportMinimal cast from Marshal.GetObjectForIUnknown in ReadObject"
      pattern: "IMetaDataImportMinimal"
---

<objective>
Add variable inspection and stack trace methods to `DotnetDebugger.cs`, and complete the deferred `ReadObject` implementation in `VariableReader.cs` using `IMetaDataImportMinimal` for field name resolution.

Purpose: This plan completes the Phase 3 goal. After this plan, DotnetDebugger supports the full debug cycle: launch → breakpoint → inspect locals → step → inspect → continue → exit.

Output: GetStackTraceAsync, GetLocalsAsync, EvaluateAsync in DotnetDebugger.cs; ReadObject field enumeration in VariableReader.cs.
</objective>

<execution_context>
@/home/eduardo/.claude/get-shit-done/workflows/execute-plan.md
@/home/eduardo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-debug-engine/03-RESEARCH.md
@src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs
@src/DebuggerNetMcp.Core/Engine/VariableReader.cs
@src/DebuggerNetMcp.Core/Engine/PdbReader.cs
@src/DebuggerNetMcp.Core/Interop/ICorDebug.cs
@src/DebuggerNetMcp.Core/Interop/IMetaDataImport.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Complete ReadObject in VariableReader.cs using IMetaDataImportMinimal</name>
  <files>src/DebuggerNetMcp.Core/Engine/VariableReader.cs</files>
  <action>
Open `src/DebuggerNetMcp.Core/Engine/VariableReader.cs` and replace the `ReadObject` stub (which currently returns `new VariableInfo(name, "object", "<object>", [])`) with a real implementation.

**What ReadObject needs to do:**
1. Get the class token from `objectValue.GetClass(out ICorDebugClass cls)` then `cls.GetToken(out uint typedefToken)`
2. Get the module from `objectValue.GetClass` → `ICorDebugObjectValue.GetClass` → class → `cls.GetModule(out ICorDebugModule module)`
   **OR** pass the ICorDebugModule as a parameter to ReadObject.
3. Get `IMetaDataImportMinimal` from `module.GetMetaDataInterface(in iid, out IntPtr ppMeta)` → `Marshal.GetObjectForIUnknown(ppMeta)`
4. Enumerate fields: `EnumFields(ref hEnum, typedefToken, fieldDefs[], count, out fetched)` in a loop
5. For each field token: `GetFieldProps(fieldToken, out _, nameBuffer, cch, out pch, ...)` → extract name
6. For each field token: `objectValue.GetFieldValue(cls, fieldToken, out ICorDebugValue fieldVal)` → `ReadValue(fieldName, fieldVal, depth + 1)`

**The challenge:** `ICorDebugObjectValue` in `ICorDebug.cs` has `GetClass(out ICorDebugClass pClass)` and `GetFieldValue(ICorDebugClass pClass, uint fieldDef, out ICorDebugValue ppValue)`. Check the actual signatures in the file.

**Implementation to add:**

In `VariableReader.cs`, add a new overload or modify the existing `ReadObject` private method. Since `ReadObject` currently only gets `ICorDebugObjectValue`, you also need access to the `ICorDebugModule`. The cleanest approach is to:

1. In the `ReadValue` method's `object` case: when you call `ReadObject`, also try to extract the module:

```csharp
// In the CorElementType.Object / CorElementType.Class handling in ReadValue:
case CorElementType.Object:
case CorElementType.Class:
{
    if (depth > MaxDepth)
        return new VariableInfo(name, "object", "<max depth>", []);

    // Dereference if it's a reference type (ICorDebugReferenceValue)
    ICorDebugValue derefVal = val;
    if (val is ICorDebugReferenceValue refVal)
    {
        try { refVal.Dereference(out derefVal); }
        catch { return new VariableInfo(name, "object", "<null>", []); }
    }

    if (derefVal is not ICorDebugObjectValue objVal)
        return new VariableInfo(name, "object", "<not an object>", []);

    return ReadObject(name, objVal, depth);
}
```

Replace the body of the private `ReadObject` method with:

```csharp
private static VariableInfo ReadObject(string name, ICorDebugObjectValue objVal, int depth)
{
    const int FIELD_BUFFER_SIZE = 256;

    try
    {
        // Get the class and its typedef token
        objVal.GetClass(out ICorDebugClass cls);
        cls.GetToken(out uint typedefToken);
        cls.GetModule(out ICorDebugModule module);

        // Get IMetaDataImportMinimal from the module
        var iid = new Guid("7DAC8207-D3AE-4C75-9B67-92801A497D44");
        module.GetMetaDataInterface(in iid, out IntPtr ppMeta);
        if (ppMeta == IntPtr.Zero)
            return new VariableInfo(name, "object", "<no metadata>", []);

        var meta = (IMetaDataImportMinimal)Marshal.GetObjectForIUnknown(ppMeta);
        Marshal.Release(ppMeta);  // RCW now holds the reference

        // Enumerate fields
        var children = new List<VariableInfo>();
        IntPtr hEnum = IntPtr.Zero;

        try
        {
            var fieldTokens = new uint[32];
            while (true)
            {
                meta.EnumFields(ref hEnum, typedefToken, fieldTokens, (uint)fieldTokens.Length, out uint fetched);
                if (fetched == 0)
                    break;

                for (uint i = 0; i < fetched; i++)
                {
                    uint fieldToken = fieldTokens[i];
                    try
                    {
                        // Get field name
                        string fieldName = GetFieldName(meta, fieldToken, FIELD_BUFFER_SIZE);

                        // Get field value
                        objVal.GetFieldValue(cls, fieldToken, out ICorDebugValue fieldVal);
                        children.Add(VariableReader.ReadValue(fieldName, fieldVal, depth + 1));
                    }
                    catch { /* skip unreadable fields */ }
                }
            }
        }
        finally
        {
            meta.CloseEnum(hEnum);
        }

        return new VariableInfo(name, "object", $"{{fields: {children.Count}}}", children);
    }
    catch (Exception ex)
    {
        return new VariableInfo(name, "object", $"<error: {ex.Message}>", []);
    }
}

private static string GetFieldName(IMetaDataImportMinimal meta, uint fieldToken, int bufferSize)
{
    IntPtr nameBuffer = Marshal.AllocHGlobal(bufferSize * 2);  // Unicode chars
    try
    {
        meta.GetFieldProps(fieldToken,
            out _,           // pClass
            nameBuffer,      // szField
            (uint)bufferSize,
            out uint pchField,
            out _,           // pdwAttr
            out _,           // ppvSigBlob
            out _,           // pcbSigBlob
            out _,           // pdwCPlusTypeFlag
            out _,           // ppValue
            out _);          // pcchValue

        return Marshal.PtrToStringUni(nameBuffer, (int)pchField - 1) ?? $"<field_{fieldToken:X8}>";
    }
    finally
    {
        Marshal.FreeHGlobal(nameBuffer);
    }
}
```

**Import statement needed:** Add `using DebuggerNetMcp.Core.Interop;` to `VariableReader.cs` if not already there.

**If `ICorDebugClass.GetModule` is not yet on the stub:** Add `void GetModule(out ICorDebugModule pModule)` to `ICorDebugClass` in `ICorDebug.cs` (before `GetToken`).

After writing, build. Fix any signature mismatches by checking `ICorDebug.cs` for exact method signatures.
  </action>
  <verify>
    Run: `dotnet build /home/eduardo/Projects/DebuggerNetMcp/DebuggerNetMcp.sln`
    Expected: Exit code 0, 0 errors
    Run: `grep "IMetaDataImportMinimal" /home/eduardo/Projects/DebuggerNetMcp/src/DebuggerNetMcp.Core/Engine/VariableReader.cs`
    Expected: at least 1 match
    Run: `grep "EnumFields" /home/eduardo/Projects/DebuggerNetMcp/src/DebuggerNetMcp.Core/Engine/VariableReader.cs`
    Expected: 1 match
    Run: `grep "GetFieldProps" /home/eduardo/Projects/DebuggerNetMcp/src/DebuggerNetMcp.Core/Engine/VariableReader.cs`
    Expected: 1 match
  </verify>
  <done>
    ReadObject enumerates fields via IMetaDataImportMinimal.EnumFields + GetFieldProps.
    Field values read via ICorDebugObjectValue.GetFieldValue → VariableReader.ReadValue (recursive).
    GetFieldName uses Marshal.AllocHGlobal/PtrToStringUni for the IntPtr-based API.
    dotnet build exits 0.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add GetStackTraceAsync, GetLocalsAsync, EvaluateAsync to DotnetDebugger.cs</name>
  <files>src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs</files>
  <action>
Append the following inspection methods to `DotnetDebugger.cs` inside the class body.

**GetStackTraceAsync:**

```csharp
/// <summary>
/// Returns a snapshot of the current call stack.
/// Must be called while the debuggee is stopped (at a breakpoint, step, or pause).
/// </summary>
public async Task<IReadOnlyList<StackFrameInfo>> GetStackTraceAsync(CancellationToken ct = default)
{
    var tcs = new TaskCompletionSource<IReadOnlyList<StackFrameInfo>>(
        TaskCreationOptions.RunContinuationsAsynchronously);

    await DispatchAsync(() =>
    {
        try
        {
            var frames = new List<StackFrameInfo>();
            ICorDebugThread thread = GetCurrentThread();

            // Enumerate chains on the thread
            thread.EnumerateChains(out ICorDebugChainEnum chainEnum);
            var chains = new ICorDebugChain[1];
            int frameIndex = 0;

            while (true)
            {
                chainEnum.Next(1, chains, out uint fetched);
                if (fetched == 0) break;

                chains[0].EnumerateFrames(out ICorDebugFrameEnum frameEnum);
                var frameArr = new ICorDebugFrame[1];

                while (true)
                {
                    frameEnum.Next(1, frameArr, out uint frameFetched);
                    if (frameFetched == 0) break;

                    var frame = frameArr[0];
                    try
                    {
                        if (frame is ICorDebugILFrame ilFrame)
                        {
                            ilFrame.GetIP(out uint ip, out _);
                            frame.GetFunction(out ICorDebugFunction fn);
                            fn.GetToken(out uint methodToken);
                            fn.GetModule(out ICorDebugModule module);
                            module.GetName(512, out _, out IntPtr namePtr);
                            string dllPath = Marshal.PtrToStringUni(namePtr) ?? string.Empty;

                            // Try to get source location from PDB
                            string? sourceFile = null;
                            int? sourceLine = null;
                            try
                            {
                                var loc = PdbReader.FindSourceLocation(dllPath, (int)methodToken, (int)ip);
                                if (loc.HasValue)
                                {
                                    sourceFile = loc.Value.file;
                                    sourceLine = loc.Value.line;
                                }
                            }
                            catch { /* PDB not available — use token */ }

                            frames.Add(new StackFrameInfo(
                                frameIndex++,
                                $"0x{methodToken:X8}",
                                sourceFile,
                                sourceLine,
                                (int)ip));
                        }
                    }
                    catch { frameIndex++; /* skip unreadable frames */ }
                }
            }

            tcs.SetResult(frames);
        }
        catch (Exception ex) { tcs.SetException(ex); }
    }, ct);

    return await tcs.Task.WaitAsync(ct);
}
```

**Note:** `PdbReader.FindSourceLocation(dllPath, methodToken, ilOffset)` does not exist yet — PdbReader only has `FindLocation` (source→IL). Add a reverse lookup method `FindSourceLocation` to `PdbReader.cs` that maps `(dllPath, methodToken, ilOffset)` → `(file, line)?`. If this is out of scope for this task, use `null` for sourceFile/sourceLine and mark it as a future improvement with a TODO comment. The stack trace must still build and return data; source locations are best-effort.

**GetLocalsAsync:**

```csharp
/// <summary>
/// Returns local variables in the current stack frame.
/// Uses PDB slot→name mapping and ICorDebugILFrame.GetLocalVariable for values.
/// Must be called while stopped.
/// </summary>
public async Task<IReadOnlyList<VariableInfo>> GetLocalsAsync(CancellationToken ct = default)
{
    var tcs = new TaskCompletionSource<IReadOnlyList<VariableInfo>>(
        TaskCreationOptions.RunContinuationsAsynchronously);

    await DispatchAsync(() =>
    {
        try
        {
            const int CORDBG_E_IL_VAR_NOT_AVAILABLE = unchecked((int)0x80131304);
            var result = new List<VariableInfo>();

            ICorDebugThread thread = GetCurrentThread();
            thread.GetActiveFrame(out ICorDebugFrame frame);

            if (frame is not ICorDebugILFrame ilFrame)
            {
                tcs.SetResult(result);  // native frame — no locals
                return;
            }

            // Get the method token and dll path for PDB-based name lookup
            frame.GetFunction(out ICorDebugFunction fn);
            fn.GetToken(out uint methodToken);
            fn.GetModule(out ICorDebugModule module);
            module.GetName(512, out _, out IntPtr namePtr);
            string dllPath = Marshal.PtrToStringUni(namePtr) ?? string.Empty;

            // Get local variable names from PDB (slot index → name)
            Dictionary<int, string> localNames = new();
            try
            {
                localNames = PdbReader.GetLocalNames(dllPath, (int)methodToken);
            }
            catch { /* PDB not available — use generic names */ }

            // Enumerate locals by index
            for (uint i = 0; i < 256; i++)
            {
                try
                {
                    ilFrame.GetLocalVariable(i, out ICorDebugValue val);
                    string varName = localNames.TryGetValue((int)i, out string? n) ? n : $"local_{i}";
                    result.Add(VariableReader.ReadValue(varName, val));
                }
                catch (COMException ex) when (ex.HResult == CORDBG_E_IL_VAR_NOT_AVAILABLE)
                {
                    break;  // No more variables
                }
                catch
                {
                    break;  // Other errors — stop enumeration
                }
            }

            tcs.SetResult(result);
        }
        catch (Exception ex) { tcs.SetException(ex); }
    }, ct);

    return await tcs.Task.WaitAsync(ct);
}
```

**Note on PdbReader.GetLocalNames:** Add `public static Dictionary<int, string> GetLocalNames(string dllPath, int methodToken)` to `PdbReader.cs`. It should open the PDB, find the `MethodDebugInformation` for the method token, enumerate `LocalScope.Variables`, and return a `Dictionary<int, string>` mapping slot index → variable name. Use the existing `OpenPdbProvider` helper already in `PdbReader.cs`. If the method is not found or PDB is not available, return an empty dictionary.

**EvaluateAsync:**

```csharp
/// <summary>
/// Evaluates a simple expression in the context of the current frame.
/// Currently supports local variable lookup by name only (full expression eval requires ICorDebugEval
/// which needs a running runtime — deferred to future work).
/// </summary>
public async Task<EvalResult> EvaluateAsync(string expression, CancellationToken ct = default)
{
    var tcs = new TaskCompletionSource<EvalResult>(TaskCreationOptions.RunContinuationsAsynchronously);

    await DispatchAsync(() =>
    {
        try
        {
            // Simple implementation: look up local variable by name
            const int CORDBG_E_IL_VAR_NOT_AVAILABLE = unchecked((int)0x80131304);

            ICorDebugThread thread = GetCurrentThread();
            thread.GetActiveFrame(out ICorDebugFrame frame);

            if (frame is not ICorDebugILFrame ilFrame)
            {
                tcs.SetResult(new EvalResult(false, string.Empty, "No IL frame available"));
                return;
            }

            frame.GetFunction(out ICorDebugFunction fn);
            fn.GetToken(out uint methodToken);
            fn.GetModule(out ICorDebugModule module);
            module.GetName(512, out _, out IntPtr namePtr);
            string dllPath = Marshal.PtrToStringUni(namePtr) ?? string.Empty;

            Dictionary<int, string> localNames = new();
            try { localNames = PdbReader.GetLocalNames(dllPath, (int)methodToken); }
            catch { }

            // Find the slot matching the expression (variable name)
            var slotEntry = localNames.FirstOrDefault(kv =>
                kv.Value.Equals(expression, StringComparison.Ordinal));

            if (slotEntry.Value is null)
            {
                tcs.SetResult(new EvalResult(false, string.Empty,
                    $"Variable '{expression}' not found in current scope"));
                return;
            }

            try
            {
                ilFrame.GetLocalVariable((uint)slotEntry.Key, out ICorDebugValue val);
                var varInfo = VariableReader.ReadValue(expression, val);
                tcs.SetResult(new EvalResult(true, varInfo.Value, null));
            }
            catch (COMException ex) when (ex.HResult == CORDBG_E_IL_VAR_NOT_AVAILABLE)
            {
                tcs.SetResult(new EvalResult(false, string.Empty, "Variable not available at this location"));
            }
        }
        catch (Exception ex)
        {
            tcs.SetException(ex);
        }
    }, ct);

    return await tcs.Task.WaitAsync(ct);
}
```

After appending all three methods, also add `using System.Runtime.InteropServices;` to the top of `DotnetDebugger.cs` if not already present (needed for `Marshal.PtrToStringUni` and `COMException`).

Then add `PdbReader.GetLocalNames` to `PdbReader.cs` (see note above).

Build and fix any compilation errors.
  </action>
  <verify>
    Run: `dotnet build /home/eduardo/Projects/DebuggerNetMcp/DebuggerNetMcp.sln`
    Expected: Exit code 0, 0 errors
    Run: `grep "GetStackTraceAsync\|GetLocalsAsync\|EvaluateAsync" /home/eduardo/Projects/DebuggerNetMcp/src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs`
    Expected: 3 matches
    Run: `grep "GetLocalVariable" /home/eduardo/Projects/DebuggerNetMcp/src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs`
    Expected: at least 2 matches (GetLocalsAsync + EvaluateAsync)
    Run: `grep "CORDBG_E_IL_VAR_NOT_AVAILABLE" /home/eduardo/Projects/DebuggerNetMcp/src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs`
    Expected: at least 2 matches
    Run: `grep "GetLocalNames" /home/eduardo/Projects/DebuggerNetMcp/src/DebuggerNetMcp.Core/Engine/PdbReader.cs`
    Expected: 1 match
  </verify>
  <done>
    GetStackTraceAsync: traverses chains → frames, returns StackFrameInfo list with IL offsets; source location is best-effort from PDB.
    GetLocalsAsync: iterates GetLocalVariable by index with CORDBG_E_IL_VAR_NOT_AVAILABLE sentinel; names from PdbReader.GetLocalNames.
    EvaluateAsync: looks up local variable by name, returns EvalResult.
    PdbReader.GetLocalNames(dllPath, methodToken) returns slot→name dictionary from MethodDebugInformation.
    dotnet build exits 0 with 0 errors.
  </done>
</task>

</tasks>

<verification>
- `dotnet build DebuggerNetMcp.sln` exits 0 with 0 errors
- VariableReader.cs has IMetaDataImportMinimal, EnumFields, GetFieldProps
- DotnetDebugger.cs has GetStackTraceAsync, GetLocalsAsync, EvaluateAsync
- PdbReader.cs has GetLocalNames method
- grep "CORDBG_E_IL_VAR_NOT_AVAILABLE" in DotnetDebugger.cs → at least 2 matches
</verification>

<success_criteria>
- GetStackTraceAsync walks chains and frames, returns StackFrameInfo[] with IL offset; file/line are best-effort
- GetLocalsAsync: index loop with CORDBG_E_IL_VAR_NOT_AVAILABLE break; names from PDB slot map
- EvaluateAsync: variable name lookup → GetLocalVariable → VariableReader.ReadValue → EvalResult
- ReadObject in VariableReader.cs enumerates fields via IMetaDataImportMinimal (not placeholder)
- PdbReader.GetLocalNames opens PDB, reads MethodDebugInformation, returns slot→name map
- Phase 3 success criteria from ROADMAP all achievable after this plan completes
</success_criteria>

<output>
After completion, create `.planning/phases/03-debug-engine/03-05-SUMMARY.md`
</output>
