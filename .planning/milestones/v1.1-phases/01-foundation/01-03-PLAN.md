---
phase: 01-foundation
plan: 03
type: execute
wave: 2
depends_on:
  - 01-01
  - 01-02
files_modified:
  - build.sh
  - install.sh
autonomous: true
requirements:
  - INFRA-04
  - INFRA-05

must_haves:
  truths:
    - "build.sh compiles native library then managed solution in a single command"
    - "install.sh registers debugger-net MCP server at user scope via claude mcp add"
    - "Running build.sh from repo root exits 0 and produces lib/libdotnetdbg.so and managed build artifacts"
    - "install.sh is idempotent (safe to run multiple times)"
    - "install.sh uses SCRIPT_DIR-relative paths, not hardcoded absolute paths"
  artifacts:
    - path: "build.sh"
      provides: "Single-command build for native + managed"
      contains: "cmake"
    - path: "install.sh"
      provides: "MCP registration script"
      contains: "claude mcp add"
  key_links:
    - from: "build.sh"
      to: "native/CMakeLists.txt"
      via: "cmake -S native"
      pattern: "cmake.*native"
    - from: "build.sh"
      to: "DebuggerNetMcp.sln"
      via: "dotnet build"
      pattern: "dotnet build"
    - from: "install.sh"
      to: "src/DebuggerNetMcp.Mcp/DebuggerNetMcp.Mcp.csproj"
      via: "dotnet run --project"
      pattern: "dotnet.*run.*project"
---

<objective>
Write build.sh (native + managed build orchestration) and install.sh (MCP registration).

Purpose: Ties together both build systems into a single-command developer experience. install.sh replaces the old Python uv-based MCP registration with the new C# dotnet-based one.
Output: build.sh and install.sh, both executable and verified functional.
</objective>

<execution_context>
@/home/eduardo/.claude/get-shit-done/workflows/execute-plan.md
@/home/eduardo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write build.sh (CMake + dotnet orchestration)</name>
  <files>
    build.sh
  </files>
  <action>
    Create `build.sh` at the repo root. The CMakeLists.txt sets `LIBRARY_OUTPUT_DIRECTORY` to `${CMAKE_SOURCE_DIR}/../lib`, so libdotnetdbg.so is written directly to `lib/` — no copy step needed.

    ```bash
    #!/usr/bin/env bash
    set -euo pipefail

    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

    echo "==> Building native library (CMake)..."
    cmake -S "$SCRIPT_DIR/native" -B "$SCRIPT_DIR/native/build" -DCMAKE_BUILD_TYPE=Release
    cmake --build "$SCRIPT_DIR/native/build" --parallel

    echo "==> Building managed projects (dotnet)..."
    dotnet build "$SCRIPT_DIR/DebuggerNetMcp.sln" -c Release

    echo ""
    echo "==> Build complete."
    echo "    Native: $SCRIPT_DIR/lib/libdotnetdbg.so"
    echo "    Managed: dotnet build -c Release completed"
    ```

    Make it executable:
    ```bash
    chmod +x build.sh
    ```

    Key requirements:
    - `set -euo pipefail` — fail fast on any error
    - `SCRIPT_DIR` computed via `BASH_SOURCE[0]` — works from any working directory
    - CMake out-of-source build: `-S "$SCRIPT_DIR/native" -B "$SCRIPT_DIR/native/build"`
    - `--parallel` on cmake --build — uses all CPU cores
    - `dotnet build "$SCRIPT_DIR/DebuggerNetMcp.sln" -c Release` — solution-level build
    - No copy step needed (CMakeLists.txt outputs directly to lib/)
    - Do NOT run `dotnet restore` separately — `dotnet build` includes restore

    Verify build.sh works end-to-end:
    ```bash
    cd /home/eduardo/Projects/DebuggerNetMcp
    bash build.sh
    ```
  </action>
  <verify>
    ```bash
    cd /home/eduardo/Projects/DebuggerNetMcp

    # Run build.sh
    bash build.sh
    # Must exit 0

    # Verify native output exists
    ls lib/libdotnetdbg.so
    # Must exist

    # Verify managed build artifacts
    ls src/DebuggerNetMcp.Core/bin/Release/
    # Must contain net10.0/ directory

    # Verify build.sh is executable
    [ -x build.sh ] && echo "executable" || echo "not executable"
    ```
  </verify>
  <done>
    `bash build.sh` exits 0. `lib/libdotnetdbg.so` exists. Managed build artifacts present in `bin/Release/`. `build.sh` has executable permission.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write install.sh (MCP registration) and verify</name>
  <files>
    install.sh
  </files>
  <action>
    Create `install.sh` at the repo root. This replaces the old Python uv-based MCP registration.

    ```bash
    #!/usr/bin/env bash
    set -euo pipefail

    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    CLAUDE_BIN="${CLAUDE_BIN:-${HOME}/.local/bin/claude}"

    # Verify claude binary exists
    if ! command -v "$CLAUDE_BIN" &>/dev/null; then
        echo "ERROR: claude binary not found at $CLAUDE_BIN"
        echo "Set CLAUDE_BIN environment variable to the correct path."
        exit 1
    fi

    echo "==> Registering debugger-net MCP server..."

    # Remove existing registration (idempotent — ignore error if not registered)
    "$CLAUDE_BIN" mcp remove debugger-net -s user 2>/dev/null || true

    # Register with user scope, stdio transport
    # -e passes environment variables to the spawned dotnet process
    # -- separates mcp add options from the command to run
    # --no-build prevents dotnet from rebuilding on each MCP invocation (build.sh handles builds)
    "$CLAUDE_BIN" mcp add \
        -s user \
        -e DOTNET_ROOT="${DOTNET_ROOT:-${HOME}/.dotnet}" \
        -e LD_LIBRARY_PATH="$SCRIPT_DIR/lib${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}" \
        debugger-net \
        dotnet -- run \
            --project "$SCRIPT_DIR/src/DebuggerNetMcp.Mcp" \
            --no-build \
            -c Release

    echo "==> MCP server 'debugger-net' registered at user scope."
    echo "    Restart Claude Code to pick up the new registration."
    ```

    Make it executable:
    ```bash
    chmod +x install.sh
    ```

    Key requirements:
    - `CLAUDE_BIN` uses `~/.local/bin/claude` as default (verified location on this system)
    - `mcp remove ... || true` — idempotent, safe to re-run
    - `-s user` — user scope (not project/local scope)
    - `-e DOTNET_ROOT` — required for dotnet runtime discovery
    - `-e LD_LIBRARY_PATH` — makes lib/libdotnetdbg.so findable at runtime (Phase 3+ need)
    - `${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}` — safe append even if LD_LIBRARY_PATH is unset
    - `dotnet -- run --project ... --no-build -c Release` — the `--` separates claude mcp add args from the command
    - `--no-build` — prevents dotnet from rebuilding on each MCP invocation
    - Do NOT hardcode any absolute paths except via SCRIPT_DIR

    Verify install.sh runs without errors (actual MCP registration):
    ```bash
    cd /home/eduardo/Projects/DebuggerNetMcp
    bash install.sh
    # Verify registration was recorded
    ~/.local/bin/claude mcp list 2>/dev/null | grep debugger-net
    ```
  </action>
  <verify>
    ```bash
    cd /home/eduardo/Projects/DebuggerNetMcp

    # Run install.sh
    bash install.sh
    # Must exit 0

    # Verify registration exists
    ~/.local/bin/claude mcp list 2>/dev/null | grep "debugger-net"
    # Must show the registered server

    # Verify install.sh is executable
    [ -x install.sh ] && echo "executable" || echo "not executable"

    # Verify no hardcoded absolute paths (other than SCRIPT_DIR-based)
    grep -v "SCRIPT_DIR\|HOME\|DOTNET_ROOT\|CLAUDE_BIN\|LD_LIBRARY_PATH" install.sh | grep "^[^#].*/"
    # Should not show hardcoded paths like /home/eduardo/...
    ```
  </verify>
  <done>
    `bash install.sh` exits 0. `claude mcp list` shows `debugger-net` registered. `install.sh` has executable permission. Running install.sh a second time does not error (idempotent).
  </done>
</task>

</tasks>

<verification>
End-to-end Phase 1 verification (combines all plans):

```bash
cd /home/eduardo/Projects/DebuggerNetMcp

# Success criterion 1: No Python files
find . -name "*.py" -not -path "./.git/*" -not -path "./.planning/*" | wc -l
# Expected: 0

# Success criterion 2: dotnet build clean
dotnet build DebuggerNetMcp.sln -c Release
# Expected: Build succeeded, 0 Error(s)

# Success criterion 3: native symbols
nm -D lib/libdotnetdbg.so | grep " T dbg_" | wc -l
# Expected: 5

# Success criterion 4: build.sh works
bash build.sh
# Expected: exits 0

# Success criterion 5: MCP registered
~/.local/bin/claude mcp list | grep debugger-net
# Expected: debugger-net listed
```
</verification>

<success_criteria>
- `build.sh` exists, is executable, and runs cmake + dotnet build in sequence
- `install.sh` exists, is executable, and registers debugger-net at user scope via `claude mcp add`
- `bash build.sh` exits 0 from repo root
- `bash install.sh` exits 0 and is idempotent (safe to run multiple times)
- `~/.local/bin/claude mcp list` shows `debugger-net` after running install.sh
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md` following @/home/eduardo/.claude/get-shit-done/templates/summary.md
</output>
