---
phase: 04-mcp-server
plan: 02
type: execute
wave: 2
depends_on:
  - "04-01"
files_modified:
  - src/DebuggerNetMcp.Mcp/DebuggerTools.cs
autonomous: true
requirements:
  - MCP-02

must_haves:
  truths:
    - "dotnet build DebuggerNetMcp.sln compiles without errors or warnings"
    - "All 14 tools are registered: debug_launch, debug_attach, debug_set_breakpoint, debug_remove_breakpoint, debug_continue, debug_step_over, debug_step_into, debug_step_out, debug_variables, debug_evaluate, debug_stacktrace, debug_pause, debug_disconnect, debug_status"
    - "Every tool method has an explicit [McpServerTool(Name = 'debug_xxx')] attribute — no auto-naming"
    - "Execution-control tools (continue, step_over, step_into, step_out, pause) call WaitForEventAsync and include the event in their response"
    - "Inspection tools (variables, stacktrace, evaluate) return structured error JSON when process not stopped"
    - "debug_status returns session state without calling any DotnetDebugger methods"
    - "No Console.Write* calls exist in DebuggerTools.cs"
  artifacts:
    - path: "src/DebuggerNetMcp.Mcp/DebuggerTools.cs"
      provides: "14 MCP tool methods wrapping DotnetDebugger"
      min_lines: 200
      exports: ["DebuggerTools"]
  key_links:
    - from: "src/DebuggerNetMcp.Mcp/DebuggerTools.cs"
      to: "DebuggerNetMcp.Core.Engine.DotnetDebugger"
      via: "constructor injection: DebuggerTools(DotnetDebugger debugger)"
      pattern: "DotnetDebugger debugger"
    - from: "src/DebuggerNetMcp.Mcp/DebuggerTools.cs"
      to: "ModelContextProtocol.Server.McpServerToolAttribute"
      via: "[McpServerToolType] on class + [McpServerTool(Name=...)] on each method"
      pattern: "McpServerTool\\(Name"
    - from: "src/DebuggerNetMcp.Mcp/Program.cs"
      to: "src/DebuggerNetMcp.Mcp/DebuggerTools.cs"
      via: ".WithTools<DebuggerTools>() in Program.cs"
      pattern: "WithTools<DebuggerTools>"
---

<objective>
Create DebuggerTools.cs — the [McpServerToolType] class with all 14 tool methods that wrap DotnetDebugger and expose the full debug session over MCP stdio.

Purpose: This is the final wiring layer — each tool method is a thin adapter from MCP protocol to the DotnetDebugger engine built in Phase 3.
Output: A single file with 14 tool methods, session state tracking, and JSON serialization of all results.
</objective>

<execution_context>
@/home/eduardo/.claude/get-shit-done/workflows/execute-plan.md
@/home/eduardo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-mcp-server/04-RESEARCH.md
@.planning/phases/04-mcp-server/04-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DebuggerTools.cs with all 14 MCP tool methods</name>
  <files>
    src/DebuggerNetMcp.Mcp/DebuggerTools.cs
  </files>
  <action>
    Create `src/DebuggerNetMcp.Mcp/DebuggerTools.cs` as a new file.

    **File header and class declaration:**
    ```csharp
    using System.ComponentModel;
    using System.Text.Json;
    using ModelContextProtocol.Server;
    using DebuggerNetMcp.Core.Engine;

    [McpServerToolType]
    public sealed class DebuggerTools(DotnetDebugger debugger)
    {
        private string _state = "idle";  // idle | running | stopped | exited
    ```

    **DotnetDebugger API surface (confirmed via roslyn-nav from Phase 3):**
    ```
    Task LaunchAsync(string projectPath, string appDllPath, CancellationToken ct = default)
    Task AttachAsync(uint processId, CancellationToken ct = default)
    Task DisconnectAsync(CancellationToken ct = default)
    Task&lt;DebugEvent&gt; WaitForEventAsync(CancellationToken ct = default)
    Task ContinueAsync(CancellationToken ct = default)
    Task PauseAsync(CancellationToken ct = default)
    Task StepOverAsync(CancellationToken ct = default)
    Task StepIntoAsync(CancellationToken ct = default)
    Task StepOutAsync(CancellationToken ct = default)
    Task&lt;int&gt; SetBreakpointAsync(string dllPath, string sourceFile, int line, CancellationToken ct = default)
    Task RemoveBreakpointAsync(int breakpointId, CancellationToken ct = default)
    Task&lt;IReadOnlyList&lt;StackFrameInfo&gt;&gt; GetStackTraceAsync(CancellationToken ct = default)
    Task&lt;IReadOnlyList&lt;VariableInfo&gt;&gt; GetLocalsAsync(CancellationToken ct = default)
    Task&lt;EvalResult&gt; EvaluateAsync(string expression, CancellationToken ct = default)
    ```

    **DebugEvent hierarchy (from DebuggerNetMcp.Core.Engine.Models):**
    - `abstract record DebugEvent`
    - `sealed record StoppedEvent(string Reason, int ThreadId, StackFrameInfo? TopFrame) : DebugEvent`
    - `sealed record BreakpointHitEvent(int BreakpointId, int ThreadId, StackFrameInfo TopFrame) : DebugEvent`
    - `sealed record ExceptionEvent(string ExceptionType, string Message, int ThreadId, bool IsUnhandled) : DebugEvent`
    - `sealed record ExitedEvent(int ExitCode) : DebugEvent`
    - `sealed record OutputEvent(string Category, string Output) : DebugEvent`

    **State machine for _state field:**
    - Init: `"idle"`
    - LaunchAsync/AttachAsync success → `"running"`
    - ContinueAsync/StepXxx/PauseAsync called → `"running"` (before WaitForEventAsync)
    - WaitForEventAsync returns ExitedEvent → `"exited"`
    - WaitForEventAsync returns any other event → `"stopped"`
    - DisconnectAsync success → `"idle"`

    **Private helper — SerializeEvent:**
    ```csharp
    private static object SerializeEvent(DebugEvent ev) => ev switch
    {
        StoppedEvent e      => new { type = "stopped",       reason = e.Reason, threadId = e.ThreadId, topFrame = (object?)e.TopFrame },
        BreakpointHitEvent e => new { type = "breakpointHit", breakpointId = e.BreakpointId, threadId = e.ThreadId, topFrame = (object)e.TopFrame },
        ExceptionEvent e    => new { type = "exception",     exceptionType = e.ExceptionType, message = e.Message, threadId = e.ThreadId, isUnhandled = e.IsUnhandled },
        ExitedEvent e       => new { type = "exited",        exitCode = e.ExitCode },
        OutputEvent e       => new { type = "output",        category = e.Category, output = e.Output },
        _                   => new { type = "unknown" }
    };
    ```

    **Execution-control helper (avoids repetition for continue/step*/pause):**
    ```csharp
    private async Task&lt;string&gt; RunAndWait(Func&lt;Task&gt; operation, CancellationToken ct)
    {
        try
        {
            await operation();
            _state = "running";
            var ev = await debugger.WaitForEventAsync(ct);
            _state = ev is ExitedEvent ? "exited" : "stopped";
            return JsonSerializer.Serialize(new { success = true, state = _state, @event = SerializeEvent(ev) });
        }
        catch (Exception ex)
        {
            return JsonSerializer.Serialize(new { success = false, error = ex.Message });
        }
    }
    ```

    **All 14 tools — implement with these exact tool Names:**

    **1. debug_launch**
    ```csharp
    [McpServerTool(Name = "debug_launch"),
     Description("Build and launch a .NET project under the debugger. " +
                 "Returns when the process is created. Use debug_continue to run until a breakpoint.")]
    public async Task&lt;string&gt; Launch(
        [Description("Path to the .csproj file or project directory")] string projectPath,
        [Description("Path to the compiled .dll to debug (e.g. bin/Debug/net10.0/App.dll)")] string appDllPath,
        CancellationToken ct)
    {
        try
        {
            await debugger.LaunchAsync(projectPath, appDllPath, ct);
            _state = "running";
            return JsonSerializer.Serialize(new { success = true, state = _state });
        }
        catch (Exception ex)
        {
            return JsonSerializer.Serialize(new { success = false, error = ex.Message });
        }
    }
    ```

    **2. debug_attach**
    ```csharp
    [McpServerTool(Name = "debug_attach"),
     Description("Attach the debugger to a running .NET process by process ID.")]
    public async Task&lt;string&gt; Attach(
        [Description("The process ID to attach to")] uint processId,
        CancellationToken ct)
    {
        try
        {
            await debugger.AttachAsync(processId, ct);
            _state = "running";
            return JsonSerializer.Serialize(new { success = true, state = _state, pid = processId });
        }
        catch (Exception ex)
        {
            return JsonSerializer.Serialize(new { success = false, error = ex.Message });
        }
    }
    ```

    **3. debug_set_breakpoint**
    ```csharp
    [McpServerTool(Name = "debug_set_breakpoint"),
     Description("Set a breakpoint at a source file line. Returns the breakpoint ID needed to remove it later.")]
    public async Task&lt;string&gt; SetBreakpoint(
        [Description("Full path to the compiled .dll")] string dllPath,
        [Description("Source file name (e.g. Program.cs)")] string sourceFile,
        [Description("1-based source line number")] int line,
        CancellationToken ct)
    {
        try
        {
            var id = await debugger.SetBreakpointAsync(dllPath, sourceFile, line, ct);
            return JsonSerializer.Serialize(new { success = true, id, file = sourceFile, line });
        }
        catch (Exception ex)
        {
            return JsonSerializer.Serialize(new { success = false, error = ex.Message });
        }
    }
    ```

    **4. debug_remove_breakpoint**
    ```csharp
    [McpServerTool(Name = "debug_remove_breakpoint"),
     Description("Remove a previously set breakpoint by its ID.")]
    public async Task&lt;string&gt; RemoveBreakpoint(
        [Description("Breakpoint ID returned by debug_set_breakpoint")] int breakpointId,
        CancellationToken ct)
    {
        try
        {
            await debugger.RemoveBreakpointAsync(breakpointId, ct);
            return JsonSerializer.Serialize(new { success = true, id = breakpointId });
        }
        catch (Exception ex)
        {
            return JsonSerializer.Serialize(new { success = false, error = ex.Message });
        }
    }
    ```

    **5. debug_continue — uses RunAndWait helper**
    ```csharp
    [McpServerTool(Name = "debug_continue"),
     Description("Resume execution and wait for the next debug event (breakpoint hit, step complete, exception, or exit). Returns the event.")]
    public Task&lt;string&gt; Continue(CancellationToken ct) =>
        RunAndWait(() => debugger.ContinueAsync(ct), ct);
    ```

    **6. debug_step_over — uses RunAndWait helper**
    ```csharp
    [McpServerTool(Name = "debug_step_over"),
     Description("Step over the current source line without entering called methods. Returns the resulting debug event.")]
    public Task&lt;string&gt; StepOver(CancellationToken ct) =>
        RunAndWait(() => debugger.StepOverAsync(ct), ct);
    ```

    **7. debug_step_into — uses RunAndWait helper**
    ```csharp
    [McpServerTool(Name = "debug_step_into"),
     Description("Step into the current source line, entering any called methods. Returns the resulting debug event.")]
    public Task&lt;string&gt; StepInto(CancellationToken ct) =>
        RunAndWait(() => debugger.StepIntoAsync(ct), ct);
    ```

    **8. debug_step_out — uses RunAndWait helper**
    ```csharp
    [McpServerTool(Name = "debug_step_out"),
     Description("Step out of the current method and return to the caller. Returns the resulting debug event.")]
    public Task&lt;string&gt; StepOut(CancellationToken ct) =>
        RunAndWait(() => debugger.StepOutAsync(ct), ct);
    ```

    **9. debug_pause — uses RunAndWait helper**
    ```csharp
    [McpServerTool(Name = "debug_pause"),
     Description("Pause a running process and wait for the stopped event.")]
    public Task&lt;string&gt; Pause(CancellationToken ct) =>
        RunAndWait(() => debugger.PauseAsync(ct), ct);
    ```

    **10. debug_variables**
    ```csharp
    [McpServerTool(Name = "debug_variables"),
     Description("Get local variables at the current stopped position. Requires the process to be stopped at a breakpoint or step.")]
    public async Task&lt;string&gt; GetVariables(CancellationToken ct)
    {
        try
        {
            var locals = await debugger.GetLocalsAsync(ct);
            return JsonSerializer.Serialize(locals);
        }
        catch (Exception ex)
        {
            var hint = ex.Message.Contains("80131301", StringComparison.OrdinalIgnoreCase)
                ? " Process not stopped. Call debug_continue or debug_step_* first."
                : string.Empty;
            return JsonSerializer.Serialize(new { success = false, error = ex.Message + hint });
        }
    }
    ```

    **11. debug_stacktrace**
    ```csharp
    [McpServerTool(Name = "debug_stacktrace"),
     Description("Get the current call stack. Requires the process to be stopped at a breakpoint or step.")]
    public async Task&lt;string&gt; GetStackTrace(CancellationToken ct)
    {
        try
        {
            var frames = await debugger.GetStackTraceAsync(ct);
            return JsonSerializer.Serialize(frames);
        }
        catch (Exception ex)
        {
            var hint = ex.Message.Contains("80131301", StringComparison.OrdinalIgnoreCase)
                ? " Process not stopped. Call debug_continue or debug_step_* first."
                : string.Empty;
            return JsonSerializer.Serialize(new { success = false, error = ex.Message + hint });
        }
    }
    ```

    **12. debug_evaluate**
    ```csharp
    [McpServerTool(Name = "debug_evaluate"),
     Description("Evaluate a local variable name at the current stopped position. Requires the process to be stopped.")]
    public async Task&lt;string&gt; Evaluate(
        [Description("Variable name or simple expression to evaluate")] string expression,
        CancellationToken ct)
    {
        try
        {
            var result = await debugger.EvaluateAsync(expression, ct);
            return JsonSerializer.Serialize(result);
        }
        catch (Exception ex)
        {
            return JsonSerializer.Serialize(new { success = false, error = ex.Message });
        }
    }
    ```

    **13. debug_disconnect**
    ```csharp
    [McpServerTool(Name = "debug_disconnect"),
     Description("Disconnect from the debuggee and end the debug session.")]
    public async Task&lt;string&gt; Disconnect(CancellationToken ct)
    {
        try
        {
            await debugger.DisconnectAsync(ct);
            _state = "idle";
            return JsonSerializer.Serialize(new { success = true, state = _state });
        }
        catch (Exception ex)
        {
            return JsonSerializer.Serialize(new { success = false, error = ex.Message });
        }
    }
    ```

    **14. debug_status**
    ```csharp
    [McpServerTool(Name = "debug_status"),
     Description("Returns the current debugger state: idle (no session), running (process running), stopped (at breakpoint or step), or exited (process terminated).")]
    public Task&lt;string&gt; GetStatus(CancellationToken ct) =>
        Task.FromResult(JsonSerializer.Serialize(new { state = _state }));
    ```

    Close the class with `}`.

    **Critical rules (do not violate):**
    - `[McpServerTool(Name = "debug_xxx")]` on EVERY method — never rely on SDK auto-naming
    - `[Description("...")]` on the method AND on each non-CancellationToken parameter
    - Return type is `Task&lt;string&gt;` for all tools
    - CancellationToken parameter gets NO `[Description]` attribute — SDK injects it automatically
    - NEVER call `Console.Write*` or `Console.Error.Write*`
    - `RunAndWait` receives the operation as `Func&lt;Task&gt;` — capture `ct` in the lambda
  </action>
  <verify>
    Run: `dotnet build src/DebuggerNetMcp.Mcp/DebuggerNetMcp.Mcp.csproj`
    Expected: Build succeeded, 0 errors, 0 warnings.

    Run: `grep -c "McpServerTool(Name" src/DebuggerNetMcp.Mcp/DebuggerTools.cs`
    Expected: 14

    Run: `grep "debug_launch\|debug_attach\|debug_set_breakpoint\|debug_remove_breakpoint\|debug_continue\|debug_step_over\|debug_step_into\|debug_step_out\|debug_variables\|debug_evaluate\|debug_stacktrace\|debug_pause\|debug_disconnect\|debug_status" src/DebuggerNetMcp.Mcp/DebuggerTools.cs | wc -l`
    Expected: 14 (each tool name appears exactly once as Name= value)

    Run: `grep "Console\." src/DebuggerNetMcp.Mcp/DebuggerTools.cs`
    Expected: No output

    Run: `dotnet build DebuggerNetMcp.sln`
    Expected: Build succeeded, 0 errors across all projects.
  </verify>
  <done>
    DebuggerTools.cs exists at src/DebuggerNetMcp.Mcp/DebuggerTools.cs.
    14 [McpServerTool] methods present, each with explicit Name= attribute.
    dotnet build DebuggerNetMcp.Mcp exits 0.
    dotnet build DebuggerNetMcp.sln exits 0 (full solution clean).
    No Console.* calls in DebuggerTools.cs.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build DebuggerNetMcp.sln` exits 0, 0 errors across all 4 projects
2. `grep -c "McpServerTool(Name" src/DebuggerNetMcp.Mcp/DebuggerTools.cs` outputs 14
3. All 14 tool names confirmed in file: debug_launch, debug_attach, debug_set_breakpoint, debug_remove_breakpoint, debug_continue, debug_step_over, debug_step_into, debug_step_out, debug_variables, debug_evaluate, debug_stacktrace, debug_pause, debug_disconnect, debug_status
4. `grep Console src/DebuggerNetMcp.Mcp/DebuggerTools.cs` returns nothing
5. `grep "WaitForEventAsync" src/DebuggerNetMcp.Mcp/DebuggerTools.cs | wc -l` outputs at least 1 (in RunAndWait helper)
6. `grep "_state" src/DebuggerNetMcp.Mcp/DebuggerTools.cs | wc -l` outputs at least 6 (field + transitions)
</verification>

<success_criteria>
- DebuggerTools.cs exists and compiles as part of DebuggerNetMcp.Mcp (0 errors)
- All 14 tools have explicit Name= attributes with debug_ prefix
- Execution-control tools use RunAndWait helper which calls WaitForEventAsync and returns the event
- Inspection tools return structured error JSON when process is not stopped
- debug_status reads _state field directly without calling DotnetDebugger
- Full solution dotnet build DebuggerNetMcp.sln exits 0
</success_criteria>

<output>
After completion, create `.planning/phases/04-mcp-server/04-02-SUMMARY.md` following the summary template.
</output>
