---
phase: 07-exceptions-threading-attach
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs
  - src/DebuggerNetMcp.Mcp/DebuggerTools.cs
autonomous: true
requirements:
  - THRD-01
  - THRD-02
  - THRD-03

must_haves:
  truths:
    - "debug_variables called with a thread_id returns locals for that specific thread's active frame"
    - "debug_stacktrace called with a thread_id returns the call stack for that specific thread"
    - "debug_stacktrace called without a thread_id returns frames for ALL active threads as a threads array"
    - "debug_pause stops all threads (ICorDebugProcess.Stop(0) — already correct behavior, verified)"
    - "GetAllThreads() uses celt=1 loop to avoid LPArray marshaling issues with COM interop"
  artifacts:
    - path: "src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs"
      provides: "GetAllThreads helper + optional threadId on GetLocalsAsync/GetStackTraceAsync + GetAllThreadStackTracesAsync"
      contains: "GetAllThreads"
    - path: "src/DebuggerNetMcp.Mcp/DebuggerTools.cs"
      provides: "debug_variables thread_id param + debug_stacktrace thread_id param + all-threads output"
      contains: "thread_id"
  key_links:
    - from: "DebuggerTools.GetVariables"
      to: "DotnetDebugger.GetLocalsAsync(threadId)"
      via: "optional uint thread_id parameter"
      pattern: "GetLocalsAsync.*threadId"
    - from: "DebuggerTools.GetStackTrace"
      to: "DotnetDebugger.GetAllThreadStackTracesAsync OR GetStackTraceAsync(threadId)"
      via: "thread_id == 0 branches to all-threads path"
      pattern: "GetAllThreadStackTraces"
    - from: "DotnetDebugger.GetAllThreads"
      to: "ICorDebugController.EnumerateThreads"
      via: "celt=1 while loop"
      pattern: "EnumerateThreads"
---

<objective>
Add optional thread_id parameter to debug_variables and debug_stacktrace. When thread_id is
specified, inspection targets that specific thread. When no thread_id is given, debug_stacktrace
returns frames for all active threads. Confirm debug_pause already stops all threads.

Purpose: Multi-thread debugging requires targeting a specific thread for locals and call stack.
The all-threads stacktrace gives the full picture of concurrent execution.

Output: DotnetDebugger with GetAllThreads helper, GetLocalsAsync(threadId), GetStackTraceAsync(threadId),
and GetAllThreadStackTracesAsync. MCP tools with optional thread_id parameters.
</objective>

<execution_context>
@/home/eduardo/.claude/get-shit-done/workflows/execute-plan.md
@/home/eduardo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs
@src/DebuggerNetMcp.Core/Interop/ICorDebug.cs
@src/DebuggerNetMcp.Mcp/DebuggerTools.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: GetAllThreads helper + optional threadId in DotnetDebugger</name>
  <files>src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs</files>
  <action>
**Add GetAllThreads private helper** (right after the existing `GetCurrentThread()` method):

```csharp
/// <summary>
/// Returns all threads in the process using a celt=1 loop.
/// MUST be called on the debug thread (inside DispatchAsync).
/// Uses celt=1 to avoid ICorDebugThreadEnum.Next LPArray marshaling issues with
/// source-generated COM interop — the same pattern used for chain/frame enumeration.
/// </summary>
private List<ICorDebugThread> GetAllThreads()
{
    var threads = new List<ICorDebugThread>();
    if (_process is null) return threads;
    _process.EnumerateThreads(out ICorDebugThreadEnum threadEnum);
    var arr = new ICorDebugThread[1];
    while (true)
    {
        threadEnum.Next(1, arr, out uint fetched);
        if (fetched == 0) break;
        threads.Add(arr[0]);
    }
    return threads;
}

/// <summary>
/// Returns a specific thread by ID, or throws if not found.
/// MUST be called on the debug thread.
/// </summary>
private ICorDebugThread GetThreadById(uint threadId)
{
    _process!.GetThread(threadId, out ICorDebugThread thread);
    if (thread is null)
        throw new InvalidOperationException($"Thread {threadId} not found in process");
    return thread;
}
```

**Add new method GetAllThreadStackTracesAsync** (after the existing GetStackTraceAsync method):

```csharp
/// <summary>
/// Returns the call stack for every active thread in the process.
/// Each element is (ThreadId, Frames). MUST be called while stopped.
/// </summary>
public async Task<IReadOnlyList<(uint ThreadId, IReadOnlyList<StackFrameInfo> Frames)>>
    GetAllThreadStackTracesAsync(CancellationToken ct = default)
{
    var tcs = new TaskCompletionSource<IReadOnlyList<(uint, IReadOnlyList<StackFrameInfo>)>>(
        TaskCreationOptions.RunContinuationsAsynchronously);

    await DispatchAsync(() =>
    {
        try
        {
            var result = new List<(uint, IReadOnlyList<StackFrameInfo>)>();
            var threads = GetAllThreads();
            foreach (var thread in threads)
            {
                thread.GetID(out uint tid);
                var frames = GetStackFramesForThread(thread);
                result.Add((tid, frames));
            }
            tcs.SetResult(result);
        }
        catch (Exception ex) { tcs.SetException(ex); }
    }, ct);

    return await tcs.Task.WaitAsync(ct);
}
```

**Extract GetStackFramesForThread private helper** from the existing GetStackTraceAsync.
The current GetStackTraceAsync body walks chains/frames for a single thread. Extract that inner
logic into:

```csharp
/// <summary>
/// Walks the chain/frame tree for a single thread. MUST be called on the debug thread.
/// </summary>
private List<StackFrameInfo> GetStackFramesForThread(ICorDebugThread thread)
{
    var frames = new List<StackFrameInfo>();
    thread.EnumerateChains(out ICorDebugChainEnum chainEnum);
    var chains = new ICorDebugChain[1];
    int frameIndex = 0;

    while (true)
    {
        chainEnum.Next(1, chains, out uint chainFetched);
        if (chainFetched == 0) break;

        chains[0].EnumerateFrames(out ICorDebugFrameEnum frameEnum);
        var frameArr = new ICorDebugFrame[1];

        while (true)
        {
            frameEnum.Next(1, frameArr, out uint frameFetched);
            if (frameFetched == 0) break;

            var frame = frameArr[0];
            try
            {
                if (frame is ICorDebugILFrame ilFrame)
                {
                    ilFrame.GetIP(out uint ip, out _);
                    frame.GetFunction(out ICorDebugFunction fn);
                    fn.GetToken(out uint methodToken);
                    fn.GetModule(out ICorDebugModule module);

                    uint nameLen = 512;
                    IntPtr namePtr = Marshal.AllocHGlobal((int)(nameLen * 2));
                    string dllPath;
                    try
                    {
                        module.GetName(nameLen, out _, namePtr);
                        dllPath = Marshal.PtrToStringUni(namePtr) ?? string.Empty;
                    }
                    finally
                    {
                        Marshal.FreeHGlobal(namePtr);
                    }

                    frames.Add(new StackFrameInfo(
                        frameIndex++,
                        $"0x{methodToken:X8}",
                        null,
                        null,
                        (int)ip));
                }
                else
                {
                    frameIndex++;
                }
            }
            catch { frameIndex++; }
        }
    }
    return frames;
}
```

**Update GetStackTraceAsync** to accept an optional threadId and call the helper:

```csharp
public async Task<IReadOnlyList<StackFrameInfo>> GetStackTraceAsync(
    uint threadId = 0, CancellationToken ct = default)
{
    var tcs = new TaskCompletionSource<IReadOnlyList<StackFrameInfo>>(
        TaskCreationOptions.RunContinuationsAsynchronously);

    await DispatchAsync(() =>
    {
        try
        {
            ICorDebugThread thread = threadId != 0
                ? GetThreadById(threadId)
                : GetCurrentThread();
            tcs.SetResult(GetStackFramesForThread(thread));
        }
        catch (Exception ex) { tcs.SetException(ex); }
    }, ct);

    return await tcs.Task.WaitAsync(ct);
}
```

**Update GetLocalsAsync** to accept an optional threadId parameter. Add `uint threadId = 0`
as the first parameter. Inside the method, replace:
```csharp
ICorDebugThread thread = GetCurrentThread();
```
with:
```csharp
ICorDebugThread thread = threadId != 0 ? GetThreadById(threadId) : GetCurrentThread();
```
  </action>
  <verify>
    dotnet build src/DebuggerNetMcp.Core/ -c Release
    No compilation errors. Search confirms: GetAllThreads, GetThreadById, GetStackFramesForThread,
    GetAllThreadStackTracesAsync all present in DotnetDebugger.cs.
  </verify>
  <done>
    Core project builds. GetStackTraceAsync and GetLocalsAsync both accept optional threadId.
    GetAllThreadStackTracesAsync enumerates all threads via celt=1 loop.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update debug_variables and debug_stacktrace MCP tools with thread_id parameter</name>
  <files>src/DebuggerNetMcp.Mcp/DebuggerTools.cs</files>
  <action>
**Update debug_variables (GetVariables method):**

Replace the existing signature:
```csharp
public async Task<string> GetVariables(CancellationToken ct)
```
with:
```csharp
public async Task<string> GetVariables(
    [Description("Thread ID to inspect. 0 or omitted = use the current stopped thread.")] uint thread_id = 0,
    CancellationToken ct = default)
```
Replace `await debugger.GetLocalsAsync(ct)` with:
```csharp
await debugger.GetLocalsAsync(thread_id, ct)
```
Update the [Description] attribute on the tool to mention thread_id:
Append: " Pass thread_id to inspect a specific thread's locals."

**Update debug_stacktrace (GetStackTrace method):**

Replace the existing signature:
```csharp
public async Task<string> GetStackTrace(CancellationToken ct)
```
with:
```csharp
public async Task<string> GetStackTrace(
    [Description("Thread ID to get stack for. 0 or omitted = return all active threads.")] uint thread_id = 0,
    CancellationToken ct = default)
```

Replace the body:
```csharp
if (thread_id != 0)
{
    var frames = await debugger.GetStackTraceAsync(thread_id, ct);
    return JsonSerializer.Serialize(new { thread_id, frames });
}
else
{
    var allThreads = await debugger.GetAllThreadStackTracesAsync(ct);
    var threads = allThreads.Select(t => new { threadId = t.ThreadId, frames = t.Frames }).ToList();
    return JsonSerializer.Serialize(new { threads });
}
```

Add `using System.Linq;` at the top of DebuggerTools.cs if not already present.

Update the [Description] attribute on debug_stacktrace:
"Get the call stack. Without thread_id, returns frames for ALL active threads. With thread_id, returns frames for that specific thread. Requires the process to be stopped."
  </action>
  <verify>
    dotnet build src/ -c Release
    Full solution builds. grep for "thread_id" in DebuggerTools.cs confirms both debug_variables and debug_stacktrace have the parameter.
  </verify>
  <done>
    Full solution builds. debug_variables accepts thread_id, passes it to GetLocalsAsync.
    debug_stacktrace with thread_id=0 calls GetAllThreadStackTracesAsync and returns {threads:[...]};
    with non-zero thread_id calls GetStackTraceAsync(threadId) and returns {thread_id, frames:[...]}.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build src/ -c Release` — zero errors
2. `grep -n "GetAllThreads\|GetAllThreadStack\|GetStackFramesForThread" src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs` — all three found
3. `grep -n "thread_id" src/DebuggerNetMcp.Mcp/DebuggerTools.cs` — found in both GetVariables and GetStackTrace
4. `grep -n "uint threadId = 0" src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs` — found in GetLocalsAsync and GetStackTraceAsync
5. Confirm GetAllThreads uses `threadEnum.Next(1, arr, out uint fetched)` with single-element array (celt=1 pattern)
</verification>

<success_criteria>
- GetLocalsAsync and GetStackTraceAsync both accept optional uint threadId = 0
- When threadId != 0, both use GetThreadById(threadId) instead of GetCurrentThread()
- GetAllThreadStackTracesAsync enumerates all threads with celt=1 loop, returns list of (ThreadId, Frames) pairs
- debug_stacktrace with no args returns {threads: [{threadId, frames}, ...]}
- debug_variables with thread_id passes it down to GetLocalsAsync
- Full solution builds clean
</success_criteria>

<output>
After completion, create `.planning/phases/07-exceptions-threading-attach/07-02-SUMMARY.md`
</output>
