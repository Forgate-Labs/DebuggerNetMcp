---
phase: 07-exceptions-threading-attach
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/DebuggerNetMcp.Core/Engine/ManagedCallbackHandler.cs
  - src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs
  - src/DebuggerNetMcp.Mcp/DebuggerTools.cs
autonomous: true
requirements:
  - EXCP-01
  - EXCP-02

must_haves:
  truths:
    - "An unhandled exception event carries the real exception type name (e.g. DivideByZeroException), not '<unhandled>'"
    - "An unhandled exception event carries the real exception message (e.g. 'Attempted to divide by zero.'), not 'Unhandled exception'"
    - "Only one ExceptionEvent is written per unhandled exception — not two (no double-reporting from v1+v2 callbacks)"
    - "First-chance exceptions are silently continued by default (notifyFirstChanceExceptions=false)"
    - "When notifyFirstChanceExceptions=true is passed to debug_launch, thrown exceptions produce a stopping ExceptionEvent before the catch block runs"
  artifacts:
    - path: "src/DebuggerNetMcp.Core/Engine/ManagedCallbackHandler.cs"
      provides: "TryReadExceptionInfo helper + NotifyFirstChanceExceptions flag + double-reporting guard"
      contains: "TryReadExceptionInfo"
    - path: "src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs"
      provides: "LaunchAsync notifyFirstChanceExceptions parameter threaded through to handler"
      contains: "notifyFirstChanceExceptions"
    - path: "src/DebuggerNetMcp.Mcp/DebuggerTools.cs"
      provides: "debug_launch firstChanceExceptions optional bool"
      contains: "firstChanceExceptions"
  key_links:
    - from: "ManagedCallbackHandler.Exception (v1)"
      to: "ManagedCallbackHandler.TryReadExceptionInfo"
      via: "method call in bUnhandled != 0 branch"
      pattern: "TryReadExceptionInfo"
    - from: "ManagedCallbackHandler.Exception (v2)"
      to: "_exceptionStopPending guard"
      via: "bool flag set by v1, cleared by v2"
      pattern: "_exceptionStopPending"
    - from: "DotnetDebugger.LaunchAsync"
      to: "ManagedCallbackHandler.NotifyFirstChanceExceptions"
      via: "_callbackHandler.NotifyFirstChanceExceptions = notifyFirstChanceExceptions"
      pattern: "NotifyFirstChanceExceptions"
---

<objective>
Fix unhandled exception events to carry the real exception type name and message instead of
placeholder strings. Add first-chance notification support as an optional debug_launch parameter.
Guard against double-reporting caused by both v1 and v2 exception callbacks firing for the same event.

Purpose: Exception events are currently useless — they always say "<unhandled>" and "Unhandled exception".
After this plan, when a process throws DivideByZeroException the MCP caller sees the actual type and message.

Output: ManagedCallbackHandler with TryReadExceptionInfo + _exceptionStopPending guard;
DotnetDebugger.LaunchAsync with notifyFirstChanceExceptions param; debug_launch with firstChanceExceptions option.
</objective>

<execution_context>
@/home/eduardo/.claude/get-shit-done/workflows/execute-plan.md
@/home/eduardo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/DebuggerNetMcp.Core/Engine/ManagedCallbackHandler.cs
@src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs
@src/DebuggerNetMcp.Core/Engine/VariableReader.cs
@src/DebuggerNetMcp.Mcp/DebuggerTools.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: TryReadExceptionInfo + double-reporting guard in ManagedCallbackHandler</name>
  <files>src/DebuggerNetMcp.Core/Engine/ManagedCallbackHandler.cs</files>
  <action>
Add the following to ManagedCallbackHandler:

1. Add two new fields after the existing field declarations (before the constructor):
   ```csharp
   // Controls whether first-chance exceptions produce a stopping ExceptionEvent.
   // Set by DotnetDebugger.LaunchAsync before launching. Default false (continue silently).
   internal bool NotifyFirstChanceExceptions { get; set; }

   // Set by v1 Exception callback when it writes a stopping unhandled ExceptionEvent.
   // Prevents the v2 Exception callback from writing a duplicate stopping event.
   private bool _exceptionStopPending;
   ```

2. Replace the existing `TryGetTopFrame` helper with a new `TryReadExceptionInfo` helper
   (add as a new private static method near the bottom of the class, before TryGetTopFrame):
   ```csharp
   /// <summary>
   /// Reads the exception type name and message from the thread's current exception.
   /// Must be called while stopped in an exception callback (before any Continue call).
   /// </summary>
   private static (string typeName, string message) TryReadExceptionInfo(ICorDebugThread pThread)
   {
       try
       {
           pThread.GetCurrentException(out ICorDebugValue exVal);
           if (exVal == null) return ("<unknown>", "No exception available");

           // Dereference the reference value to get the actual exception object
           ICorDebugValue actual = exVal;
           if (exVal is ICorDebugReferenceValue rv)
           {
               rv.IsNull(out int isNull);
               if (isNull != 0) return ("<unknown>", "Exception reference is null");
               rv.Dereference(out ICorDebugValue inner);
               actual = inner;
           }

           string typeName = VariableReader.GetTypeName(actual) ?? "<unknown>";
           string message = "Unhandled exception";

           if (actual is ICorDebugObjectValue objVal)
           {
               objVal.GetClass(out ICorDebugClass cls);
               cls.GetModule(out ICorDebugModule module);
               cls.GetToken(out uint typedefToken);
               string dllPath = VariableReader.GetModulePath(module);

               // Read _message field — System.Exception stores message in private field _message.
               // Walk inheritance chain via VariableReader.ReadInstanceFieldsFromPE (same pattern
               // used successfully for DivideByZeroException in Phase 6 tests).
               string? found = TryReadStringField(objVal, dllPath, typedefToken, "_message");
               if (found != null) message = found;
           }

           return (typeName, message);
       }
       catch { return ("<unknown>", "Exception info unavailable"); }
   }

   /// <summary>
   /// Reads a single string field from an exception object by walking the inheritance chain.
   /// Returns null if the field is not found or cannot be read.
   /// </summary>
   private static string? TryReadStringField(
       ICorDebugObjectValue objVal, string dllPath, uint typedefToken, string fieldName)
   {
       uint current = typedefToken;
       while (current != 0)
       {
           var fields = VariableReader.ReadInstanceFieldsFromPE(dllPath, current);
           uint targetRid = 0;
           foreach (var (rid, name) in fields)
           {
               if (name == fieldName) { targetRid = rid; break; }
           }
           if (targetRid != 0)
           {
               try
               {
                   objVal.GetFieldValue(objVal.GetClass_(), targetRid, out ICorDebugValue fieldVal);
                   if (fieldVal is ICorDebugReferenceValue rv2)
                   {
                       rv2.IsNull(out int isNull);
                       if (isNull != 0) return null;
                       rv2.Dereference(out ICorDebugValue inner2);
                       if (inner2 is ICorDebugStringValue sv)
                           return sv.GetString_();
                   }
               }
               catch { /* field not readable in this frame */ }
               return null;
           }
           current = VariableReader.GetBaseTypeToken(dllPath, current);
       }
       return null;
   }
   ```

   IMPORTANT: `VariableReader.GetTypeName`, `VariableReader.GetModulePath`,
   `VariableReader.ReadInstanceFieldsFromPE`, and `VariableReader.GetBaseTypeToken` are
   currently `private static` in VariableReader.cs — they must be changed to `internal static`
   to be callable from ManagedCallbackHandler (same assembly). Do this as part of this task.

   Also note: `ICorDebugObjectValue.GetClass_()` and `ICorDebugStringValue.GetString_()` are
   the source-generated COM interop method names (trailing underscore due to C# keyword
   collision). Check the actual method names in ICorDebug.cs before using — they may differ.
   Use the pattern from VariableReader.ReadObject which already calls these successfully.

3. Replace the existing v1 `Exception` callback body:
   ```csharp
   public void Exception(ICorDebugAppDomain pAppDomain, ICorDebugThread pThread, int bUnhandled)
   {
       if (bUnhandled != 0)
       {
           // Second-chance (unhandled) — STOPPING event. Do NOT call Continue.
           try
           {
               pThread.GetID(out uint tid);
               CurrentStoppedThreadId = tid;
               var (exType, exMsg) = TryReadExceptionInfo(pThread);
               _exceptionStopPending = true;
               _events.TryWrite(new ExceptionEvent(exType, exMsg, (int)tid, true));
           }
           catch { pAppDomain.Continue(0); }
       }
       else if (NotifyFirstChanceExceptions)
       {
           // First-chance with notifications enabled — STOPPING event. Do NOT call Continue.
           try
           {
               pThread.GetID(out uint tid);
               CurrentStoppedThreadId = tid;
               var (exType, exMsg) = TryReadExceptionInfo(pThread);
               _events.TryWrite(new ExceptionEvent(exType, exMsg, (int)tid, false));
           }
           catch { pAppDomain.Continue(0); }
       }
       else
       {
           pAppDomain.Continue(0);  // first-chance: continue silently
       }
   }
   ```

4. Replace the existing v2 `Exception` callback body (ICorDebugManagedCallback2.Exception):
   ```csharp
   public void Exception(ICorDebugAppDomain pAppDomain, ICorDebugThread pThread,
       ICorDebugFrame? pFrame, uint nOffset,
       CorDebugExceptionCallbackType dwEventType, uint dwFlags)
   {
       if (dwEventType == CorDebugExceptionCallbackType.DEBUG_EXCEPTION_UNHANDLED)
       {
           if (_exceptionStopPending)
           {
               // v1 callback already handled this unhandled exception and wrote the stopping event.
               // Continue silently to avoid double-stopping and double-writing to the event channel.
               _exceptionStopPending = false;
               pAppDomain.Continue(0);
           }
           else
           {
               // v1 did not fire (should not happen on .NET 10) — handle here as fallback.
               try
               {
                   pThread.GetID(out uint tid);
                   CurrentStoppedThreadId = tid;
                   var (exType, exMsg) = TryReadExceptionInfo(pThread);
                   _events.TryWrite(new ExceptionEvent(exType, exMsg, (int)tid, true));
               }
               catch { pAppDomain.Continue(0); }
           }
       }
       else
       {
           // First-chance / catch-handler-found: continue silently.
           // First-chance notifications are handled in the v1 callback.
           pAppDomain.Continue(0);
       }
   }
   ```
  </action>
  <verify>
    dotnet build src/DebuggerNetMcp.Core/ -c Release
    Confirm no CS0122 (access errors) and no CS0103 (undefined names) in build output.
  </verify>
  <done>
    Core project builds clean. ManagedCallbackHandler has TryReadExceptionInfo, NotifyFirstChanceExceptions,
    and _exceptionStopPending. VariableReader helper methods are internal.
  </done>
</task>

<task type="auto">
  <name>Task 2: Thread notifyFirstChanceExceptions through DotnetDebugger.LaunchAsync and debug_launch MCP tool</name>
  <files>
    src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs
    src/DebuggerNetMcp.Mcp/DebuggerTools.cs
  </files>
  <action>
**DotnetDebugger.cs changes:**

1. Find `LaunchAsync` signature:
   ```csharp
   public async Task LaunchAsync(string projectPath, string appDllPath, CancellationToken ct = default)
   ```
   Change to:
   ```csharp
   public async Task LaunchAsync(string projectPath, string appDllPath,
       bool notifyFirstChanceExceptions = false,
       CancellationToken ct = default)
   ```

2. Inside LaunchAsync, immediately before the DispatchAsync call (where the launch happens),
   add:
   ```csharp
   _callbackHandler.NotifyFirstChanceExceptions = notifyFirstChanceExceptions;
   _callbackHandler.NotifyFirstChanceExceptions must be reset to false in DisconnectAsync as well,
   to avoid stale state across sessions.
   ```
   The exact location: add `_callbackHandler.NotifyFirstChanceExceptions = notifyFirstChanceExceptions;`
   right after `_callbackHandler.StopAtCreateProcess = true;` inside LaunchAsync.

3. In `DisconnectAsync`, add `_callbackHandler.NotifyFirstChanceExceptions = false;` alongside
   the other cleanup (e.g., after `_callbackHandler.SuppressExitProcess = false;` or similar
   cleanup lines).

**DebuggerTools.cs changes:**

1. Find the `Launch` method signature:
   ```csharp
   public async Task<string> Launch(
       [Description("Path to the .csproj file or project directory")] string projectPath,
       [Description("Path to the compiled .dll to debug ...")] string appDllPath,
       CancellationToken ct)
   ```
   Add a new optional parameter before CancellationToken:
   ```csharp
   [Description("If true, stop on every thrown exception (first-chance) before it is caught. " +
                "Default false. Warning: enabling this on apps that use exceptions for control " +
                "flow (JSON parsing, IO) can generate many events.")]
   bool firstChanceExceptions = false,
   ```

2. Change the `await debugger.LaunchAsync(projectPath, appDllPath, ct);` call to:
   ```csharp
   await debugger.LaunchAsync(projectPath, appDllPath, firstChanceExceptions, ct);
   ```

3. Update the debug_launch Description attribute to mention the firstChanceExceptions parameter:
   Append to existing description: " Use firstChanceExceptions=true to stop on thrown exceptions before they are caught."
  </action>
  <verify>
    dotnet build src/ -c Release
    Both Core and Mcp projects build with no errors.
  </verify>
  <done>
    Full solution builds. LaunchAsync accepts notifyFirstChanceExceptions bool, threads it to
    _callbackHandler. debug_launch MCP tool exposes firstChanceExceptions optional parameter.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build src/ -c Release` — zero errors, zero warnings about missing members
2. Search for `TryReadExceptionInfo` in ManagedCallbackHandler.cs — found
3. Search for `_exceptionStopPending` in ManagedCallbackHandler.cs — found in v1 and v2 Exception methods
4. Search for `NotifyFirstChanceExceptions` in ManagedCallbackHandler.cs and DotnetDebugger.cs — found in both
5. Search for `firstChanceExceptions` in DebuggerTools.cs — found as parameter on Launch method
6. Search for `internal static` on `GetTypeName`, `GetModulePath`, `ReadInstanceFieldsFromPE`, `GetBaseTypeToken`
   in VariableReader.cs — all four changed from private to internal
</verification>

<success_criteria>
- ExceptionEvent written by v1 Exception callback contains real type name and message read via TryReadExceptionInfo
- v2 Exception callback with DEBUG_EXCEPTION_UNHANDLED silently continues when _exceptionStopPending is true (no duplicate event)
- First-chance exceptions continue silently by default; when NotifyFirstChanceExceptions=true they produce stopping ExceptionEvent
- Full solution builds clean in Release configuration
</success_criteria>

<output>
After completion, create `.planning/phases/07-exceptions-threading-attach/07-01-SUMMARY.md`
</output>
