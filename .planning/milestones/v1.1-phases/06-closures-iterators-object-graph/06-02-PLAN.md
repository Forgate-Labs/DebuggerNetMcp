---
phase: 06-closures-iterators-object-graph
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/DebuggerNetMcp.Core/Engine/VariableReader.cs
autonomous: true
requirements: [GRAPH-01, GRAPH-02]

must_haves:
  truths:
    - "Inspecting an object where A.Self = A returns a VariableInfo with value '<circular reference>' instead of crashing or returning '<max depth>'"
    - "Computed properties (no backing field in PE) appear in the variable output with value '<computed>'"
    - "Auto-properties that already have a backing field are NOT duplicated in the output"
    - "Compiler-generated types (names starting with '<') are excluded from property enumeration to avoid spurious entries"
  artifacts:
    - path: "src/DebuggerNetMcp.Core/Engine/VariableReader.cs"
      provides: "ReadValue with optional visited HashSet parameter"
      contains: "HashSet<ulong>"
    - path: "src/DebuggerNetMcp.Core/Engine/VariableReader.cs"
      provides: "ReadObject with circular reference guard using GetAddress"
      contains: "<circular reference>"
    - path: "src/DebuggerNetMcp.Core/Engine/VariableReader.cs"
      provides: "ReadObjectFields with computed property enumeration"
      contains: "<computed>"
  key_links:
    - from: "VariableReader.ReadValue"
      to: "VariableReader.ReadObject"
      via: "visited HashSet threaded through call chain"
      pattern: "visited"
    - from: "VariableReader.ReadObject"
      to: "ICorDebugValue.GetAddress"
      via: "circular reference check before recursion"
      pattern: "GetAddress.*addr"
    - from: "VariableReader.ReadObjectFields"
      to: "typeDef.GetProperties()"
      via: "computed property enumeration after field loop"
      pattern: "GetProperties"
---

<objective>
Add circular reference detection and computed property reporting to VariableReader.

Purpose: Currently, a circular object graph (A.Self = A) hits `MaxDepth = 3` and returns `<max depth>` — acceptable but not informative. The correct fix threads a `HashSet<ulong>` of visited heap addresses through `ReadValue` → `ReadObject` → `ReadObjectFields`, returning `<circular reference>` on the second visit to any address. Computed properties (expression-bodied getters with no PE backing field) are currently absent from output — adding `typeDef.GetProperties()` enumeration after the field loop fills this gap.

Output: Modified `VariableReader.cs` with two independent changes: GRAPH-01 (visited set) and GRAPH-02 (computed property scan).
</objective>

<execution_context>
@/home/eduardo/.claude/get-shit-done/workflows/execute-plan.md
@/home/eduardo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-closures-iterators-object-graph/06-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Circular reference detection — thread HashSet&lt;ulong&gt; visited through ReadValue/ReadObject</name>
  <files>src/DebuggerNetMcp.Core/Engine/VariableReader.cs</files>
  <action>
Make two targeted changes to thread the visited set through the call chain.

**Change 1: ReadValue signature** (currently line 71, signature: `public static VariableInfo ReadValue(string name, ICorDebugValue value, int depth = 0)`)

Add an optional `visited` parameter with default `null`. Initialize it at the entry point so external callers are unaffected:

```csharp
public static VariableInfo ReadValue(string name, ICorDebugValue value, int depth = 0, HashSet<ulong>? visited = null)
{
    visited ??= new HashSet<ulong>();
    // ... rest of method unchanged
```

Update all recursive calls to `ReadValue` within this method to pass `visited`:
- The fallback `Dereference` path: `return ReadValue(name, derefFb, depth);` → `return ReadValue(name, derefFb, depth, visited);`

Update all calls to `ReadObject` and `ReadArray` to pass `visited` (see Change 2).

**Change 2: ReadObject signature** (currently line 344, signature: `private static VariableInfo ReadObject(string name, ICorDebugValue value, int depth, string typeName)`)

Add `HashSet<ulong> visited` parameter (NOT optional — internal method):

```csharp
private static VariableInfo ReadObject(string name, ICorDebugValue value, int depth, string typeName, HashSet<ulong> visited)
```

Inside `ReadObject`, after the `refVal.Dereference(out actualValue);` call and before `if (actualValue is not ICorDebugObjectValue objVal)`, add the circular reference guard:

```csharp
refVal.Dereference(out actualValue);

// Circular reference check: get heap address of dereferenced object
try
{
    actualValue.GetAddress(out ulong addr);
    if (addr != 0 && !visited.Add(addr))
    {
        return new VariableInfo(name, typeName, "<circular reference>", Array.Empty<VariableInfo>());
    }
}
catch { /* GetAddress failure is non-fatal; skip circular check */ }
```

Pass `visited` through to `ReadObjectFields`:
```csharp
return ReadObjectFields(name, typeName, objVal, depth, visited);
```

**Change 3: ReadObjectFields signature** (currently line 380)

Add `HashSet<ulong> visited` parameter:
```csharp
private static VariableInfo ReadObjectFields(string name, string typeName, ICorDebugObjectValue objVal, int depth, HashSet<ulong> visited)
```

Update all `ReadValue(displayName, fieldVal, depth + 1)` calls inside this method to pass `visited`:
```csharp
children.Add(ReadValue(displayName, fieldVal, depth + 1, visited));
```

Also update `ReadNullableValue` call at the top of ReadObjectFields if it internally calls ReadValue — check if it does and pass visited if needed.

**Change 4: Update callers of ReadObject and ReadArray in ReadValue**

In the `elementType switch` inside `ReadValue`, update the three `ReadObject` calls:
```csharp
CorElementType.Object   => ReadObject(name, value, depth, "object", visited),
CorElementType.Class    => ReadObject(name, value, depth, "object", visited),
CorElementType.ValueType => ReadObject(name, value, depth, "struct", visited),
```

Update `ReadArray` calls to pass `visited` too — ReadArray must also accept it and pass it through to any `ReadValue` calls it makes internally.

**ReadArray** (lines 294-338): Add `HashSet<ulong>? visited = null` parameter (optional for public-friendliness) or `HashSet<ulong> visited` (consistent internal). Since ReadArray is called from ReadValue which now always has a non-null visited, make it non-optional internally:
```csharp
private static VariableInfo ReadArray(string name, ICorDebugValue value, int depth, HashSet<ulong> visited)
```
Update all `ReadValue` calls inside `ReadArray` to pass `visited`.

Do NOT change the public API used by callers outside VariableReader (e.g., in DotnetDebugger.cs). `ReadValue` uses `HashSet<ulong>? visited = null` with `visited ??= new HashSet<ulong>();` — external callers continue to work without changes.
  </action>
  <verify>
Run: `dotnet build src/ 2>&1 | grep -E "^.*error|succeeded"`
Expected: Build succeeded with 0 errors.

Confirm visited parameter is present:
`grep -n "HashSet.*ulong\|circular reference\|visited" src/DebuggerNetMcp.Core/Engine/VariableReader.cs`
Expected: Multiple lines showing HashSet declaration, visited parameter, and `"<circular reference>"` string.
  </verify>
  <done>
Build succeeds. `ReadValue`, `ReadObject`, `ReadArray`, and `ReadObjectFields` all accept and thread the `HashSet<ulong> visited` parameter. External callers of `ReadValue(name, value)` continue to compile without changes (optional parameter). A circular object graph returns `<circular reference>` at the second visit.
  </done>
</task>

<task type="auto">
  <name>Task 2: Computed property reporting — enumerate PE properties after field loop in ReadObjectFields</name>
  <files>src/DebuggerNetMcp.Core/Engine/VariableReader.cs</files>
  <action>
In `ReadObjectFields` (lines 380-460), locate the line just before the `return` statement at the end of the method:

```csharp
string displayTypeName = GetTypeName(dllPath, typedefToken);
return new VariableInfo(name, displayTypeName, $"{{fields: {children.Count}}}", children);
```

Insert the computed property enumeration block BEFORE the `string displayTypeName` line:

```csharp
// GRAPH-02: Report computed properties (properties without a PE backing field).
// Skip compiler-generated types (display classes, state machines) — their "properties"
// are interface implementations, not user-visible computed properties.
try
{
    string concreteTypeName = GetTypeName(dllPath, typedefToken);
    bool isCompilerGenerated = concreteTypeName.StartsWith("<") || concreteTypeName.Contains(">d__") || concreteTypeName.Contains(">c__DisplayClass");
    if (!isCompilerGenerated)
    {
        // Collect all instance field names already added for backing-field check
        var instanceFieldNames = new HashSet<string>(
            ReadInstanceFieldsFromPE(dllPath, typedefToken).Values);

        using var propPeReader = new System.Reflection.PortableExecutable.PEReader(File.OpenRead(dllPath));
        var propMetadata = propPeReader.GetMetadataReader();
        int rowNum = (int)(typedefToken & 0x00FFFFFF);
        var propTypeHandle = System.Reflection.Metadata.MetadataTokens.TypeDefinitionHandle(rowNum);
        var propTypeDef = propMetadata.GetTypeDefinition(propTypeHandle);

        foreach (var propHandle in propTypeDef.GetProperties())
        {
            var prop = propMetadata.GetPropertyDefinition(propHandle);
            string propName = propMetadata.GetString(prop.Name);

            // Skip explicitly-implemented interface properties (contain '.')
            if (propName.Contains('.')) continue;

            string expectedBacking = $"<{propName}>k__BackingField";
            if (!instanceFieldNames.Contains(expectedBacking))
            {
                // No backing field found — this is a computed property
                children.Add(new VariableInfo(propName, "<computed>", "<computed>", Array.Empty<VariableInfo>()));
            }
        }
    }
}
catch { /* property scan is best-effort; PE read failures are non-fatal */ }
```

IMPORTANT: The `using` namespace for `File` is already available (`System.IO`). The `PEReader` and `MetadataTokens` types are from `System.Reflection.PortableExecutable` and `System.Reflection.Metadata` respectively — both already imported at the top of `VariableReader.cs`. Verify the existing `using` directives before adding any new ones.

IMPORTANT: `ReadInstanceFieldsFromPE` opens a new `PEReader` internally. This is the 2nd PEReader open in this method path — acceptable as best-effort for computed property detection. Do NOT try to reuse the internal PEReader from `ReadInstanceFieldsFromPE`; the extra open is cheap for local files.

The `children.Count` in the `return` below will now include the computed properties, which is correct.
  </action>
  <verify>
Run: `dotnet build src/ 2>&1 | grep -E "^.*error|succeeded"`
Expected: Build succeeded with 0 errors.

Confirm the key strings are present:
`grep -n "GetProperties\|computed\|isCompilerGenerated\|expectedBacking" src/DebuggerNetMcp.Core/Engine/VariableReader.cs`
Expected: All four strings present at the appropriate lines in `ReadObjectFields`.
  </verify>
  <done>
Build succeeds. `ReadObjectFields` now appends computed properties (those without `<PropName>k__BackingField` in the PE) as `VariableInfo` entries with value `"<computed>"`. Compiler-generated types are excluded. Auto-properties with backing fields are not duplicated.
  </done>
</task>

</tasks>

<verification>
Run the full solution build:
`dotnet build src/ 2>&1 | grep -E "error|warning|succeeded"`

Expected: Build succeeded, 0 errors.

Confirm all GRAPH-01 + GRAPH-02 indicators are in place:
```
grep -n "HashSet\|circular reference\|GetProperties\|computed\|isCompilerGenerated" \
  src/DebuggerNetMcp.Core/Engine/VariableReader.cs
```

Expected: At minimum 6 distinct lines covering HashSet declaration, visited parameter usage, `<circular reference>` return, `GetProperties()` call, `<computed>` entry, and compiler-generated guard.
</verification>

<success_criteria>
- `dotnet build src/` succeeds with 0 errors
- `ReadValue` public signature has `HashSet<ulong>? visited = null` optional parameter (external callers unaffected)
- `ReadObject` performs circular reference detection via `GetAddress()` + `visited.Add()`
- Objects already in the visited set return `VariableInfo` with value `"<circular reference>"`
- `ReadObjectFields` enumerates `typeDef.GetProperties()` after field loop and adds `<computed>` entries for properties without PE backing fields
- Compiler-generated types (names containing `>d__` or `>c__DisplayClass` or starting with `<`) are excluded from property enumeration
</success_criteria>

<output>
After completion, create `.planning/phases/06-closures-iterators-object-graph/06-02-SUMMARY.md`
</output>
