---
phase: 02-interop-engine-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/DebuggerNetMcp.Core/DebuggerNetMcp.Core.csproj
  - src/DebuggerNetMcp.Core/Interop/DbgShimInterop.cs
  - src/DebuggerNetMcp.Core/Interop/ICorDebug.cs
autonomous: true
requirements:
  - INTEROP-01
  - INTEROP-02

must_haves:
  truths:
    - "DbgShimInterop.Load() searches 6 candidate paths for libdbgshim.so and binds all 4 required function delegates"
    - "All 17 ICorDebug COM interfaces compile with [GeneratedComInterface] + correct [Guid] attributes on .NET 10 Linux"
    - "dotnet build completes without errors after both Interop files are added"
  artifacts:
    - path: "src/DebuggerNetMcp.Core/Interop/DbgShimInterop.cs"
      provides: "Runtime dynamic loading of libdbgshim.so with multi-path candidate search"
      exports: ["DbgShimInterop"]
    - path: "src/DebuggerNetMcp.Core/Interop/ICorDebug.cs"
      provides: "All 17 ICorDebug COM interface definitions for use by DotnetDebugger in Phase 3"
      exports: ["ICorDebug", "ICorDebugProcess", "ICorDebugThread", "ICorDebugFrame", "ICorDebugILFrame", "ICorDebugFunction", "ICorDebugModule", "ICorDebugValue", "ICorDebugGenericValue", "ICorDebugStringValue", "ICorDebugObjectValue", "ICorDebugArrayValue", "ICorDebugBreakpoint", "ICorDebugFunctionBreakpoint", "ICorDebugStepper", "ICorDebugManagedCallback", "ICorDebugManagedCallback2"]
  key_links:
    - from: "src/DebuggerNetMcp.Core/Interop/DbgShimInterop.cs"
      to: "/home/eduardo/.local/lib/netcoredbg/libdbgshim.so"
      via: "NativeLibrary.TryLoad with candidate path list"
      pattern: "NativeLibrary.TryLoad"
    - from: "src/DebuggerNetMcp.Core/Interop/ICorDebug.cs"
      to: "src/DebuggerNetMcp.Core/Engine/VariableReader.cs"
      via: "ICorDebugValue, ICorDebugGenericValue, ICorDebugStringValue, ICorDebugObjectValue, ICorDebugArrayValue interfaces"
      pattern: "ICorDebugValue"
---

<objective>
Build the COM interop layer: dynamic libdbgshim.so loading (DbgShimInterop.cs) and all 17 ICorDebug COM interface definitions (ICorDebug.cs) using [GeneratedComInterface] for cross-platform Linux support.

Purpose: Phase 3 (DotnetDebugger.cs) cannot start without ICorDebug interfaces and the ability to load libdbgshim.so at runtime. These two files are the foundation of the entire debugger engine.
Output: Interop/ directory with two files; csproj updated with AllowUnsafeBlocks.
</objective>

<execution_context>
@/home/eduardo/.claude/get-shit-done/workflows/execute-plan.md
@/home/eduardo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-interop-engine-foundation/02-RESEARCH.md

Key context from research:
- libdbgshim.so is at /home/eduardo/.local/lib/netcoredbg/libdbgshim.so on this machine (NOT in DOTNET_ROOT)
- [GeneratedComInterface] requires AllowUnsafeBlocks in csproj
- All interfaces must be partial; derived interfaces use C# inheritance, no `new` shadowing
- GUIDs confirmed for 5 interfaces; remaining 12 must be fetched from cordebug.idl at implementation time
- cordebug.idl URL: https://raw.githubusercontent.com/dotnet/runtime/main/src/coreclr/inc/cordebug.idl
- PSTARTUP_CALLBACK signature: delegate void(IntPtr pCordb, IntPtr parameter, int hr)
- ICorDebugManagedCallback requires [GeneratedComClass] on implementation class (not the interface)
- Anti-pattern: do NOT use [ComImport] — Linux-incompatible
- All interfaces must be in a single file (DebuggerNetMcp.Core assembly only — cross-assembly inheritance breaks vtable offsets in some .NET versions)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enable AllowUnsafeBlocks and create DbgShimInterop.cs</name>
  <files>
    src/DebuggerNetMcp.Core/DebuggerNetMcp.Core.csproj
    src/DebuggerNetMcp.Core/Interop/DbgShimInterop.cs
  </files>
  <action>
    **Step 1: Update csproj**
    Add `<AllowUnsafeBlocks>true</AllowUnsafeBlocks>` to the existing PropertyGroup in DebuggerNetMcp.Core.csproj. Required by [GeneratedComInterface] source generator.

    **Step 2: Create src/DebuggerNetMcp.Core/Interop/DbgShimInterop.cs**

    Namespace: DebuggerNetMcp.Core.Interop (file-scoped)

    Implement internal static class DbgShimInterop with:

    **Delegate types** (UnmanagedFunctionPointer where needed):
    ```
    internal delegate int RegisterForRuntimeStartupDelegate(
        uint processId,
        RuntimeStartupCallback callback,
        IntPtr parameter,
        out IntPtr unregisterToken);

    [UnmanagedFunctionPointer(CallingConvention.StdCall)]
    internal delegate void RuntimeStartupCallback(
        IntPtr pCordb,
        IntPtr parameter,
        int hr);

    internal delegate int CreateProcessForLaunchDelegate(
        [MarshalAs(UnmanagedType.LPWStr)] string lpCommandLine,
        bool bSuspendProcess,
        IntPtr lpEnvironment,
        [MarshalAs(UnmanagedType.LPWStr)] string? lpCurrentDirectory,
        out uint processId,
        out IntPtr resumeHandle);

    internal delegate int ResumeProcessDelegate(IntPtr resumeHandle);
    internal delegate int CloseResumeHandleDelegate(IntPtr resumeHandle);
    ```

    **Static fields** (public, initialized to null! stubs):
    - `public static RegisterForRuntimeStartupDelegate RegisterForRuntimeStartup = null!;`
    - `public static CreateProcessForLaunchDelegate CreateProcessForLaunch = null!;`
    - `public static ResumeProcessDelegate ResumeProcess = null!;`
    - `public static CloseResumeHandleDelegate CloseResumeHandle = null!;`
    - `private static nint _libHandle;`

    **public static void Load(string? dbgShimPath = null)** method:
    1. Build candidate list via BuildCandidateList(dbgShimPath)
    2. Iterate candidates with NativeLibrary.TryLoad(path, out _libHandle); break on first success
    3. If _libHandle == IntPtr.Zero: throw FileNotFoundException with message listing all attempted paths
    4. Bind each delegate: `RegisterForRuntimeStartup = Marshal.GetDelegateForFunctionPointer<RegisterForRuntimeStartupDelegate>(NativeLibrary.GetExport(_libHandle, "RegisterForRuntimeStartup"));`
    5. Bind CreateProcessForLaunch, ResumeProcess, CloseResumeHandle similarly

    **private static IEnumerable<string> BuildCandidateList(string? explicit)** method:
    Search order (yield each candidate, skip null/empty):
    1. explicit parameter (if not null)
    2. Environment.GetEnvironmentVariable("DBGSHIM_PATH") (if set)
    3. Path.Combine(Environment.GetEnvironmentVariable("DOTNET_ROOT") ?? "", "shared/Microsoft.NETCore.App") → enumerate subdirs, yield libdbgshim.so in each (newest version first via OrderByDescending)
    4. /usr/share/dotnet/shared/Microsoft.NETCore.App → same enumeration
    5. If NETCOREDBG_PATH env var set: yield Path.Combine(Path.GetDirectoryName(NETCOREDBG_PATH) ?? "", "libdbgshim.so")
    6. Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), ".local", "lib", "netcoredbg", "libdbgshim.so")
    7. "/usr/local/lib/netcoredbg/libdbgshim.so"

    **CRITICAL: GC lifetime guard** — add a private static field to keep the RuntimeStartupCallback delegate alive:
    `private static RuntimeStartupCallback? _startupCallbackRef;`
    Expose a public method: `public static void KeepAlive(RuntimeStartupCallback cb) => _startupCallbackRef = cb;`
    Phase 3 (DotnetDebugger.cs) must call KeepAlive before RegisterForRuntimeStartup to prevent GC collection of the callback before native code fires it.

    Usings: System.Runtime.InteropServices, System.IO, System.Collections.Generic, System.Linq
  </action>
  <verify>
    cd /home/eduardo/Projects/DebuggerNetMcp && dotnet build src/DebuggerNetMcp.Core/DebuggerNetMcp.Core.csproj -c Release --nologo -v q
    Expected: Build succeeded. 0 Warning(s). 0 Error(s).
  </verify>
  <done>
    DbgShimInterop.cs exists with Load(), BuildCandidateList(), KeepAlive(), and 4 bound delegates. AllowUnsafeBlocks is true in csproj. Build passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fetch GUIDs from cordebug.idl and create ICorDebug.cs</name>
  <files>src/DebuggerNetMcp.Core/Interop/ICorDebug.cs</files>
  <action>
    **Step 1: Fetch GUIDs from cordebug.idl**
    Fetch https://raw.githubusercontent.com/dotnet/runtime/main/src/coreclr/inc/cordebug.idl
    Extract the GUID for each of the 17 required interfaces by searching for `object ICorDebugXxx` blocks and their preceding `uuid(...)` lines.

    Required interfaces to extract GUIDs for:
    ICorDebug, ICorDebugController, ICorDebugProcess, ICorDebugThread, ICorDebugFrame, ICorDebugILFrame, ICorDebugFunction, ICorDebugModule, ICorDebugValue, ICorDebugGenericValue, ICorDebugStringValue, ICorDebugObjectValue, ICorDebugArrayValue, ICorDebugBreakpoint, ICorDebugFunctionBreakpoint, ICorDebugStepper, ICorDebugManagedCallback, ICorDebugManagedCallback2

    Known GUIDs (already confirmed — do not change):
    - ICorDebug: 3D6F5F61-7538-11D3-8D5B-00104B35E7EF
    - ICorDebugController: 3D6F5F62-7538-11D3-8D5B-00104B35E7EF
    - ICorDebugProcess: 3D6F5F64-7538-11D3-8D5B-00104B35E7EF
    - ICorDebugManagedCallback: 3D6F5F60-7538-11D3-8D5B-00104B35E7EF
    - ICorDebugManagedCallback2: 250E5EEA-DB5C-4C76-B6F3-8C46F12E3203

    For the remaining 12, extract exact GUIDs from the IDL. The IDL has `uuid(GUID-HERE)` immediately before each interface definition.

    **Step 2: Create src/DebuggerNetMcp.Core/Interop/ICorDebug.cs**

    Namespace: DebuggerNetMcp.Core.Interop (file-scoped)
    Usings: System.Runtime.InteropServices, System.Runtime.InteropServices.Marshalling

    Define each interface using the pattern:
    ```csharp
    [GeneratedComInterface]
    [Guid("GUID-FROM-IDL")]
    internal partial interface ICorDebugXxx
    {
        // methods
    }
    ```

    **Rules for all interfaces:**
    - All must be `partial` and `internal`
    - Derived interfaces use C# inheritance: `ICorDebugProcess : ICorDebugController`
    - Do NOT use `new` keyword to shadow base methods
    - Method return type is `void` (HRESULT is implicit); the source generator handles HRESULT checking
    - Use `out` for output parameters; last `out` param becomes the logical return value
    - Parameters use managed types where appropriate: `string` for LPCWSTR, `uint` for ULONG32, `int` for LONG/ULONG32 when signed semantics needed

    **Inheritance hierarchy (must be correct):**
    - ICorDebugController → (base, no parent beyond IUnknown implicit)
    - ICorDebugProcess : ICorDebugController
    - ICorDebugFrame → (base)
    - ICorDebugILFrame : ICorDebugFrame

    **Required methods per interface (minimum for Phase 3 compilation — include all methods from the IDL for the listed interfaces, not just the ones Phase 3 uses):**

    ICorDebug: Initialize(), Terminate(), SetManagedHandler(ICorDebugManagedCallback pCallback), SetUnmanagedHandler(ICorDebugUnmanagedCallback pCallback), CreateProcess(...), DebugActiveProcess(uint id, bool win32Attach, out ICorDebugProcess ppProcess), EnumerateProcesses(out ICorDebugProcessEnum ppProcess), GetProcess(uint dwProcessId, out ICorDebugProcess ppProcess), CanLaunchOrAttach(uint dwProcessId, bool win32DebuggingEnabled)

    ICorDebugController: Stop(uint dwTimeoutIgnored), Continue(bool fIsOutOfBand), IsRunning(out int pbRunning), HasQueuedCallbacks(ICorDebugThread? pThread, out int pbQueued), EnumerateThreads(out ICorDebugThreadEnum ppThreads), SetAllThreadsDebugState(CorDebugThreadState state, ICorDebugThread? pExceptThisThread), Detach(), Terminate(uint exitCode), CanCommitChanges(uint cSnapshots, ref ICorDebugEditAndContinueSnapshot pSnapshots, out ICorDebugErrorInfoEnum pError), CommitChanges(uint cSnapshots, ref ICorDebugEditAndContinueSnapshot pSnapshots, out ICorDebugErrorInfoEnum pError)

    ICorDebugProcess: (inherits ICorDebugController) GetID(out uint pdwProcessId), GetHandle(out IntPtr phProcessHandle), GetThread(uint dwThreadId, out ICorDebugThread ppThread), EnumerateObjects(out ICorDebugObjectEnum ppObjects), IsTransitionStub(ulong address, out int pbTransitionStub), IsOSSuspended(uint threadId, out int pbSuspended), GetThreadContext(uint threadId, uint contextSize, IntPtr context), SetThreadContext(uint threadId, uint contextSize, IntPtr context), ReadMemory(ulong address, uint size, byte[] buffer, out nuint read), WriteMemory(ulong address, uint size, byte[] buffer, out nuint written), ClearCurrentException(uint threadId), EnableLogMessages(int fOnOff), ModifyLogSwitch([MarshalAs(UnmanagedType.LPWStr)] string pLogSwitchName, int lLevel), EnumerateAppDomains(out ICorDebugAppDomainEnum ppAppDomains), GetObject(out ICorDebugValue ppObject), ThreadForFiberCookie(uint fiberCookie, out ICorDebugThread ppThread), GetHelperThreadID(out uint pThreadID)

    ICorDebugThread: GetProcess(out ICorDebugProcess ppProcess), GetID(out uint pdwThreadId), GetHandle(out IntPtr phThreadHandle), GetAppDomain(out ICorDebugAppDomain ppAppDomain), SetDebugState(CorDebugThreadState state), GetDebugState(out CorDebugThreadState pState), GetUserState(out CorDebugUserState pState), GetCurrentException(out ICorDebugValue ppExceptionObject), ClearCurrentException(), CreateStepper(out ICorDebugStepper ppStepper), EnumerateChains(out ICorDebugChainEnum ppChains), GetActiveChain(out ICorDebugChain ppChain), GetActiveFrame(out ICorDebugFrame ppFrame), GetRegisterSet(out ICorDebugRegisterSet ppRegisters), CreateEval(out ICorDebugEval ppEval), GetObject(out ICorDebugValue ppObject)

    ICorDebugFrame: GetChain(out ICorDebugChain ppChain), GetCode(out ICorDebugCode ppCode), GetFunction(out ICorDebugFunction ppFunction), GetFunctionToken(out uint pToken), GetStackRange(out ulong pStart, out ulong pEnd), GetCaller(out ICorDebugFrame ppFrame), GetCallee(out ICorDebugFrame ppCallee), CreateStepper(out ICorDebugStepper ppStepper)

    ICorDebugILFrame: (inherits ICorDebugFrame) GetIP(out uint pnOffset, out CorDebugMappingResult pMappingResult), SetIP(uint nOffset), EnumerateLocalVariables(out ICorDebugValueEnum ppValueEnum), GetLocalVariable(uint dwIndex, out ICorDebugValue ppValue), EnumerateArguments(out ICorDebugValueEnum ppValueEnum), GetArgument(uint dwIndex, out ICorDebugValue ppValue), GetStackDepth(out uint pDepth), GetStackValue(uint dwIndex, out ICorDebugValue ppValue), CanSetIP(uint nOffset)

    ICorDebugFunction: GetModule(out ICorDebugModule ppModule), GetClass(out ICorDebugClass ppClass), GetToken(out uint pMethodDef), GetILCode(out ICorDebugCode ppCode), GetNativeCode(out ICorDebugCode ppCode), CreateBreakpoint(out ICorDebugFunctionBreakpoint ppBreakpoint), GetLocalVarSigToken(out uint pmdSig), GetCurrentVersionNumber(out uint pnCurrentVersion), GetVersionNumber(out uint pnVersion)

    ICorDebugModule: GetProcess(out ICorDebugProcess ppProcess), GetBaseAddress(out ulong pAddress), GetAssembly(out ICorDebugAssembly ppAssembly), GetName(uint cchName, out uint pcchName, char[] szName), EnableJITDebugging(int bTrackJITInfo, int bAllowJitOpts), EnableClassLoadCallbacks(int bClassLoadCallbacks), GetFunctionFromToken(uint methodDef, out ICorDebugFunction ppFunction), GetFunctionFromRVA(ulong rva, out ICorDebugFunction ppFunction), GetClassFromToken(uint typeDef, out ICorDebugClass ppClass), CreateBreakpoint(out ICorDebugModuleBreakpoint ppBreakpoint), GetEditAndContinueSnapshot(out ICorDebugEditAndContinueSnapshot ppEditAndContinueSnapshot), GetMetaDataInterface([MarshalAs(UnmanagedType.LPStruct)] Guid riid, [MarshalAs(UnmanagedType.IUnknown)] out object ppObj), GetToken(out uint pToken), IsDynamic(out int pbDynamic), GetGlobalVariableValue(uint fieldDef, out ICorDebugValue ppValue), GetSize(out uint pcBytes), IsInMemory(out int pbInMemory)

    ICorDebugValue: GetType(out uint pType), GetSize(out uint pSize), GetAddress(out ulong pAddress), CreateBreakpoint(out ICorDebugValueBreakpoint ppBreakpoint)

    ICorDebugGenericValue: (inherits ICorDebugValue) GetValue(byte[] pTo), SetValue(byte[] pFrom)

    ICorDebugStringValue: (inherits ICorDebugHeapValue) GetLength(out uint pcchString), GetString(uint cchString, out uint pcchString, char[] szString)

    ICorDebugObjectValue: (inherits ICorDebugValue) GetClass(out ICorDebugClass ppClass), GetFieldValue(ICorDebugClass pClass, uint fieldDef, out ICorDebugValue ppValue), GetVirtualMethod(uint memberRef, out ICorDebugFunction ppFunction), GetContext(out ICorDebugContext ppContext), IsValueClass(out int pbIsValueClass), GetManagedCopy([MarshalAs(UnmanagedType.IUnknown)] out object ppObject), SetFromManagedCopy([MarshalAs(UnmanagedType.IUnknown)] object pObject)

    ICorDebugArrayValue: (inherits ICorDebugHeapValue) GetElementType(out uint pType), GetRank(out uint pnRank), GetCount(out uint pnCount), GetDimensions(uint cdim, uint[] dims), HasBaseIndicies(out int pbHasBaseIndicies), GetBaseIndicies(uint cdim, uint[] indicies), GetElement(uint cdim, uint[] indices, out ICorDebugValue ppValue), GetElementAtPosition(uint nPosition, out ICorDebugValue ppValue)

    ICorDebugBreakpoint: Activate(int bActive), IsActive(out int pbActive)

    ICorDebugFunctionBreakpoint: (inherits ICorDebugBreakpoint) GetFunction(out ICorDebugFunction ppFunction), GetOffset(out uint pnOffset)

    ICorDebugStepper: IsActive(out int pbActive), Deactivate(), SetInterceptMask(CorDebugIntercept mask), SetUnmappedStopMask(CorDebugUnmappedStop mask), Step(int bStepIn), StepRange(int bStepIn, COR_DEBUG_STEP_RANGE[] ranges, uint cRangeCount), StepOut(), SetRangeIL(int bIL)

    ICorDebugManagedCallback: Breakpoint(ICorDebugAppDomain pAppDomain, ICorDebugThread pThread, ICorDebugBreakpoint pBreakpoint), StepComplete(ICorDebugAppDomain pAppDomain, ICorDebugThread pThread, ICorDebugStepper pStepper, CorDebugStepReason reason), Break(ICorDebugAppDomain pAppDomain, ICorDebugThread pThread), Exception(ICorDebugAppDomain pAppDomain, ICorDebugThread pThread, int bUnhandled), EvalComplete(ICorDebugAppDomain pAppDomain, ICorDebugThread pThread, ICorDebugEval pEval), EvalException(ICorDebugAppDomain pAppDomain, ICorDebugThread pThread, ICorDebugEval pEval), CreateProcess(ICorDebugProcess pProcess), ExitProcess(ICorDebugProcess pProcess), CreateThread(ICorDebugAppDomain pAppDomain, ICorDebugThread pThread), ExitThread(ICorDebugAppDomain pAppDomain, ICorDebugThread pThread), LoadModule(ICorDebugAppDomain pAppDomain, ICorDebugModule pModule), UnloadModule(ICorDebugAppDomain pAppDomain, ICorDebugModule pModule), LoadClass(ICorDebugAppDomain pAppDomain, ICorDebugClass c), UnloadClass(ICorDebugAppDomain pAppDomain, ICorDebugClass c), DebuggerError(ICorDebugProcess pProcess, int errorHR, uint errorCode), LogMessage(ICorDebugAppDomain pAppDomain, ICorDebugThread pThread, int lLevel, [MarshalAs(UnmanagedType.LPWStr)] string pLogSwitchName, [MarshalAs(UnmanagedType.LPWStr)] string pMessage), LogSwitch(ICorDebugAppDomain pAppDomain, ICorDebugThread pThread, int lLevel, int ulReason, [MarshalAs(UnmanagedType.LPWStr)] string pLogSwitchName, [MarshalAs(UnmanagedType.LPWStr)] string pParentName), CreateAppDomain(ICorDebugProcess pProcess, ICorDebugAppDomain pAppDomain), ExitAppDomain(ICorDebugProcess pProcess, ICorDebugAppDomain pAppDomain), LoadAssembly(ICorDebugAppDomain pAppDomain, ICorDebugAssembly pAssembly), UnloadAssembly(ICorDebugAppDomain pAppDomain, ICorDebugAssembly pAssembly), ControlCTrap(ICorDebugProcess pProcess), NameChange(ICorDebugAppDomain? pAppDomain, ICorDebugThread? pThread), UpdateModuleSymbols(ICorDebugAppDomain pAppDomain, ICorDebugModule pModule, [MarshalAs(UnmanagedType.IUnknown)] object pSymbolStream), EditAndContinueRemap(ICorDebugAppDomain pAppDomain, ICorDebugThread pThread, ICorDebugFunction pFunction, int fAccurate), BreakpointSetError(ICorDebugAppDomain pAppDomain, ICorDebugThread pThread, ICorDebugBreakpoint pBreakpoint, uint dwError)

    ICorDebugManagedCallback2: FunctionRemapOpportunity(ICorDebugAppDomain pAppDomain, ICorDebugThread pThread, ICorDebugFunction pOldFunction, ICorDebugFunction pNewFunction, uint oldILOffset), CreateConnection(ICorDebugProcess pProcess, uint dwConnectionId, [MarshalAs(UnmanagedType.LPWStr)] ref string pConnName), ChangeConnection(ICorDebugProcess pProcess, uint dwConnectionId), DestroyConnection(ICorDebugProcess pProcess, uint dwConnectionId), Exception(ICorDebugAppDomain pAppDomain, ICorDebugThread pThread, ICorDebugFrame? pFrame, uint nOffset, CorDebugExceptionCallbackType dwEventType, uint dwFlags), ExceptionUnwind(ICorDebugAppDomain pAppDomain, ICorDebugThread pThread, CorDebugExceptionUnwindCallbackType dwEventType, uint dwFlags), FunctionRemapComplete(ICorDebugAppDomain pAppDomain, ICorDebugThread pThread, ICorDebugFunction pFunction), MDANotification(ICorDebugController pController, ICorDebugThread pThread, ICorDebugMDA pMDA)

    **Also define these enums and placeholder interfaces** used as parameters (define with minimal members — just enough to compile; Phase 3 will use them):
    - `internal enum CorDebugThreadState { THREAD_RUN = 0, THREAD_SUSPEND = 1 }`
    - `internal enum CorDebugUserState { USER_STOP_REQUESTED = 0x01, USER_SUSPEND_REQUESTED = 0x02, USER_BACKGROUND = 0x04, USER_UNSTARTED = 0x08, USER_STOPPED = 0x10, USER_WAIT_SLEEP_JOIN = 0x20, USER_SUSPENDED = 0x40, USER_UNSAFE_POINT = 0x80 }`
    - `internal enum CorDebugMappingResult { MAPPING_PROLOG = 0x1, MAPPING_EPILOG = 0x2, MAPPING_NO_INFO = 0x4, MAPPING_UNMAPPED_ADDRESS = 0x8, MAPPING_EXACT = 0x10, MAPPING_APPROXIMATE = 0x20 }`
    - `internal enum CorDebugStepReason { STEP_NORMAL = 0, STEP_RETURN = 1, STEP_CALL = 2, STEP_EXCEPTION_FILTER = 3, STEP_EXCEPTION_HANDLER = 4, STEP_INTERCEPT = 5, STEP_EXIT = 6 }`
    - `internal enum CorDebugIntercept { INTERCEPT_NONE = 0x0, INTERCEPT_CLASS_INIT = 0x01, INTERCEPT_EXCEPTION_FILTER = 0x02, INTERCEPT_SECURITY = 0x04, INTERCEPT_CONTEXT_POLICY = 0x08, INTERCEPT_REMOTING = 0x10, INTERCEPT_ALL = 0xFFFF }`
    - `internal enum CorDebugUnmappedStop { STOP_NONE = 0x0, STOP_PROLOG = 0x01, STOP_EPILOG = 0x02, STOP_NO_MAPPING_INFO = 0x04, STOP_OTHER_UNMAPPED = 0x08, STOP_UNMANAGED = 0x10, STOP_ALL = 0xFFFF }`
    - `internal enum CorDebugExceptionCallbackType { DEBUG_EXCEPTION_FIRST_CHANCE = 1, DEBUG_EXCEPTION_USER_FIRST_CHANCE = 2, DEBUG_EXCEPTION_CATCH_HANDLER_FOUND = 3, DEBUG_EXCEPTION_UNHANDLED = 4 }`
    - `internal enum CorDebugExceptionUnwindCallbackType { DEBUG_EXCEPTION_UNWIND_BEGIN = 1, DEBUG_EXCEPTION_INTERCEPTED = 2 }`
    - `[GeneratedComInterface][Guid("...")]internal partial interface ICorDebugHeapValue : ICorDebugValue { }` — get GUID from IDL
    - `[GeneratedComInterface][Guid("...")]internal partial interface ICorDebugReferenceValue : ICorDebugValue { void IsNull(out int pbNull); void GetValue(out ulong pValue); void SetValue(ulong value); void Dereference(out ICorDebugValue ppValue); void DereferenceStrong(out ICorDebugValue ppValue); }` — get GUID from IDL
    - Stub interfaces (no methods needed, just GUID+declaration): ICorDebugAppDomain, ICorDebugAssembly, ICorDebugChain, ICorDebugClass, ICorDebugContext, ICorDebugCode, ICorDebugEval, ICorDebugMDA, ICorDebugRegisterSet, ICorDebugErrorInfoEnum, ICorDebugObjectEnum, ICorDebugProcessEnum, ICorDebugThreadEnum, ICorDebugAppDomainEnum, ICorDebugChainEnum, ICorDebugValueEnum, ICorDebugModuleBreakpoint, ICorDebugValueBreakpoint, ICorDebugEditAndContinueSnapshot, ICorDebugUnmanagedCallback
    - `internal struct COR_DEBUG_STEP_RANGE { public uint startOffset; public uint endOffset; }`

    For stub interfaces, use placeholder GUIDs in format `00000000-0000-0000-00XX-000000000000` where XX is an incrementing byte — these are only needed to make the compiler happy; the actual GUIDs matter only for ICorDebug, ICorDebugProcess, ICorDebugThread, ICorDebugFrame, ICorDebugILFrame, ICorDebugFunction, ICorDebugModule, ICorDebugValue subtypes, ICorDebugBreakpoint, ICorDebugStepper, and the two callback interfaces. Fetch the exact GUIDs for those from the IDL.

    **IMPORTANT:** Do NOT add `[GeneratedComInterface]` to ICorDebugManagedCallback or ICorDebugManagedCallback2 in this task — these interfaces will be implemented by a C# class in Phase 3 using `[GeneratedComClass]`. For now, mark them with `[GeneratedComInterface]` as they also need to be receivable as COM objects by native code. The implementation class in Phase 3 will use `[GeneratedComClass]`.
  </action>
  <verify>
    cd /home/eduardo/Projects/DebuggerNetMcp && dotnet build src/DebuggerNetMcp.Core/DebuggerNetMcp.Core.csproj -c Release --nologo -v q
    Expected: Build succeeded. 0 Warning(s). 0 Error(s).

    Also verify the GUID count:
    grep -c "\[Guid(" src/DebuggerNetMcp.Core/Interop/ICorDebug.cs
    Expected: >= 17 (one per interface that needs a real GUID)
  </verify>
  <done>
    ICorDebug.cs exists with all 17 core COM interfaces + helper interfaces + enums. All [Guid] attributes use GUIDs extracted from the authoritative cordebug.idl. dotnet build passes with 0 errors.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `dotnet build src/DebuggerNetMcp.Core/DebuggerNetMcp.Core.csproj -c Release --nologo` exits 0
2. `grep -c "GeneratedComInterface" src/DebuggerNetMcp.Core/Interop/ICorDebug.cs` returns >= 17
3. `grep "AllowUnsafeBlocks" src/DebuggerNetMcp.Core/DebuggerNetMcp.Core.csproj` shows `<AllowUnsafeBlocks>true</AllowUnsafeBlocks>`
4. `grep "NativeLibrary.TryLoad" src/DebuggerNetMcp.Core/Interop/DbgShimInterop.cs` matches at least once
5. `grep "netcoredbg" src/DebuggerNetMcp.Core/Interop/DbgShimInterop.cs` confirms ~/.local/lib/netcoredbg candidate path is present
</verification>

<success_criteria>
DbgShimInterop.cs compiles with multi-path libdbgshim.so discovery and GC lifetime guard. ICorDebug.cs contains all 17 required COM interfaces with correct GUIDs from cordebug.idl, using [GeneratedComInterface] exclusively (no [ComImport]). dotnet build is clean.
</success_criteria>

<output>
After completion, create .planning/phases/02-interop-engine-foundation/02-02-SUMMARY.md
</output>
