---
phase: 07-exceptions-threading-attach
plan: 03
type: execute
wave: 2
depends_on:
  - 07-01
  - 07-02
files_modified:
  - src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs
  - src/DebuggerNetMcp.Mcp/DebuggerTools.cs
  - tests/HelloDebug/Program.cs
autonomous: false
requirements:
  - ATCH-01

must_haves:
  truths:
    - "debug_attach(pid) waits for the CreateProcess callback before returning — _process is non-null when the tool returns"
    - "debug_attach returns state='attached' with the confirmed pid and process name"
    - "HelloDebug section 20 spawns a background thread with a distinct variable (threadMessage) visible at BP-20"
    - "HelloDebug section 21 throws an unhandled exception — the session ends with an ExceptionEvent carrying the real type and message"
    - "Live verification: debug_launch → BP-17 (closure) → debug_continue → ExceptionEvent has real type name (not '<unhandled>')"
  artifacts:
    - path: "src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs"
      provides: "AttachAsync updated to wait for CreateProcess confirmation via TaskCompletionSource"
      contains: "attachConfirmedTcs"
    - path: "src/DebuggerNetMcp.Mcp/DebuggerTools.cs"
      provides: "debug_attach returns state='attached' with pid and processName"
      contains: "processName"
    - path: "tests/HelloDebug/Program.cs"
      provides: "Section 20 (multi-thread) + Section 21 (unhandled exception) + BP-20 + BP-21 markers"
      contains: "BP-20"
  key_links:
    - from: "DotnetDebugger.AttachAsync"
      to: "ManagedCallbackHandler.OnProcessCreated"
      via: "TaskCompletionSource set in OnProcessCreated callback"
      pattern: "attachConfirmedTcs"
    - from: "DebuggerTools.Attach"
      to: "System.Diagnostics.Process.GetProcessById"
      via: "called after attachAsync confirms pid"
      pattern: "GetProcessById"
---

<objective>
Fix debug_attach to wait for the CreateProcess callback before returning, so _process is ready
and the tool returns state="attached" with confirmed pid and process name. Add HelloDebug
sections 20-21 for multi-thread and unhandled exception testing. Checkpoint verifies all 6
Phase 7 requirements end-to-end.

Purpose: Currently debug_attach returns state="running" immediately without confirming the
attach succeeded — subsequent calls fail with NullReferenceException. After this plan,
attach is confirmed before returning, enabling safe subsequent debug calls.

Output: AttachAsync with confirmation TCS; updated debug_attach JSON; HelloDebug sections 20-21.
</objective>

<execution_context>
@/home/eduardo/.claude/get-shit-done/workflows/execute-plan.md
@/home/eduardo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/07-exceptions-threading-attach/07-01-SUMMARY.md
@.planning/phases/07-exceptions-threading-attach/07-02-SUMMARY.md

@src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs
@src/DebuggerNetMcp.Core/Engine/ManagedCallbackHandler.cs
@src/DebuggerNetMcp.Mcp/DebuggerTools.cs
@tests/HelloDebug/Program.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix AttachAsync to confirm connection + update debug_attach return</name>
  <files>
    src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs
    src/DebuggerNetMcp.Mcp/DebuggerTools.cs
  </files>
  <action>
**DotnetDebugger.cs — replace AttachAsync:**

The existing AttachAsync dispatches AttachToProcess and returns immediately after the dispatch
completes, with _process still null (it's set asynchronously in CreateProcess callback).

Replace the existing AttachAsync with:

```csharp
/// <summary>
/// Attaches to a running .NET process by PID. Waits for the CreateProcess callback to confirm
/// the attach succeeded and _process is set before returning.
/// Returns (Pid, ProcessName) — process continues running (not stopped) after attach.
/// </summary>
public async Task<(uint Pid, string ProcessName)> AttachAsync(
    uint processId, CancellationToken ct = default)
{
    var attachConfirmedTcs = new TaskCompletionSource<uint>(
        TaskCreationOptions.RunContinuationsAsynchronously);

    // Set OnProcessCreated BEFORE dispatching — the callback fires on the ICorDebug thread
    // and may complete very quickly (race condition if set after dispatch).
    _callbackHandler.OnProcessCreated = proc =>
    {
        proc.GetID(out uint pid);
        attachConfirmedTcs.TrySetResult(pid);
    };

    await DispatchAsync(() =>
    {
        try
        {
            AttachToProcess(processId);
        }
        catch (Exception ex)
        {
            attachConfirmedTcs.TrySetException(ex);
        }
    }, ct);

    // Wait for the CreateProcess callback to fire — confirms _process is set
    uint confirmedPid = await attachConfirmedTcs.Task.WaitAsync(ct);

    // Read process name outside the debug thread (safe: just reading OS process table)
    string processName;
    try
    {
        processName = System.Diagnostics.Process.GetProcessById((int)confirmedPid).ProcessName;
    }
    catch
    {
        processName = "unknown";
    }

    return (confirmedPid, processName);
}
```

Note: After this change, the `_callbackHandler.OnProcessCreated` assignment in LaunchAsync
(which was already present to handle launch confirmation) should be checked — confirm LaunchAsync
does NOT overwrite OnProcessCreated used by AttachAsync. They are separate code paths:
LaunchAsync uses `OnProcessCreated` for its own stop-at-create logic; AttachAsync sets it
for attach confirmation. This is sequential (one session at a time) so no conflict exists.
Check LaunchAsync to confirm it sets `OnProcessCreated` only after `_callbackHandler.StopAtCreateProcess = true`.

**DebuggerTools.cs — update Attach method:**

Replace the existing Attach method body:
```csharp
[McpServerTool(Name = "debug_attach"),
 Description("Attach the debugger to a running .NET process by process ID. " +
             "Returns state='attached' with the confirmed pid and process name once " +
             "the runtime connection is established. The process continues running; " +
             "use debug_pause to stop it for inspection.")]
public async Task<string> Attach(
    [Description("The process ID to attach to")] uint processId,
    CancellationToken ct)
{
    try
    {
        var (confirmedPid, processName) = await debugger.AttachAsync(processId, ct);
        _state = "running";
        return JsonSerializer.Serialize(new
        {
            success = true,
            state = "attached",
            pid = confirmedPid,
            processName
        });
    }
    catch (Exception ex)
    {
        return JsonSerializer.Serialize(new { success = false, error = ex.Message });
    }
}
```
  </action>
  <verify>
    dotnet build src/ -c Release
    No compilation errors. grep for "attachConfirmedTcs" in DotnetDebugger.cs — found.
    grep for "processName" in DebuggerTools.cs — found in Attach method return.
  </verify>
  <done>
    Full solution builds. AttachAsync waits for TCS before returning. debug_attach returns
    { success: true, state: "attached", pid: N, processName: "..." }.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add HelloDebug sections 20-21 (multi-thread and unhandled exception)</name>
  <files>tests/HelloDebug/Program.cs</files>
  <action>
The current Program.cs ends at line 136 with `Console.WriteLine("[HelloDebug] Session complete");`
and then has helper methods and type declarations.

Insert two new sections BEFORE `Console.WriteLine("[HelloDebug] Session complete")`.
Specifically, insert after the BP-19 block (line ~134) and before the Session complete line.

**Section 20 — Multi-thread:**

```csharp
// ─── Section 20: Multi-thread ────────────────────────────────────────────────
// BP-20: Set breakpoint on the Console.WriteLine inside the thread lambda below.
// Expected: thread_id parameter on debug_variables returns 'threadMessage' from the background thread.
//           debug_stacktrace without thread_id shows both main thread and background thread frames.
{
    string threadMessage = "hello from main";
    var cts20 = new CancellationTokenSource();
    var bgThread = new Thread(() =>
    {
        string threadMessage = "hello from background";  // intentionally shadows outer
        Console.WriteLine($"[20] Background thread: {threadMessage}");  // <── BP-20
        cts20.Token.WaitHandle.WaitOne();
    });
    bgThread.IsBackground = true;
    bgThread.Start();
    Thread.Sleep(50);   // give background thread time to reach BP-20
    cts20.Cancel();
    bgThread.Join();
}
```

**Section 21 — Unhandled exception:**

```csharp
// ─── Section 21: Unhandled exception ─────────────────────────────────────────
// BP-21: No manual breakpoint needed — the throw below is unhandled.
// Expected: ExceptionEvent delivered with exceptionType="System.InvalidOperationException"
//           and message="Section 21 unhandled" — process does NOT exit silently.
// WARNING: This section terminates the HelloDebug process via an unhandled exception.
//          It MUST remain the last section. The ExceptionEvent is the session-ending event.
throw new InvalidOperationException("Section 21 unhandled");
```

Note: Section 21 uses `throw` not `try/catch` so it is genuinely unhandled.
Place Section 21 as the very last statement before the `Console.WriteLine("[HelloDebug] Session complete")` line,
then remove or comment out the `Session complete` line (the throw will prevent it from running anyway).

Also add the type declarations needed at the bottom of the file (none new needed for these sections;
they only use Thread, CancellationTokenSource, InvalidOperationException from BCL).

Add a comment block near the top of Program.cs (after the existing BP list) documenting the new sections:
```csharp
// BP-20: Background thread breakpoint (multi-thread section)
// BP-21: Unhandled exception (terminates session — must be last section)
```
  </action>
  <verify>
    dotnet build tests/HelloDebug/ -c Debug
    No compilation errors. grep for "BP-20" and "BP-21" in Program.cs — both found.
    grep for "Section 21 unhandled" in Program.cs — found (the throw message).
  </verify>
  <done>
    HelloDebug builds. Section 20 creates a background thread with a local variable at BP-20.
    Section 21 throws an unhandled InvalidOperationException as the last statement.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Plan 07-01: Exception type/message extraction (TryReadExceptionInfo) + first-chance notifications + double-reporting guard.
    Plan 07-02: Multi-thread inspection (GetAllThreads, optional threadId on debug_variables/debug_stacktrace, all-threads stacktrace).
    Plan 07-03 Task 1: AttachAsync confirmation via TCS + debug_attach returns state="attached" with processName.
    Plan 07-03 Task 2: HelloDebug sections 20-21 (multi-thread BP-20, unhandled exception section 21).
  </what-built>
  <how-to-verify>
    Build the full solution first:
    ```
    dotnet build src/DebuggerNetMcp.Mcp/ -c Release
    ```

    Run HelloDebug under the debugger using the MCP tools. Example verification sequence:

    **Verify EXCP-01 (unhandled exception with real type/message):**
    1. debug_launch(projectPath, appDllPath) → state="stopped"
    2. debug_set_breakpoint(dllPath, "Program.cs", BP-19 line) → id=1
    3. debug_continue → wait for breakpointHit event
    4. debug_continue → wait for exception event
    5. Confirm event has: type="exception", exceptionType="System.InvalidOperationException",
       message="Section 21 unhandled", isUnhandled=true
    6. Confirm only ONE exception event (not two)

    **Verify EXCP-02 (first-chance notifications):**
    1. debug_launch(projectPath, appDllPath, firstChanceExceptions=true) → state="stopped"
    2. debug_continue → wait for exception event
    3. Confirm event has isUnhandled=false (first-chance), real type/message
    4. debug_continue → more first-chance events or eventually unhandled section 21

    **Verify THRD-01 (thread-specific variables):**
    1. debug_launch → debug_continue → breakpointHit at BP-20
    2. debug_stacktrace() (no args) → response has "threads" array with 2+ entries
    3. Note the background thread's threadId from the stacktrace
    4. debug_variables(thread_id=backgroundThreadId) → returns {threadMessage: "hello from background"}
    5. debug_variables() (no args) → returns main thread variables (no threadMessage or main's value)

    **Verify THRD-02 (all-thread stacktrace):**
    Confirmed via step 2 above: response shape {threads: [{threadId, frames}, ...]}

    **Verify THRD-03 (pause stops all threads):**
    1. In a separate run: debug_launch → debug_continue (let it reach section 20)
    2. debug_pause → stopped event
    3. debug_stacktrace() → multiple threads visible in response

    **Verify ATCH-01 (attach):**
    1. Start a long-running .NET process (e.g., dotnet run with a sleep loop) in a separate terminal
    2. debug_attach(pid) → response has state="attached", pid=N, processName set (not null or empty)
    3. debug_status → state="running"
    4. debug_pause → stopped event
    5. debug_stacktrace() → frames visible for the attached process

    Confirm overall: `dotnet build src/DebuggerNetMcp.Mcp/ -c Release` succeeds before testing.
  </how-to-verify>
  <resume-signal>
    Type "approved" if all 6 requirements verified, or describe which checks failed and what was observed.
  </resume-signal>
</task>

</tasks>

<verification>
1. `dotnet build src/ -c Release` — zero errors
2. grep for "attachConfirmedTcs" in DotnetDebugger.cs — confirms new TCS pattern
3. grep for "processName" in DebuggerTools.cs — confirms updated return JSON
4. grep for "BP-20\|BP-21\|Section 20\|Section 21" in tests/HelloDebug/Program.cs — all found
5. Human checkpoint confirms all 6 phase requirements end-to-end
</verification>

<success_criteria>
- AttachAsync sets OnProcessCreated before dispatch, awaits TCS for confirmed pid
- debug_attach returns { success: true, state: "attached", pid: N, processName: "..." }
- HelloDebug section 20: background Thread with local 'threadMessage' variable at BP-20
- HelloDebug section 21: throw new InvalidOperationException("Section 21 unhandled") as last statement
- Human verifies: exception events carry real type/message, multi-thread inspection works per thread,
  debug_stacktrace returns all-threads structure, debug_attach returns confirmed state
</success_criteria>

<output>
After completion, create `.planning/phases/07-exceptions-threading-attach/07-03-SUMMARY.md`
</output>
