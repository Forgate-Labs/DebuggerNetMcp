---
phase: 05-type-system
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/DebuggerNetMcp.Core/Engine/VariableReader.cs
autonomous: true
requirements:
  - TYPE-02
  - TYPE-03

must_haves:
  truths:
    - "debug_variables on an enum variable returns 'EnumName.MemberName' not a raw integer"
    - "debug_variables on a Nullable<T> with HasValue=true returns the unwrapped T value"
    - "debug_variables on a Nullable<T> with HasValue=false returns 'null'"
  artifacts:
    - path: "src/DebuggerNetMcp.Core/Engine/VariableReader.cs"
      provides: "Enum detection + Nullable<T> unwrapping in ReadObjectFields"
      contains: "IsEnumType"
    - path: "src/DebuggerNetMcp.Core/Engine/VariableReader.cs"
      provides: "Nullable<T> unwrapping logic"
      contains: "Nullable"
  key_links:
    - from: "VariableReader.ReadObjectFields"
      to: "IsEnumType (PE metadata check)"
      via: "TypeAttributes.Sealed + base type == System.Enum"
      pattern: "IsEnumType"
    - from: "VariableReader.ReadObjectFields"
      to: "ReadNullableValue (hasValue + value fields)"
      via: "type name starts with Nullable"
      pattern: "Nullable"
---

<objective>
Teach VariableReader to detect and display enum and Nullable<T> value types correctly.

Purpose: Currently both enums and Nullable<T> go through ReadObjectFields as generic structs, showing raw integer fields or internal hasValue/value fields. Users need human-readable output: "DayOfWeek.Monday" for enums, the unwrapped T for Nullable<T>.

Output: Two new private methods in VariableReader.cs (IsEnumType, ReadEnumValue, ReadNullableValue) + updated ReadObjectFields dispatch. Enum vars show "TypeName.MemberName". Nullable vars show unwrapped value or "null".
</objective>

<execution_context>
@/home/eduardo/.claude/get-shit-done/workflows/execute-plan.md
@/home/eduardo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/DebuggerNetMcp.Core/Engine/VariableReader.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add IsEnumType helper + ReadEnumValue to VariableReader</name>
  <files>src/DebuggerNetMcp.Core/Engine/VariableReader.cs</files>
  <action>
Add two new private static methods to VariableReader (after ReadInstanceFieldsFromPE, before GetTypeName):

**IsEnumType(string dllPath, uint typedefToken) → bool**
- Opens PEReader, reads TypeDefinition for typedefToken
- Enum detection: check if the base type is a TypeReference with Name == "Enum" and Namespace == "System"
  - `typeDef.BaseType` → if Kind == HandleKind.TypeReference, get TypeReference, check name/namespace
- Return true only when base type is System.Enum (not System.ValueType)

**GetEnumFields(string dllPath, uint typedefToken) → (string typeName, Dictionary&lt;long, string&gt; members)**
- Opens PEReader, reads TypeDefinition
- typeName: metadata.GetString(typeDef.Name)
- Enumerate fields: skip `value__` (name == "value__") — it holds the underlying int value
- For each other static field: read its DefaultValue (ConstantHandle from field.GetDefaultValue())
  - Use metadata.GetConstant(constantHandle) to get the blob, decode to long (handles I4, I8, I2, I1, U4 etc.)
  - members[longValue] = fieldName
- Return (typeName, members)

**ReadEnumValue(string name, ICorDebugObjectValue objVal, ICorDebugClass cls, string dllPath, uint typedefToken) → VariableInfo**
- Find the `value__` field token in the type (instance field named "value__")
- Call objVal.GetFieldValue(cls, valueFieldToken, out ICorDebugValue rawVal)
- Read the raw integer via ICorDebugGenericValue.GetValue() — the value__ field is a primitive (I4, I8, etc.)
  - Call rawVal.GetType(out uint elemTypeRaw), cast to CorElementType
  - Use ReadGenericBytes(rawVal) then BitConverter to decode the integer to long
- Call GetEnumFields to get (typeName, members)
- Look up members[longValue]: if found return VariableInfo(name, typeName, $"{typeName}.{memberName}", empty children)
- If not found: return VariableInfo(name, typeName, $"{typeName}({longValue})", empty children)

Note: ConstantHandle from field.GetDefaultValue() — use `metadata.GetConstant(handle)` which returns a `Constant` struct. The blob reader gives a BlobReader; use BlobReader.ReadInt32(), ReadInt64(), etc. based on `Constant.TypeCode` (which is a ConstantTypeCode enum).

Avoid using IMetaDataImport — use only System.Reflection.Metadata (PEReader pattern already established in this file).
  </action>
  <verify>dotnet build src/DebuggerNetMcp.Mcp/ -c Release 2>&amp;1 | tail -5</verify>
  <done>Build succeeds with 0 errors. IsEnumType, GetEnumFields, ReadEnumValue methods exist in VariableReader.cs.</done>
</task>

<task type="auto">
  <name>Task 2: Add ReadNullableValue + update ReadObjectFields dispatch</name>
  <files>src/DebuggerNetMcp.Core/Engine/VariableReader.cs</files>
  <action>
Add ReadNullableValue and update ReadObjectFields to dispatch enums and Nullable&lt;T&gt; before falling through to generic field enumeration.

**ReadNullableValue(string name, ICorDebugObjectValue objVal, ICorDebugClass cls, string dllPath, uint typedefToken, int depth) → VariableInfo**
- Nullable&lt;T&gt; has exactly two instance fields in the PE: `hasValue` (bool, underlying I1) and `value` (T)
- Find field tokens: call ReadInstanceFieldsFromPE, look for fields named "hasValue" and "value"
- Read `hasValue`: objVal.GetFieldValue(cls, hasValueToken, out ICorDebugValue hvVal), ReadBoolean → check value string == "true"
- If hasValue is false: return VariableInfo(name, "Nullable", "null", empty children)
- If hasValue is true: objVal.GetFieldValue(cls, valueToken, out ICorDebugValue valVal), return ReadValue(name, valVal, depth + 1)
  - This recursively reads the underlying T (int, struct, etc.)

**Update ReadObjectFields** (lines 380-451) to add dispatch at the top, right after getting typedefToken and dllPath:

```csharp
// 1. Enum detection
if (IsEnumType(dllPath, typedefToken))
    return ReadEnumValue(name, objVal, cls, dllPath, typedefToken);

// 2. Nullable<T> detection
string rawTypeName = GetTypeName(dllPath, typedefToken);
if (rawTypeName == "Nullable`1")
    return ReadNullableValue(name, objVal, cls, dllPath, typedefToken, depth);
```

Place these two checks after `string dllPath = GetModulePath(module);` (early return if empty) and before the `var children = new List&lt;VariableInfo&gt;();` line.

Note: Nullable&lt;T&gt; lives in System.Private.CoreLib.dll, not the user's assembly. When dllPath points to the user's DLL, IsEnumType will return false and rawTypeName will be "object" (GetTypeName fails gracefully). Handle Nullable differently: the type name comes from `GetTypeName` which reads from the user DLL — this won't work for BCL types. Instead, get the raw type name from `objVal.GetClass()` → `cls.GetToken()` → `ICorDebugType` path... but ICorDebugType is not in the interface set.

Alternative: Use `ICorDebugObjectValue.GetClass()` → token + module → check module path contains "System.Private.CoreLib". Then try to get type name via ICorDebug's existing path. Actually, simplest approach: check if `typeName == "struct"` in ReadObject (the caller), then inside ReadObjectFields check via the module path if it's a CoreLib type.

Simpler yet: Nullable&lt;T&gt; struct fields — when `dllPath` is the user assembly, `GetTypeName` returns "object" for BCL types. Instead, detect Nullable by querying the PE metadata reader of the module path — if module path contains "System.Private.CoreLib", use a different approach.

Best approach for Nullable: In `ReadObjectFields`, after getting dllPath, check if `Path.GetFileName(dllPath)` is "System.Private.CoreLib.dll". If yes, use a BCL type name helper — read type name from PE (works because CoreLib PEs are readable). GetTypeName already reads from PE; the issue is GetTypeName uses `typedefToken` from `cls.GetToken()` which is a token in the module's metadata — it works for any module including CoreLib.

So GetTypeName(dllPath, typedefToken) DOES work for CoreLib types (it reads the PE). The check `rawTypeName == "Nullable\`1"` will work correctly. Proceed as originally described.
  </action>
  <verify>dotnet build src/DebuggerNetMcp.Mcp/ -c Release 2>&amp;1 | tail -5</verify>
  <done>Build succeeds. ReadObjectFields dispatches to ReadEnumValue for enum types and ReadNullableValue for Nullable&lt;T&gt; before generic field enumeration.</done>
</task>

</tasks>

<verification>
1. `dotnet build src/DebuggerNetMcp.Mcp/ -c Release` — 0 errors, 0 warnings (or warnings unchanged from baseline)
2. Verify IsEnumType method exists: `grep -n "IsEnumType\|ReadEnumValue\|ReadNullableValue" src/DebuggerNetMcp.Core/Engine/VariableReader.cs`
3. Verify ReadObjectFields dispatch added: `grep -n "IsEnumType\|Nullable\`1" src/DebuggerNetMcp.Core/Engine/VariableReader.cs`
</verification>

<success_criteria>
- VariableReader.IsEnumType(dllPath, typedefToken) returns true when base type is System.Enum
- ReadEnumValue reads `value__` field as integer, resolves member name from PE constants, returns "TypeName.MemberName"
- ReadNullableValue reads `hasValue` field, returns "null" when false, unwrapped T value when true
- ReadObjectFields dispatches enum and Nullable before generic field enumeration
- Build passes: `dotnet build src/DebuggerNetMcp.Mcp/ -c Release` exits 0
</success_criteria>

<output>
After completion, create `.planning/phases/05-type-system/05-01-SUMMARY.md`
</output>
