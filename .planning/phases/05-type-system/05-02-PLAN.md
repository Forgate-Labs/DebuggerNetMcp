---
phase: 05-type-system
plan: "02"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/DebuggerNetMcp.Core/Interop/ICorDebug.cs
  - src/DebuggerNetMcp.Core/Engine/VariableReader.cs
  - src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs
autonomous: true
requirements:
  - TYPE-04

must_haves:
  truths:
    - "debug_variables or debug_evaluate returns the current value of a static field from a class"
    - "EvaluateAsync('ClassName.FieldName') resolves the static field and returns its value"
  artifacts:
    - path: "src/DebuggerNetMcp.Core/Interop/ICorDebug.cs"
      provides: "ICorDebugClass.GetStaticFieldValue COM method"
      contains: "GetStaticFieldValue"
    - path: "src/DebuggerNetMcp.Core/Engine/VariableReader.cs"
      provides: "ReadStaticField helper using ICorDebugClass.GetStaticFieldValue"
      contains: "ReadStaticFields"
    - path: "src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs"
      provides: "Static field lookup in GetLocalsAsync and EvaluateAsync"
      contains: "static"
  key_links:
    - from: "DotnetDebugger.GetLocalsAsync"
      to: "ICorDebugModule.GetClassFromToken"
      via: "typedefToken from PE static field scan"
      pattern: "GetClassFromToken"
    - from: "ICorDebugClass"
      to: "ICorDebugValue (static field)"
      via: "GetStaticFieldValue(fieldToken, frame)"
      pattern: "GetStaticFieldValue"
---

<objective>
Add static field reading capability to the debug engine: extend ICorDebugClass COM interface, add VariableReader helpers, and extend GetLocalsAsync + EvaluateAsync to expose static fields.

Purpose: Static fields (e.g., `Config.MaxRetries`, `AppSettings.Version`) are invisible to the debugger currently because they are not IL locals or instance fields. Users need `debug_variables` and `debug_evaluate` to surface them.

Output: ICorDebugClass gains GetStaticFieldValue. VariableReader gains ReadStaticFieldsFromPE (enumerate static fields) + ReadStaticField (read via COM). DotnetDebugger.GetLocalsAsync appends static fields from the declaring type. EvaluateAsync supports "ClassName.FieldName" syntax.
</objective>

<execution_context>
@/home/eduardo/.claude/get-shit-done/workflows/execute-plan.md
@/home/eduardo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/DebuggerNetMcp.Core/Interop/ICorDebug.cs
@src/DebuggerNetMcp.Core/Engine/VariableReader.cs
@src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend ICorDebugClass + add VariableReader static field helpers</name>
  <files>
    src/DebuggerNetMcp.Core/Interop/ICorDebug.cs
    src/DebuggerNetMcp.Core/Engine/VariableReader.cs
  </files>
  <action>
**ICorDebug.cs — extend ICorDebugClass interface:**

The current ICorDebugClass has only GetModule and GetToken. Add GetStaticFieldValue as the third method. The ICorDebugClass vtable order (from cordebug.idl) is:
1. GetModule
2. GetToken
3. GetStaticFieldValue(uint fieldDef, ICorDebugFrame pFrame, out ICorDebugValue ppValue)

Update the interface:
```csharp
internal partial interface ICorDebugClass
{
    void GetModule(out ICorDebugModule pModule);
    void GetToken(out uint pTypeDef);
    void GetStaticFieldValue(uint fieldDef, ICorDebugFrame pFrame, out ICorDebugValue ppValue);
}
```

The `pFrame` parameter provides the thread context needed to read thread-static fields; for ordinary statics pass the active frame from GetActiveFrame(). For fields with no thread-static attribute, `pFrame` can be null but the COM ABI requires passing a valid frame pointer — always pass the active frame obtained from the stopped thread.

**VariableReader.cs — add two new private static methods:**

**ReadStaticFieldsFromPE(string dllPath, uint typedefToken) → Dictionary&lt;uint, string&gt;**
- Same pattern as ReadInstanceFieldsFromPE but select ONLY static fields (FieldAttributes.Static set)
- Skip fields named "value__" (enum underlying value) and compiler-generated names starting with "&lt;&gt;"
- Return fieldToken → fieldName map

**ReadStaticField(string name, ICorDebugClass cls, uint fieldToken, ICorDebugFrame frame) → VariableInfo**
- Call cls.GetStaticFieldValue(fieldToken, frame, out ICorDebugValue val)
- Return VariableReader.ReadValue(name, val)
- On exception: return VariableInfo(name, "static", "&lt;not available&gt;", Array.Empty&lt;VariableInfo&gt;())
  </action>
  <verify>dotnet build src/DebuggerNetMcp.Mcp/ -c Release 2>&amp;1 | tail -5</verify>
  <done>Build succeeds. ICorDebugClass has GetStaticFieldValue. VariableReader has ReadStaticFieldsFromPE and ReadStaticField.</done>
</task>

<task type="auto">
  <name>Task 2: Extend GetLocalsAsync and EvaluateAsync for static field access</name>
  <files>src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs</files>
  <action>
**GetLocalsAsync — append static fields from the declaring type (lines 751-886):**

After the existing local variable enumeration (both the state-machine path and the non-state-machine path), add a static field scan for the declaring type of the current method:

```csharp
// Append static fields from the declaring type
try
{
    var (_, staticFields) = PdbReader.GetMethodTypeFields(dllPath, (int)methodToken);
    // Note: GetMethodTypeFields returns instance fields; we need static fields.
    // Use VariableReader.ReadStaticFieldsFromPE directly.
    var staticFieldMap = VariableReader.ReadStaticFieldsFromPE(dllPath, declaringTypeToken);
    if (staticFieldMap.Count > 0)
    {
        module.GetClassFromToken(declaringTypeToken, out ICorDebugClass staticCls);
        thread.GetActiveFrame(out ICorDebugFrame activeFrame);
        foreach (var (ft, fn) in staticFieldMap)
        {
            string displayName = fn.StartsWith("<") ? fn : fn; // static fields rarely need rename
            var sv = VariableReader.ReadStaticField(displayName, staticCls, ft, activeFrame);
            if (!sv.Value.Contains("not available"))
                result.Add(sv);
        }
    }
}
catch { /* static scan is best-effort */ }
```

To get `declaringTypeToken`: after obtaining `methodToken` and `dllPath`, call `PdbReader.GetMethodTypeFields(dllPath, (int)methodToken)` — this already returns the method name and instance fields. Add a new `PdbReader.GetDeclaringTypeToken(dllPath, int methodToken) → uint` helper (see below) OR inline it: open PE, read MethodDefinition for the token, return `MetadataTokens.GetToken(methodDef.GetDeclaringType())`.

**Add PdbReader.GetDeclaringTypeToken(string dllPath, int methodToken) → uint** in PdbReader.cs:
```csharp
public static uint GetDeclaringTypeToken(string dllPath, int methodToken)
{
    try
    {
        using var peReader = new PEReader(File.OpenRead(dllPath));
        var metadata = peReader.GetMetadataReader();
        int rowNumber = methodToken & 0x00FFFFFF;
        var methodHandle = MetadataTokens.MethodDefinitionHandle(rowNumber);
        var methodDef = metadata.GetMethodDefinition(methodHandle);
        var typeHandle = methodDef.GetDeclaringType();
        if (typeHandle.IsNil) return 0;
        return (uint)MetadataTokens.GetToken(typeHandle);
    }
    catch { return 0; }
}
```

Also add `ReadStaticFieldsFromPE` as `public` (or `internal`) on VariableReader so DotnetDebugger can call it. Actually, since VariableReader is `internal static` in the same assembly, accessibility is fine.

**EvaluateAsync — support "ClassName.FieldName" expression (lines 893-1027):**

Add a new lookup path at the top of the DispatchAsync lambda, before the existing state-machine and local variable paths:

```csharp
// Try "TypeName.FieldName" static field lookup
if (expression.Contains('.'))
{
    var dotIdx = expression.IndexOf('.');
    string typeName = expression[..dotIdx];
    string fieldName = expression[(dotIdx + 1)..];

    // Scan all loaded modules for a type matching typeName
    _process!.EnumerateObjects(out ICorDebugObjectEnum objEnum); // wrong — use module enumeration
    // ...
}
```

Actually `ICorDebugProcess` doesn't expose a module enumeration in the current interface. Better approach: use the current frame's module to find the type. Search within the declaring type's module first. If the user writes "MyClass.MyField" and is stopped in the same assembly, scan the PE for a type named "MyClass":

```csharp
if (expression.Contains('.'))
{
    var dotIdx = expression.IndexOf('.');
    string typePart = expression[..dotIdx];
    string fieldPart = expression[(dotIdx + 1)..];

    // Find typedefToken for typePart in the current method's module
    uint foundTypeToken = FindTypeByName(dllPath, typePart);
    if (foundTypeToken != 0)
    {
        var sfMap = VariableReader.ReadStaticFieldsFromPE(dllPath, foundTypeToken);
        var matchEntry = sfMap.FirstOrDefault(kv =>
            kv.Value.Equals(fieldPart, StringComparison.Ordinal));
        if (matchEntry.Key != 0)
        {
            module.GetClassFromToken(foundTypeToken, out ICorDebugClass sfCls);
            thread.GetActiveFrame(out ICorDebugFrame activeFrame2);
            var sfInfo = VariableReader.ReadStaticField(fieldPart, sfCls, matchEntry.Key, activeFrame2);
            tcs.SetResult(new EvalResult(true, sfInfo.Value, null));
            return;
        }
    }
}
```

Add private helper in DotnetDebugger (or PdbReader):

**PdbReader.FindTypeByName(string dllPath, string typeName) → uint**:
```csharp
public static uint FindTypeByName(string dllPath, string typeName)
{
    try
    {
        using var peReader = new PEReader(File.OpenRead(dllPath));
        var metadata = peReader.GetMetadataReader();
        foreach (var typeHandle in metadata.TypeDefinitions)
        {
            var typeDef = metadata.GetTypeDefinition(typeHandle);
            string name = metadata.GetString(typeDef.Name);
            if (name == typeName)
                return (uint)MetadataTokens.GetToken(typeHandle);
        }
    }
    catch { }
    return 0;
}
```

Place the dot-notation lookup BEFORE the existing state machine and local variable paths in EvaluateAsync so "ClassName.FieldName" is tried first.

Also make `ReadStaticFieldsFromPE` accessible from DotnetDebugger — it's already `private static` in `VariableReader`. Change to `internal static` (the class is already `internal static`), or add a public wrapper method. Since both are in DebuggerNetMcp.Core assembly and VariableReader is `internal static`, the method just needs to be `internal static` (not `private`). Change `private static Dictionary&lt;uint, string&gt; ReadStaticFieldsFromPE` to `internal static`.
  </action>
  <verify>dotnet build src/DebuggerNetMcp.Mcp/ -c Release 2>&amp;1 | tail -5</verify>
  <done>Build succeeds. GetLocalsAsync appends static fields from declaring type. EvaluateAsync supports "TypeName.FieldName" dot syntax. PdbReader has GetDeclaringTypeToken and FindTypeByName.</done>
</task>

</tasks>

<verification>
1. `dotnet build src/DebuggerNetMcp.Mcp/ -c Release` — 0 errors
2. Verify ICorDebugClass has GetStaticFieldValue: `grep -n "GetStaticFieldValue" src/DebuggerNetMcp.Core/Interop/ICorDebug.cs`
3. Verify PdbReader helpers added: `grep -n "GetDeclaringTypeToken\|FindTypeByName" src/DebuggerNetMcp.Core/Engine/PdbReader.cs`
4. Verify VariableReader has ReadStaticFieldsFromPE as internal: `grep -n "ReadStaticFieldsFromPE" src/DebuggerNetMcp.Core/Engine/VariableReader.cs`
5. Verify EvaluateAsync has dot-notation path: `grep -n "Contains\('\.'\)\|IndexOf\('\.')" src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs`
</verification>

<success_criteria>
- ICorDebugClass interface has GetStaticFieldValue as third vtable method
- VariableReader.ReadStaticFieldsFromPE returns static field token → name map (internal visibility)
- PdbReader.GetDeclaringTypeToken and FindTypeByName helpers compile correctly
- GetLocalsAsync appends available static fields from the current method's declaring type
- EvaluateAsync handles "TypeName.FieldName" dot-notation before local variable lookup
- Build passes: `dotnet build src/DebuggerNetMcp.Mcp/ -c Release` exits 0
</success_criteria>

<output>
After completion, create `.planning/phases/05-type-system/05-02-SUMMARY.md`
</output>
