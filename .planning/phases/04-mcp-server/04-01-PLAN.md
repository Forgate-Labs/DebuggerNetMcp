---
phase: 04-mcp-server
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/DebuggerNetMcp.Mcp/DebuggerNetMcp.Mcp.csproj
  - src/DebuggerNetMcp.Mcp/Program.cs
autonomous: true
requirements:
  - MCP-01
  - TEST-01

must_haves:
  truths:
    - "dotnet restore exits 0 after ModelContextProtocol package added to Mcp csproj"
    - "Program.cs wires MCP stdio transport with DotnetDebugger singleton and DebuggerTools"
    - "All console/log output goes to stderr — stdout is reserved for MCP wire protocol"
    - "HelloDebug has DebugType=portable, Optimize=false, and 9 debug sections covering all variable types (TEST-01 confirmed satisfied)"
  artifacts:
    - path: "src/DebuggerNetMcp.Mcp/DebuggerNetMcp.Mcp.csproj"
      provides: "ModelContextProtocol package reference"
      contains: "ModelContextProtocol"
    - path: "src/DebuggerNetMcp.Mcp/Program.cs"
      provides: "MCP stdio server host with DI"
      min_lines: 20
    - path: "tests/HelloDebug/Program.cs"
      provides: "9-section test app for debugger verification"
      contains: "Section 1"
  key_links:
    - from: "src/DebuggerNetMcp.Mcp/Program.cs"
      to: "ModelContextProtocol.Server.McpServerBuilderExtensions"
      via: "AddMcpServer().WithStdioServerTransport().WithTools<DebuggerTools>()"
      pattern: "WithStdioServerTransport"
    - from: "src/DebuggerNetMcp.Mcp/Program.cs"
      to: "DebuggerNetMcp.Core.Engine.DotnetDebugger"
      via: "builder.Services.AddSingleton<DotnetDebugger>()"
      pattern: "AddSingleton.*DotnetDebugger"
---

<objective>
Add ModelContextProtocol NuGet package to DebuggerNetMcp.Mcp and replace the placeholder Program.cs with the real MCP stdio host. Confirm HelloDebug satisfies TEST-01 (no code changes required).

Purpose: This is the entry point wiring — without it, DebuggerTools (Plan 02) has no host to run in.
Output: A buildable Mcp project that starts an MCP stdio server with DotnetDebugger as a DI singleton.
</objective>

<execution_context>
@/home/eduardo/.claude/get-shit-done/workflows/execute-plan.md
@/home/eduardo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-mcp-server/04-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ModelContextProtocol package and write Program.cs</name>
  <files>
    src/DebuggerNetMcp.Mcp/DebuggerNetMcp.Mcp.csproj
    src/DebuggerNetMcp.Mcp/Program.cs
  </files>
  <action>
    Step 1 — Add the NuGet package:
    ```
    dotnet add src/DebuggerNetMcp.Mcp/DebuggerNetMcp.Mcp.csproj package ModelContextProtocol --version 0.9.0-preview.2
    ```
    This adds `<PackageReference Include="ModelContextProtocol" Version="0.9.0-preview.2" />` to the csproj.
    Microsoft.Extensions.Hosting is pulled transitively — no separate package needed.

    Step 2 — Replace Program.cs with the full MCP host (overwrite the placeholder "Hello, World!" content):

    ```csharp
    using Microsoft.Extensions.DependencyInjection;
    using Microsoft.Extensions.Hosting;
    using Microsoft.Extensions.Logging;
    using ModelContextProtocol.Server;
    using DebuggerNetMcp.Core.Engine;

    var builder = Host.CreateApplicationBuilder(args);

    // CRITICAL: all logging must go to stderr — stdout is the MCP wire protocol
    builder.Logging.AddConsole(options =>
    {
        options.LogToStandardErrorThreshold = LogLevel.Trace;
    });

    // DotnetDebugger manages a single OS-level debug session with a dedicated COM thread
    // — must be singleton so state is preserved across tool calls
    builder.Services.AddSingleton<DotnetDebugger>();

    builder.Services
        .AddMcpServer()
        .WithStdioServerTransport()
        .WithTools<DebuggerTools>();

    await builder.Build().RunAsync();
    ```

    NOTE: `DebuggerTools` does not exist yet (Plan 02 creates it). The project will NOT
    compile until Plan 02 is complete. This is expected — the type reference is a forward
    declaration that Plan 02 will satisfy.

    Step 3 — Run `dotnet restore src/DebuggerNetMcp.Mcp/DebuggerNetMcp.Mcp.csproj` to
    download the NuGet packages and verify the package resolved correctly.
  </action>
  <verify>
    Run: `dotnet restore src/DebuggerNetMcp.Mcp/DebuggerNetMcp.Mcp.csproj`
    Expected: Exit 0, no errors. The restore log should show ModelContextProtocol 0.9.0-preview.2 resolved.

    Run: `grep "ModelContextProtocol" src/DebuggerNetMcp.Mcp/DebuggerNetMcp.Mcp.csproj`
    Expected: Output shows the PackageReference line.

    Run: `grep "WithStdioServerTransport" src/DebuggerNetMcp.Mcp/Program.cs`
    Expected: Output shows the line.

    Run: `grep "LogToStandardErrorThreshold" src/DebuggerNetMcp.Mcp/Program.cs`
    Expected: Output shows stderr routing is present.

    NOTE: `dotnet build` will fail until DebuggerTools.cs is created in Plan 02 — this is
    expected. Only the restore check is required at this stage.
  </verify>
  <done>
    csproj contains ModelContextProtocol 0.9.0-preview.2 package reference.
    Program.cs contains AddMcpServer/WithStdioServerTransport/WithTools pattern with stderr
    log routing and AddSingleton&lt;DotnetDebugger&gt;.
    dotnet restore exits 0.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify HelloDebug satisfies TEST-01</name>
  <files>
    tests/HelloDebug/Program.cs
    tests/HelloDebug/HelloDebug.csproj
  </files>
  <action>
    TEST-01 requires: "TestApps/HelloDebug/Program.cs — app with primitive variables,
    complex objects, lists/arrays, and a caught exception."

    The file at `tests/HelloDebug/Program.cs` already covers all 9 required scenarios
    (confirmed by research). No code changes are needed.

    Verify these assertions by reading the files:
    1. `tests/HelloDebug/HelloDebug.csproj` must contain `&lt;DebugType&gt;portable&lt;/DebugType&gt;`
       and `&lt;Optimize&gt;false&lt;/Optimize&gt;` — required for PdbReader and local variable visibility.
    2. `tests/HelloDebug/Program.cs` must contain:
       - `int counter`, `bool isActive`, `double ratio`, `char grade` (Section 1 — primitives)
       - `new List&lt;int&gt;`, `new Dictionary`, `int[]` (Section 4 — collections)
       - `new Person` with nested `new Address` (Section 5 — object graph)
       - `DivideByZeroException` catch block (Section 7 — caught exception)

    Run `dotnet build tests/HelloDebug/HelloDebug.csproj -c Debug` to confirm it compiles.

    If the build succeeds with DebugType=portable, TEST-01 is satisfied without changes.
    Record this as a no-op verification in the SUMMARY.
  </action>
  <verify>
    Run: `dotnet build tests/HelloDebug/HelloDebug.csproj -c Debug`
    Expected: Build succeeded, 0 errors.

    Run: `grep -c "Section [1-9]" tests/HelloDebug/Program.cs`
    Expected: 9 (all 9 sections present).

    Run: `grep "DebugType" tests/HelloDebug/HelloDebug.csproj`
    Expected: `&lt;DebugType&gt;portable&lt;/DebugType&gt;`
  </verify>
  <done>
    HelloDebug builds with 0 errors.
    All 9 debug sections present in Program.cs.
    csproj has DebugType=portable and Optimize=false.
    TEST-01 requirement confirmed satisfied (no code changes needed).
  </done>
</task>

</tasks>

<verification>
1. `dotnet restore src/DebuggerNetMcp.Mcp/DebuggerNetMcp.Mcp.csproj` exits 0
2. `grep ModelContextProtocol src/DebuggerNetMcp.Mcp/DebuggerNetMcp.Mcp.csproj` shows package reference
3. `grep WithStdioServerTransport src/DebuggerNetMcp.Mcp/Program.cs` shows MCP transport wired
4. `grep AddSingleton src/DebuggerNetMcp.Mcp/Program.cs` shows DotnetDebugger singleton registered
5. `grep LogToStandardErrorThreshold src/DebuggerNetMcp.Mcp/Program.cs` shows stderr routing
6. `dotnet build tests/HelloDebug/HelloDebug.csproj -c Debug` exits 0
</verification>

<success_criteria>
- ModelContextProtocol 0.9.0-preview.2 is in the Mcp csproj
- Program.cs replaces placeholder with real MCP host (AddMcpServer + WithStdioServerTransport + WithTools&lt;DebuggerTools&gt; + AddSingleton&lt;DotnetDebugger&gt; + stderr logging)
- HelloDebug confirms TEST-01 satisfied: 9 sections, DebugType=portable, Optimize=false, builds clean
</success_criteria>

<output>
After completion, create `.planning/phases/04-mcp-server/04-01-SUMMARY.md` following the summary template.
</output>
