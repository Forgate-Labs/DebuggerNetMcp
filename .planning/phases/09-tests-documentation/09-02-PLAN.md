---
phase: 09-tests-documentation
plan: 02
type: execute
wave: 2
depends_on:
  - "09-01"
files_modified:
  - tests/DebuggerNetMcp.Tests/DebuggerIntegrationTests.cs
  - tests/DebuggerNetMcp.Tests/DebuggerAdvancedTests.cs
autonomous: true
requirements:
  - TEST-03
  - TEST-09

must_haves:
  truths:
    - "`dotnet test` runs DebuggerIntegrationTests covering launch, breakpoint, variables, step, and exit — all passing"
    - "`dotnet test` runs DebuggerAdvancedTests covering unhandled exceptions, multi-thread inspection, and process attach — all passing"
    - "Tests run sequentially (DisableParallelization=true) via [Collection(\"Debugger\")] so no two debug sessions overlap"
    - "Each test is self-contained: starts with LaunchAsync, ends with DisconnectAsync, no shared session state"
    - "All WaitForEventAsync calls have a 30-second CancellationToken to prevent hung tests"
  artifacts:
    - path: "tests/DebuggerNetMcp.Tests/DebuggerIntegrationTests.cs"
      provides: "Full debug session tests: launch, breakpoint hit, variable inspection, step, exit"
      contains: "LaunchAsync_SetBreakpoint_HitsAndInspectsVariable"
    - path: "tests/DebuggerNetMcp.Tests/DebuggerAdvancedTests.cs"
      provides: "Advanced scenario tests: unhandled exception event, multi-thread visibility, process attach"
      contains: "Launch_UnhandledException_DeliversExceptionEvent"
  key_links:
    - from: "tests/DebuggerNetMcp.Tests/DebuggerIntegrationTests.cs"
      to: "DebuggerFixture"
      via: "[Collection(\"Debugger\")] and constructor injection"
      pattern: "Collection\\(\"Debugger\"\\)"
    - from: "tests/DebuggerNetMcp.Tests/DebuggerIntegrationTests.cs"
      to: "tests/HelloDebug/bin/Debug/net10.0/HelloDebug.dll"
      via: "AppContext.BaseDirectory path arithmetic"
      pattern: "AppContext\\.BaseDirectory"
    - from: "DebuggerAdvancedTests.AttachAsync_RunningProcess_AttachesSuccessfully"
      to: "System.Diagnostics.Process.Start"
      via: "Launch HelloDebug as target process, capture PID, then call AttachAsync(pid)"
      pattern: "Process\\.Start"
---

<objective>
Implement DebuggerIntegrationTests (TEST-03) and DebuggerAdvancedTests (TEST-09) — the full end-to-end xUnit integration test suite.

Purpose: Automated tests that verify all major debug scenarios without manual intervention. Catching regressions early and proving the ICorDebug engine works end-to-end for every capability shipped in Phases 5-8.

Output:
- `tests/DebuggerNetMcp.Tests/DebuggerIntegrationTests.cs` — launch/breakpoint/variables/step/exit
- `tests/DebuggerNetMcp.Tests/DebuggerAdvancedTests.cs` — exceptions/multi-thread/attach
</objective>

<execution_context>
@/home/eduardo/.claude/get-shit-done/workflows/execute-plan.md
@/home/eduardo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-tests-documentation/09-RESEARCH.md
@.planning/phases/09-tests-documentation/09-01-SUMMARY.md

@tests/DebuggerNetMcp.Tests/DebuggerFixture.cs
@tests/DebuggerNetMcp.Tests/PdbReaderTests.cs
@tests/HelloDebug/Program.cs
@src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs
@src/DebuggerNetMcp.Core/Models/Models.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write DebuggerIntegrationTests.cs — launch, breakpoint, variables, step, exit</name>
  <files>
    tests/DebuggerNetMcp.Tests/DebuggerIntegrationTests.cs
  </files>
  <action>
    Create `tests/DebuggerNetMcp.Tests/DebuggerIntegrationTests.cs`.

    **Shared paths (compute from AppContext.BaseDirectory):**
    ```csharp
    private static readonly string HelloDebugProject = Path.GetFullPath(
        Path.Combine(AppContext.BaseDirectory, "..", "..", "..", "..", "HelloDebug"));
    private static readonly string HelloDebugDll = Path.GetFullPath(
        Path.Combine(AppContext.BaseDirectory, "..", "..", "..", "..",
            "HelloDebug", "bin", "Debug", "net10.0", "HelloDebug.dll"));
    ```

    **WaitForSpecificEvent helper (static):**
    ```csharp
    private static async Task<T> WaitForSpecificEvent<T>(
        DotnetDebugger dbg, CancellationToken ct) where T : DebugEvent
    {
        while (true)
        {
            var ev = await dbg.WaitForEventAsync(ct);
            if (ev is T typedEv) return typedEv;
            if (ev is ExitedEvent) throw new Exception($"Process exited before {typeof(T).Name}");
            // OutputEvent, StoppedEvent — keep draining
        }
    }
    ```

    **DrainToExit helper (static):**
    ```csharp
    private static async Task DrainToExit(DotnetDebugger dbg, CancellationToken ct)
    {
        while (true)
        {
            var ev = await dbg.WaitForEventAsync(ct);
            if (ev is ExitedEvent) return;
            if (ev is BreakpointHitEvent or StoppedEvent)
                await dbg.ContinueAsync(ct); // keep process running toward exit
        }
    }
    ```

    **Test 1: LaunchAsync_SetBreakpoint_HitsAndInspectsVariable**
    - Call `Dbg.LaunchAsync(HelloDebugProject, HelloDebugDll, ct: cts.Token)`
    - Set breakpoint on Program.cs line 17 (`int counter = 0;`) — use `SetBreakpointAsync`
    - Call `ContinueAsync` (past CreateProcess stop)
    - Drain to `BreakpointHitEvent`; assert `hit.BreakpointId` equals returned bpId
    - Call `GetLocalsAsync(0, cts.Token)`; assert result contains a variable named `counter` with Value `"0"`
    - Call `ContinueAsync`, then `DrainToExit` to consume remaining events
    - Call `DisconnectAsync`

    **Test 2: LaunchAsync_StepOver_AdvancesLine**
    - LaunchAsync, set BP on line 17, ContinueAsync
    - Drain to BreakpointHitEvent
    - Call `StepOverAsync(cts.Token)`; drain to next StoppedEvent (step complete)
    - Call `GetLocalsAsync`; assert result contains `counter` (value may still be "0" or "1" depending on JIT — just assert it exists)
    - ContinueAsync, DrainToExit, DisconnectAsync

    **Test 3: LaunchAsync_StepInto_EntersMethod**
    - LaunchAsync, set BP on the Fibonacci call line (Section 6 — look for `Fibonacci(` in Program.cs to find the line; it's around line 62-65)
    - Read Program.cs to confirm the exact line number for the `int fib = Fibonacci(10);` call
    - ContinueAsync, drain to BreakpointHitEvent
    - Call `StepIntoAsync(cts.Token)`; drain to next StoppedEvent
    - Call `GetStackTraceAsync(0, cts.Token)`; assert frames.Count >= 2 (we stepped into Fibonacci, so at least 2 frames)
    - ContinueAsync, DrainToExit, DisconnectAsync

    **Test 4: LaunchAsync_NaturalExit_DeliversExitedEvent**
    - LaunchAsync (no breakpoints), ContinueAsync
    - DrainToExit — verify process runs to completion
    - DisconnectAsync

    **Class structure:**
    ```csharp
    using System.Diagnostics;
    using DebuggerNetMcp.Core.Engine;
    using DebuggerNetMcp.Core.Models;

    namespace DebuggerNetMcp.Tests;

    [Collection("Debugger")]
    public class DebuggerIntegrationTests(DebuggerFixture fixture)
    {
        private DotnetDebugger Dbg => fixture.Debugger;
        // ... paths, helpers, [Fact] methods
    }
    ```

    **Key implementation notes:**
    - `LaunchAsync` signature: `LaunchAsync(string projectPath, string appDllPath, bool notifyFirstChanceExceptions = false, CancellationToken ct = default)` — pass `ct: cts.Token`
    - After `LaunchAsync` returns, the process is stopped at CreateProcess — always call `ContinueAsync` before expecting breakpoints
    - `SetBreakpointAsync(dllPath, sourceFile, line, ct)` — pass `HelloDebugDll` not project path
    - `GetLocalsAsync(uint threadId = 0, CancellationToken ct = default)` — pass `0` for threadId
    - HelloDebug section 21 throws unhandled exception — DrainToExit handles BreakpointHitEvent and StoppedEvent by calling ContinueAsync to keep it running
    - All tests MUST call `DisconnectAsync` at the end — the fixture's DisposeAsync will also call it, but each test should clean up itself
  </action>
  <verify>
    ```bash
    dotnet test tests/DebuggerNetMcp.Tests/ -c Debug --filter "FullyQualifiedName~DebuggerIntegrationTests" --timeout 120
    ```
    All 4 tests pass. If any test times out, check that ContinueAsync is being called after LaunchAsync.
  </verify>
  <done>
    4 DebuggerIntegrationTests pass:
    - LaunchAsync_SetBreakpoint_HitsAndInspectsVariable
    - LaunchAsync_StepOver_AdvancesLine
    - LaunchAsync_StepInto_EntersMethod
    - LaunchAsync_NaturalExit_DeliversExitedEvent
  </done>
</task>

<task type="auto">
  <name>Task 2: Write DebuggerAdvancedTests.cs — exceptions, multi-thread, attach</name>
  <files>
    tests/DebuggerNetMcp.Tests/DebuggerAdvancedTests.cs
  </files>
  <action>
    Create `tests/DebuggerNetMcp.Tests/DebuggerAdvancedTests.cs`.

    Use same path constants and WaitForSpecificEvent/DrainToExit helpers (copy them — or extract to a shared base class if preferred).

    **Test 1: Launch_UnhandledException_DeliversExceptionEvent**
    - LaunchAsync (no breakpoints), ContinueAsync
    - Drain to `ExceptionEvent` using WaitForSpecificEvent
    - Assert `exEv.IsUnhandled == true`
    - Assert `exEv.ExceptionType` contains `"InvalidOperationException"`
    - Assert `exEv.Message` contains `"Section 21 unhandled"`
    - DrainToExit (process will exit after unhandled exception), DisconnectAsync

    **Test 2: Launch_MultipleThreads_AllThreadsVisible**
    - LaunchAsync, ContinueAsync (no breakpoints)
    - Set BP on line 149 (the `Console.WriteLine` inside the background thread lambda — `// <── BP-20`)
    - Read Program.cs to confirm the exact line for the background thread WriteLine
    - Drain to BreakpointHitEvent
    - Call `GetAllThreadStackTracesAsync(cts.Token)` — assert result.Count >= 2 (main thread + background thread)
    - ContinueAsync, DrainToExit, DisconnectAsync

    **Test 3: AttachAsync_RunningProcess_AttachesSuccessfully**
    - Launch HelloDebug as a standalone process (not via DotnetDebugger):
      ```csharp
      using var target = Process.Start(new ProcessStartInfo
      {
          FileName = "dotnet",
          Arguments = HelloDebugDll,
          UseShellExecute = false,
          RedirectStandardOutput = true,
          RedirectStandardError = true,
      })!;
      ```
    - Delay 800ms to give CLR time to initialize: `await Task.Delay(800, cts.Token)`
    - Call `await Dbg.AttachAsync((uint)target.Id, cts.Token)`
    - Assert returned pid == (uint)target.Id
    - Assert returned processName is not empty
    - Call `DisconnectAsync`, then `target.Kill()` (process may already have exited — wrap in try/catch)

    **Class structure:**
    ```csharp
    using System.Diagnostics;
    using DebuggerNetMcp.Core.Engine;
    using DebuggerNetMcp.Core.Models;

    namespace DebuggerNetMcp.Tests;

    [Collection("Debugger")]
    public class DebuggerAdvancedTests(DebuggerFixture fixture)
    {
        private DotnetDebugger Dbg => fixture.Debugger;
        // ... paths, helpers, [Fact] methods
    }
    ```

    **Key implementation notes:**
    - For multi-thread test (Test 2): set the breakpoint BEFORE calling ContinueAsync, not after.
      The process stops at CreateProcess, so: LaunchAsync → SetBreakpointAsync(line 149) → ContinueAsync → drain to BreakpointHitEvent
    - Confirm line 149 is correct for BP-20 by reading Program.cs — if different, use the actual line.
    - For unhandled exception test: `ExceptionEvent` fields depend on the model — check `Models.cs` for the actual property names. Research shows `IsUnhandled`, `ExceptionType`, `Message` — verify against the actual class.
    - For attach test: `AttachAsync` returns `(uint Pid, string ProcessName)` — confirmed from roslyn-nav.
    - Exception: after `WaitForSpecificEvent<ExceptionEvent>`, the process is paused (ICorDebug stops on unhandled). Call `ContinueAsync` once more before `DrainToExit` so the process actually exits.
    - The `[Collection("Debugger")]` attribute on both `DebuggerIntegrationTests` and `DebuggerAdvancedTests` ensures they share the same collection and run sequentially — they do NOT run in parallel.
  </action>
  <verify>
    ```bash
    dotnet test tests/DebuggerNetMcp.Tests/ -c Debug --filter "FullyQualifiedName~DebuggerAdvancedTests" --timeout 120
    ```
    All 3 tests pass. If the attach test is flaky (race condition), increase the delay from 800ms to 1500ms.
  </verify>
  <done>
    3 DebuggerAdvancedTests pass:
    - Launch_UnhandledException_DeliversExceptionEvent
    - Launch_MultipleThreads_AllThreadsVisible
    - AttachAsync_RunningProcess_AttachesSuccessfully
  </done>
</task>

</tasks>

<verification>
Run the full integration test suite:
```bash
dotnet test tests/DebuggerNetMcp.Tests/ -c Debug --timeout 180
```
Expected: 12 tests total passing (2 MathTests + 5 PdbReaderTests + 4 DebuggerIntegrationTests + 3 DebuggerAdvancedTests).

If tests fail due to timing issues (rare), re-run once — ICorDebug timing can be slightly variable on first run.
</verification>

<success_criteria>
1. `dotnet test tests/DebuggerNetMcp.Tests/ -c Debug` runs all tests sequentially and reports 12 passed, 0 failed.
2. DebuggerIntegrationTests: launch/breakpoint/variables/step/exit all passing.
3. DebuggerAdvancedTests: unhandled exception event, multi-thread visibility, and process attach all passing.
4. No test exceeds 30 seconds (CancellationTokenSource enforces this).
5. Tests run in sequential order within the "Debugger" collection (verified by xunit output showing collection name).
</success_criteria>

<output>
After completion, create `.planning/phases/09-tests-documentation/09-02-SUMMARY.md`
</output>
