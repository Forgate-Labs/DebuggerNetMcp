---
phase: 09-tests-documentation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/DebuggerNetMcp.Tests/DebuggerNetMcp.Tests.csproj
  - tests/DebuggerNetMcp.Tests/UnitTest1.cs
  - tests/DebuggerNetMcp.Tests/MathTests.cs
  - tests/DebuggerNetMcp.Tests/PdbReaderTests.cs
  - tests/DebuggerNetMcp.Tests/DebuggerFixture.cs
autonomous: true
requirements:
  - TEST-02

must_haves:
  truths:
    - "`dotnet test` runs PdbReaderTests and all assertions pass without manual intervention"
    - "PdbReader.FindLocation returns a non-zero methodToken for a known HelloDebug source line"
    - "PdbReader.ReverseLookup round-trips back to the same source file and line number"
    - "DebuggerFixture loads libdbgshim.so (via DBGSHIM_PATH env var or ~/.local/bin fallback) without throwing"
    - "MathTests still exists and passes (renamed from UnitTest1.cs)"
  artifacts:
    - path: "tests/DebuggerNetMcp.Tests/PdbReaderTests.cs"
      provides: "PdbReader forward and reverse lookup unit tests"
      contains: "FindLocation_KnownSourceLine_ReturnsNonZeroToken"
    - path: "tests/DebuggerNetMcp.Tests/DebuggerFixture.cs"
      provides: "ICollectionFixture<DebuggerFixture> + CollectionDefinition with DisableParallelization"
      contains: "DebuggerCollection"
    - path: "tests/DebuggerNetMcp.Tests/MathTests.cs"
      provides: "Renamed UnitTest1.cs — MathTests class preserved for debug_launch_test verification"
      contains: "AddTwoNumbers_ReturnsCorrectSum"
    - path: "tests/DebuggerNetMcp.Tests/DebuggerNetMcp.Tests.csproj"
      provides: "HelloDebug ProjectReference with ReferenceOutputAssembly=false"
      contains: "ReferenceOutputAssembly"
  key_links:
    - from: "tests/DebuggerNetMcp.Tests/PdbReaderTests.cs"
      to: "tests/HelloDebug/bin/Debug/net10.0/HelloDebug.dll"
      via: "AppContext.BaseDirectory path arithmetic (4 levels up)"
      pattern: "AppContext\\.BaseDirectory"
    - from: "tests/DebuggerNetMcp.Tests/DebuggerFixture.cs"
      to: "DotnetDebugger constructor"
      via: "DBGSHIM_PATH env var or ~/.local/bin/libdbgshim.so fallback"
      pattern: "DBGSHIM_PATH"
---

<objective>
Set up xUnit test infrastructure and implement PdbReader unit tests (TEST-02).

Purpose: PdbReader.FindLocation and PdbReader.ReverseLookup are pure static methods — ideal first tests to validate the test setup works before attempting full integration tests. Setting up the shared DebuggerFixture here ensures Plan 02 can focus purely on writing test logic.

Output:
- `tests/DebuggerNetMcp.Tests/DebuggerNetMcp.Tests.csproj` — updated with HelloDebug ProjectReference
- `tests/DebuggerNetMcp.Tests/MathTests.cs` — renamed from UnitTest1.cs (content unchanged)
- `tests/DebuggerNetMcp.Tests/PdbReaderTests.cs` — forward + reverse lookup tests
- `tests/DebuggerNetMcp.Tests/DebuggerFixture.cs` — shared fixture + collection definition
</objective>

<execution_context>
@/home/eduardo/.claude/get-shit-done/workflows/execute-plan.md
@/home/eduardo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-tests-documentation/09-RESEARCH.md

@tests/DebuggerNetMcp.Tests/DebuggerNetMcp.Tests.csproj
@tests/DebuggerNetMcp.Tests/UnitTest1.cs
@src/DebuggerNetMcp.Core/Engine/PdbReader.cs
@tests/HelloDebug/Program.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update csproj, rename UnitTest1.cs → MathTests.cs, add DebuggerFixture</name>
  <files>
    tests/DebuggerNetMcp.Tests/DebuggerNetMcp.Tests.csproj
    tests/DebuggerNetMcp.Tests/MathTests.cs
    tests/DebuggerNetMcp.Tests/DebuggerFixture.cs
  </files>
  <action>
    1. Update `tests/DebuggerNetMcp.Tests/DebuggerNetMcp.Tests.csproj`:
       - Add a `ProjectReference` to HelloDebug so it builds before tests run:
         ```xml
         <ProjectReference Include="..\..\tests\HelloDebug\HelloDebug.csproj"
                           ReferenceOutputAssembly="false"
                           Private="false" />
         ```
       - Add global usings for the test namespaces used across all test files:
         ```xml
         <Using Include="DebuggerNetMcp.Core.Engine" />
         <Using Include="DebuggerNetMcp.Core.Models" />
         ```

    2. Rename `tests/DebuggerNetMcp.Tests/UnitTest1.cs` → `tests/DebuggerNetMcp.Tests/MathTests.cs`.
       The file content is already correct (class `MathTests`). Just rename — do not change any code.
       Delete the old UnitTest1.cs after creating MathTests.cs.

    3. Create `tests/DebuggerNetMcp.Tests/DebuggerFixture.cs`:
       ```csharp
       using DebuggerNetMcp.Core.Engine;

       namespace DebuggerNetMcp.Tests;

       public sealed class DebuggerFixture : IAsyncLifetime
       {
           public DotnetDebugger Debugger { get; private set; } = null!;

           public async Task InitializeAsync()
           {
               var dbgShimPath = Environment.GetEnvironmentVariable("DBGSHIM_PATH")
                   ?? Path.Combine(
                       Environment.GetFolderPath(Environment.SpecialFolder.UserProfile),
                       ".local", "bin", "libdbgshim.so");

               Debugger = new DotnetDebugger(dbgShimPath);
               await Task.CompletedTask;
           }

           public async Task DisposeAsync()
           {
               await Debugger.DisposeAsync();
           }
       }

       [CollectionDefinition("Debugger", DisableParallelization = true)]
       public class DebuggerCollection : ICollectionFixture<DebuggerFixture> { }
       ```

    Note: `DotnetDebugger` constructor signature — check if it accepts dbgShimPath as first positional
    argument by reading the constructor in DotnetDebugger.cs. If the constructor uses DbgShimInterop
    internally without an explicit path parameter, then in `InitializeAsync` set the `DBGSHIM_PATH`
    environment variable instead of passing it directly:
    ```csharp
    // Alternative if constructor doesn't accept path:
    Environment.SetEnvironmentVariable("DBGSHIM_PATH", dbgShimPath);
    Debugger = new DotnetDebugger();
    ```
    Read the constructor signature before writing to avoid compilation errors.
  </action>
  <verify>
    `dotnet build tests/DebuggerNetMcp.Tests/ -c Debug` completes without errors.
    Confirm MathTests.cs exists and UnitTest1.cs does not exist in the directory.
  </verify>
  <done>
    Tests project compiles cleanly. MathTests.cs contains the two [Fact] methods.
    DebuggerFixture.cs compiles with IAsyncLifetime and CollectionDefinition.
    csproj has HelloDebug ProjectReference with ReferenceOutputAssembly="false".
  </done>
</task>

<task type="auto">
  <name>Task 2: Write PdbReaderTests.cs — forward and reverse lookup</name>
  <files>
    tests/DebuggerNetMcp.Tests/PdbReaderTests.cs
  </files>
  <action>
    Create `tests/DebuggerNetMcp.Tests/PdbReaderTests.cs` with the following tests.

    The HelloDebug.dll path must be computed from `AppContext.BaseDirectory`:
    - BaseDirectory = `tests/DebuggerNetMcp.Tests/bin/Debug/net10.0/`
    - HelloDebug.dll = 4 levels up + `HelloDebug/bin/Debug/net10.0/HelloDebug.dll`
    - Use: `Path.GetFullPath(Path.Combine(AppContext.BaseDirectory, "..", "..", "..", "..", "HelloDebug", "bin", "Debug", "net10.0", "HelloDebug.dll"))`

    Known HelloDebug source locations (from Program.cs inspection):
    - Line 17: `int counter = 0;` — Section 1, first executable line (BP-1 target)
    - Line 25: `string greeting = "Hello, World!";` — Section 2

    ```csharp
    using DebuggerNetMcp.Core.Engine;

    namespace DebuggerNetMcp.Tests;

    public class PdbReaderTests
    {
        private static readonly string HelloDebugDll = Path.GetFullPath(
            Path.Combine(AppContext.BaseDirectory,
                "..", "..", "..", "..",
                "HelloDebug", "bin", "Debug", "net10.0", "HelloDebug.dll"));

        [Fact]
        public void HelloDebugDll_Exists()
        {
            // Fails early with a clear message if the ProjectReference didn't build HelloDebug
            Assert.True(File.Exists(HelloDebugDll),
                $"HelloDebug.dll not found at: {HelloDebugDll}");
        }

        [Fact]
        public void FindLocation_Section1Primitives_ReturnsNonZeroToken()
        {
            // Program.cs line 17: "int counter = 0;"  (Section 1 BP-1)
            var (methodToken, ilOffset) = PdbReader.FindLocation(HelloDebugDll, "Program.cs", 17);
            Assert.NotEqual(0, methodToken);
            Assert.True(ilOffset >= 0);
        }

        [Fact]
        public void FindLocation_Section2Strings_ReturnsNonZeroToken()
        {
            // Program.cs line 25: "string greeting = "Hello, World!";"
            var (methodToken, ilOffset) = PdbReader.FindLocation(HelloDebugDll, "Program.cs", 25);
            Assert.NotEqual(0, methodToken);
            Assert.True(ilOffset >= 0);
        }

        [Fact]
        public void ReverseLookup_ForwardResult_RoundTripsToSameLine()
        {
            // Forward lookup then reverse — must return same source file and line
            var (methodToken, ilOffset) = PdbReader.FindLocation(HelloDebugDll, "Program.cs", 17);
            Assert.NotEqual(0, methodToken);

            var result = PdbReader.ReverseLookup(HelloDebugDll, methodToken, ilOffset);

            Assert.NotNull(result);
            Assert.Contains("Program.cs", result!.Value.sourceFile,
                StringComparison.OrdinalIgnoreCase);
            Assert.Equal(17, result.Value.line);
        }

        [Fact]
        public void ReverseLookup_NearbyOffset_ReturnsSameOrEarlierLine()
        {
            // Nearest-sequence-point semantics: offset+1 should still map to a valid line <= 17
            var (methodToken, ilOffset) = PdbReader.FindLocation(HelloDebugDll, "Program.cs", 17);
            Assert.NotEqual(0, methodToken);

            var result = PdbReader.ReverseLookup(HelloDebugDll, methodToken, ilOffset + 1);

            // Nearest SP: should still resolve to Program.cs at line <= 17 (not null)
            Assert.NotNull(result);
            Assert.Contains("Program.cs", result!.Value.sourceFile,
                StringComparison.OrdinalIgnoreCase);
        }
    }
    ```
  </action>
  <verify>
    `dotnet test tests/DebuggerNetMcp.Tests/ -c Debug --filter "FullyQualifiedName~PdbReaderTests"` passes all 5 tests.
    If HelloDebugDll_Exists fails, run `dotnet build tests/HelloDebug/ -c Debug` first to ensure the artifact exists.
  </verify>
  <done>
    All 5 PdbReaderTests pass: HelloDebugDll_Exists, FindLocation for lines 17 and 25, ReverseLookup round-trip, and nearest-SP test.
    `dotnet test` output shows 5 passed, 0 failed.
  </done>
</task>

</tasks>

<verification>
Run the full test suite to verify no regressions:
```bash
dotnet test tests/DebuggerNetMcp.Tests/ -c Debug
```
Expected: MathTests (2 tests) + PdbReaderTests (5 tests) = 7 tests passed, 0 failed.
(DebuggerIntegrationTests and DebuggerAdvancedTests don't exist yet — they come in Plan 02.)
</verification>

<success_criteria>
1. `dotnet build tests/DebuggerNetMcp.Tests/ -c Debug` compiles without errors.
2. `dotnet test tests/DebuggerNetMcp.Tests/ -c Debug --filter "FullyQualifiedName~PdbReaderTests"` shows 5 passed, 0 failed.
3. `dotnet test tests/DebuggerNetMcp.Tests/ -c Debug --filter "FullyQualifiedName~MathTests"` shows 2 passed, 0 failed.
4. UnitTest1.cs no longer exists; MathTests.cs exists with the same content.
5. DebuggerFixture.cs compiles with `[CollectionDefinition("Debugger", DisableParallelization = true)]`.
6. Tests.csproj has HelloDebug ProjectReference with `ReferenceOutputAssembly="false"`.
</success_criteria>

<output>
After completion, create `.planning/phases/09-tests-documentation/09-01-SUMMARY.md`
</output>
