---
phase: 06-closures-iterators-object-graph
plan: 03
type: execute
wave: 2
depends_on: [06-01, 06-02]
files_modified:
  - tests/HelloDebug/Program.cs
autonomous: false
requirements: [TEST-08]

must_haves:
  truths:
    - "HelloDebug has section 17 with a lambda that captures variables and a BP-17 comment on the inner line"
    - "HelloDebug has section 18 with an iterator (yield return) and a BP-18 comment after iter.MoveNext()"
    - "HelloDebug has section 19 with a CircularRef object where Self = itself and a BP-19 comment"
    - "HelloDebug builds successfully after the additions"
    - "Manual verification confirms closure vars, iterator Current, and circular ref marker all work"
  artifacts:
    - path: "tests/HelloDebug/Program.cs"
      provides: "Sections 17, 18, 19 for closure, iterator, circular reference testing"
      contains: "BP-17"
    - path: "tests/HelloDebug/Program.cs"
      provides: "CircularRef class definition"
      contains: "CircularRef"
  key_links:
    - from: "tests/HelloDebug/Program.cs section 17"
      to: "DotnetDebugger.GetLocalsAsync closure path"
      via: "BP-17 breakpoint inside lambda showing capturedValue, capturedName"
      pattern: "capturedValue.*capturedName|BP-17"
    - from: "tests/HelloDebug/Program.cs section 18"
      to: "DotnetDebugger.GetLocalsAsync iterator Current"
      via: "BP-18 breakpoint showing iter.Current = 10"
      pattern: "iter.MoveNext|BP-18"
    - from: "tests/HelloDebug/Program.cs section 19"
      to: "VariableReader.ReadObject circular reference guard"
      via: "BP-19 breakpoint inspecting circular.Self"
      pattern: "circular.Self|BP-19"
---

<objective>
Add HelloDebug sections 17-19 (closure, iterator, circular reference) and manually verify the Phase 6 engine changes work end-to-end.

Purpose: TEST-08 requires HelloDebug to have sections covering the three new scenarios so the debugger changes from Plans 01 and 02 can be exercised interactively. The sections follow the existing BP-N comment convention.

Output: Updated `tests/HelloDebug/Program.cs` with sections 17, 18, 19 and their supporting type definitions. Manual verification confirms all Phase 6 requirements are observable.
</objective>

<execution_context>
@/home/eduardo/.claude/get-shit-done/workflows/execute-plan.md
@/home/eduardo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-closures-iterators-object-graph/06-RESEARCH.md
@.planning/phases/06-closures-iterators-object-graph/06-01-SUMMARY.md
@.planning/phases/06-closures-iterators-object-graph/06-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add sections 17-19 to HelloDebug and rebuild</name>
  <files>tests/HelloDebug/Program.cs</files>
  <action>
Read the current `tests/HelloDebug/Program.cs` to find the exact line of:
```csharp
Console.WriteLine("[HelloDebug] Session complete");
```

Insert the three new sections BEFORE that line. Follow the exact comment style of sections 1-16 (separator line, section header, BP comment, expected comment, code, Console.WriteLine with BP marker).

**Section 17 — Closure:**
```csharp
// ─── SECTION 17: Closure (lambda capture) ────────────────────────────────────
// BP-17: Set breakpoint on the Console.WriteLine inside the lambda.
// Expected: capturedValue=100, capturedName="world" visible as locals.
int capturedValue = 100;
string capturedName = "world";
Action action17 = () =>
{
    Console.WriteLine($"[17] Closure: {capturedName}={capturedValue}");  // <── BP-17
};
action17();
```

**Section 18 — Iterator:**
```csharp
// ─── SECTION 18: Iterator (yield return) ─────────────────────────────────────
// BP-18: Set breakpoint on the Console.WriteLine line below (after MoveNext).
// Expected: 'iter' shows Current=10, _state fields visible.
var iter = GetNumbers().GetEnumerator();
iter.MoveNext();
Console.WriteLine($"[18] Iterator Current: {iter.Current}");  // <── BP-18

static IEnumerable<int> GetNumbers()
{
    yield return 10;
    yield return 20;
    yield return 30;
}
```

**Section 19 — Circular reference:**
```csharp
// ─── SECTION 19: Circular reference ──────────────────────────────────────────
// BP-19: Set breakpoint on the Console.WriteLine below.
// Expected: inspecting 'circObj' shows Self="<circular reference>" not a crash.
var circObj = new CircularRef();
circObj.Self = circObj;
Console.WriteLine($"[19] Circular: Value={circObj.Value}");  // <── BP-19
```

Then add the `CircularRef` class definition to the `// ─── Types ───` section at the bottom of the file (after the existing `AppConfig` class):

```csharp
// Section 19: circular reference
class CircularRef
{
    public int Value = 42;
    public CircularRef? Self;
}
```

NOTE: The `GetNumbers()` local function in section 18 uses `static` keyword to be a file-scoped local function (compatible with top-level program style). Ensure `IEnumerable<int>` is importable — `System.Collections.Generic` is already in the `using` directives at the top of the file.

After inserting, run: `dotnet build tests/HelloDebug/ 2>&1 | tail -5`
Expected: Build succeeded. If there are compiler errors fix them before proceeding.
  </action>
  <verify>
Run: `dotnet build tests/HelloDebug/ 2>&1 | tail -5`
Expected: Build succeeded with 0 errors.

Confirm section markers are present:
`grep -n "BP-17\|BP-18\|BP-19\|CircularRef\|GetNumbers" tests/HelloDebug/Program.cs`
Expected: 5 matches at distinct lines.
  </verify>
  <done>HelloDebug builds successfully. Sections 17, 18, 19 are present with BP-17, BP-18, BP-19 comment markers. The `CircularRef` class and `GetNumbers()` iterator function are defined.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Live debug session — verify all Phase 6 requirements</name>
  <action>
Build the MCP server Release binary before running:
`dotnet build src/DebuggerNetMcp.Mcp/ -c Release`

Then run the debug sessions described in how-to-verify.
  </action>
  <what-built>
Plans 01 and 02 implemented: GetLocalsAsync detects closure display class methods (>b__) and exposes iterator &lt;&gt;2__current as "Current". VariableReader threads a HashSet&lt;ulong&gt; visited set through ReadValue/ReadObject for circular reference detection, and enumerates PE properties for computed property reporting. HelloDebug has sections 17-19.
  </what-built>
  <how-to-verify>
Use the standard debug flow for each test: `debug_launch` → `debug_set_breakpoint` → `debug_continue` → `debug_variables`.

**Test 1 — CLSR-01: Closure captured variables (BP-17)**
1. `debug_launch(projectPath="tests/HelloDebug")`
2. `debug_set_breakpoint(file="Program.cs", line=&lt;BP-17 line&gt;)` — the Console.WriteLine inside the lambda
3. `debug_continue()` until breakpoint hits
4. `debug_variables()`
5. Expected: `capturedValue=100` and `capturedName="world"` in result (clean names, no angle-bracket suffixes)

**Test 2 — CLSR-02: Iterator state (BP-18)**
1. New session: `debug_launch` + set BP at BP-18 line + `debug_continue`
2. `debug_variables()` — locate `iter` in the result, expand it
3. Expected: `iter` children include `Current=10` and `_state` with a numeric value (0 or 1)

**Test 3 — GRAPH-01: Circular reference (BP-19)**
1. New session: `debug_launch` + set BP at BP-19 line + `debug_continue`
2. `debug_evaluate("circObj")` or `debug_variables()` and expand `circObj`
3. Expected: `circObj.Self` value is `"&lt;circular reference&gt;"` — no crash, no `&lt;max depth&gt;`

**Test 4 — GRAPH-02: Computed property (BP-5 with Person record)**
1. New session: `debug_launch` + set BP at BP-5 line + `debug_continue`
2. `debug_variables()` — inspect `person`
3. Expected: Either computed properties appear as `&lt;computed&gt;`, or no regression from prior behavior (Person record uses auto-properties which have backing fields, so no `&lt;computed&gt;` entries expected for Name/Age/Home).
  </how-to-verify>
  <verify>Human confirms tests 1-3 return the expected values; test 4 shows no regression.</verify>
  <done>All four Phase 6 requirements observable: CLSR-01, CLSR-02, GRAPH-01 confirmed working. GRAPH-02 confirmed non-regressive.</done>
  <resume-signal>Type "approved" if all tests pass, or describe which tests failed and what the actual output was.</resume-signal>
</task>

</tasks>

<verification>
All acceptance criteria pass when:
1. `debug_variables` at BP-17 shows `capturedValue` and `capturedName` with correct values
2. `debug_variables` at BP-18 shows `Current=10` and `_state` in the iterator
3. `debug_variables`/`debug_evaluate` at BP-19 shows `Self="&lt;circular reference&gt;"` without crashing
4. Build passes: `dotnet build src/ && dotnet build tests/HelloDebug/` both succeed
</verification>

<success_criteria>
- HelloDebug builds with sections 17-19 present
- MCP server Release build succeeds
- Closure-captured variables display with clean names (CLSR-01)
- Iterator Current value and _state field visible (CLSR-02)
- Circular object graph returns marker instead of crash (GRAPH-01)
- All prior HelloDebug sections (1-16) still work correctly
</success_criteria>

<output>
After completion, create `.planning/phases/06-closures-iterators-object-graph/06-03-SUMMARY.md`
</output>
