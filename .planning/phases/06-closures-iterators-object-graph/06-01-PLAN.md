---
phase: 06-closures-iterators-object-graph
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs
autonomous: true
requirements: [CLSR-01, CLSR-02]

must_haves:
  truths:
    - "debug_variables inside a lambda shows captured variables with clean names (e.g., capturedValue, capturedStr — no angle-bracket suffixes)"
    - "debug_variables on an iterator's MoveNext shows Current (the last yielded value) and _state (the iterator position)"
    - "Closure detection does not break the existing async state machine path"
  artifacts:
    - path: "src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs"
      provides: "GetLocalsAsync with closure + iterator extensions"
      contains: "isClosureMethod"
    - path: "src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs"
      provides: "Iterator Current field exposed"
      contains: "<>2__current"
  key_links:
    - from: "DotnetDebugger.GetLocalsAsync"
      to: "smMethodName.Contains(\">b__\")"
      via: "closure detection branch"
      pattern: ">b__"
    - from: "DotnetDebugger.GetLocalsAsync"
      to: "fieldName == \"<>2__current\""
      via: "iterator Current exposure"
      pattern: "<>2__current"
---

<objective>
Extend GetLocalsAsync to display closure-captured variables and iterator state.

Purpose: When stopped inside a lambda, the active frame is a method named `<<Main>$>b__0` on a `<>c__DisplayClass` type. GetLocalsAsync currently only handles `MoveNext` state machines. Closures need the same `GetArgument(0)` → `this` → read fields pattern. Iterator state machines already go through the `MoveNext` path, but `<>2__current` (the last yielded value) is incorrectly skipped by the `<>` infrastructure filter.

Output: Modified `DotnetDebugger.cs` with two targeted changes to `GetLocalsAsync`.
</objective>

<execution_context>
@/home/eduardo/.claude/get-shit-done/workflows/execute-plan.md
@/home/eduardo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-closures-iterators-object-graph/06-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Closure detection — extend GetLocalsAsync to handle display class methods</name>
  <files>src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs</files>
  <action>
In `GetLocalsAsync` (lines 688-845), locate the existing state machine detection block:

```csharp
if (smMethodName == "MoveNext" && smTypeFields.Count > 0)
```

Change the condition to also trigger for closure display class methods:

```csharp
bool isClosureMethod = smMethodName.Contains(">b__");
if ((smMethodName == "MoveNext" || isClosureMethod) && smTypeFields.Count > 0)
```

The body of the `if` block does NOT change. Closure fields use original names (`captured`, `capturedStr`) — no angle brackets. The existing field-name logic handles them correctly:
- The `if (fieldName.StartsWith("<>")) continue;` guard skips infrastructure fields only.
- The `if (fieldName.StartsWith("<"))` branch extracts names from `<Name>k__BackingField` patterns — for plain names like `captured`, the `else` branch fires and `displayName = fieldName` directly.

IMPORTANT: Do NOT change the inner field-processing loop. The same logic works for both closures and async state machines. The only change is the outer `if` condition.

Also add a `// NEW: closure display class detection` comment above the `bool isClosureMethod` line to make it clear this was intentionally extended.
  </action>
  <verify>
Run: `dotnet build src/DebuggerNetMcp.Core/ 2>&1 | tail -5`
Expected: Build succeeded with 0 errors.
  </verify>
  <done>
Build succeeds. The `GetLocalsAsync` method now enters the state machine `this`-reading path when `smMethodName` contains `>b__` (closure lambda methods), in addition to the existing `MoveNext` path.
  </done>
</task>

<task type="auto">
  <name>Task 2: Iterator Current — expose &lt;&gt;2__current as "Current" and &lt;&gt;1__state as "_state"</name>
  <files>src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs</files>
  <action>
Still in `GetLocalsAsync`, inside the field-processing loop of the state machine block, locate the existing guard:

```csharp
// Skip compiler infrastructure fields: <>1__state, <>t__builder, <>u__1 etc.
if (fieldName.StartsWith("<>")) continue;
```

Replace this single guard with three checks (order matters — the specific checks must come BEFORE the general `<>` skip):

```csharp
// Iterator current value: expose as "Current" instead of skipping
string displayName = fieldName;
if (fieldName == "<>2__current")
{
    displayName = "Current";
    // fall through — do NOT continue
}
// Iterator / async state position: expose as "_state"
else if (fieldName == "<>1__state")
{
    displayName = "_state";
    // fall through — do NOT continue
}
// Skip all other compiler infrastructure fields: <>t__builder, <>u__1 etc.
else if (fieldName.StartsWith("<>"))
{
    continue;
}
// Existing hoisted variable name extraction (async): <counter>5__2 → "counter"
else if (fieldName.StartsWith("<"))
{
    int closeAngle = fieldName.IndexOf('>');
    if (closeAngle > 1)
        displayName = fieldName.Substring(1, closeAngle - 1);
    else
        continue; // malformed name — skip
}
// else: plain name (closures) — displayName = fieldName already set above
```

IMPORTANT: Remove the old `string displayName = fieldName;` and the old `if (fieldName.StartsWith("<>")) continue;` and the old `if (fieldName.StartsWith("<"))` block entirely — replace the whole block with the new version above. There must be only ONE `string displayName` declaration at the start of the new block.

After this change, the `objVal.GetFieldValue` + `result.Add` lines below remain unchanged.
  </action>
  <verify>
Run: `dotnet build src/DebuggerNetMcp.Core/ 2>&1 | tail -5`
Expected: Build succeeded with 0 errors, 0 warnings related to these changes.

Also grep to confirm both strings are present:
`grep -n "Current\|_state\|2__current\|1__state" src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs`
Expected: Lines showing `"<>2__current"` mapped to `"Current"` and `"<>1__state"` mapped to `"_state"`.
  </verify>
  <done>
Build succeeds. `<>2__current` is mapped to display name `"Current"` and `<>1__state` is mapped to `"_state"`. All other `<>` prefixed fields continue to be skipped. The async hoisted-variable path (`<counter>5__2` → `counter`) is preserved.
  </done>
</task>

</tasks>

<verification>
Run the full solution build to confirm no regressions:
`dotnet build src/ 2>&1 | grep -E "error|warning|succeeded"`

Expected: Build succeeded. Zero errors.

Confirm the two key patterns exist in the modified file:
`grep -n "isClosureMethod\|>b__\|<>2__current\|<>1__state" src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs`

Expected output shows all four strings present at correct lines.
</verification>

<success_criteria>
- `dotnet build src/` succeeds with 0 errors
- `GetLocalsAsync` enters the state machine `this`-reading path when stopped in a lambda (smMethodName contains `>b__`)
- Iterator `<>2__current` field is shown as `Current` in variable output
- Iterator `<>1__state` field is shown as `_state` in variable output
- Existing async state machine behavior (`MoveNext` path, hoisted `<counter>5__2` → `counter`) is unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/06-closures-iterators-object-graph/06-01-SUMMARY.md`
</output>
