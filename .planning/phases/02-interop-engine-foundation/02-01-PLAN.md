---
phase: 02-interop-engine-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/DebuggerNetMcp.Core/Engine/Models.cs
autonomous: true
requirements:
  - ENGINE-01

must_haves:
  truths:
    - "BreakpointInfo, StackFrameInfo, VariableInfo, and EvalResult types exist as immutable records in DebuggerNetMcp.Core"
    - "DebugEvent is an abstract base class with 5 sealed subclasses: StoppedEvent, BreakpointHitEvent, ExceptionEvent, ExitedEvent, OutputEvent"
    - "dotnet build completes without errors after Models.cs is added"
  artifacts:
    - path: "src/DebuggerNetMcp.Core/Engine/Models.cs"
      provides: "All Phase 2-5 shared data model types"
      min_lines: 50
  key_links:
    - from: "src/DebuggerNetMcp.Core/Engine/Models.cs"
      to: "src/DebuggerNetMcp.Core/Engine/VariableReader.cs"
      via: "VariableInfo return type"
      pattern: "VariableInfo"
    - from: "src/DebuggerNetMcp.Core/Engine/Models.cs"
      to: "src/DebuggerNetMcp.Core/Engine/PdbReader.cs"
      via: "no direct dependency (PdbReader returns tuples, not Models types)"
      pattern: "N/A"
---

<objective>
Define all shared data model types for the DebuggerNetMcp debug engine in a single Models.cs file.

Purpose: Phase 3 (DotnetDebugger.cs), Phase 4 (MCP tools), and Phase 5 (tests) all depend on these types. Defining them first, in isolation, lets Plans 02-02 and 02-03 proceed without model stubs.
Output: src/DebuggerNetMcp.Core/Engine/Models.cs with all record types and the DebugEvent hierarchy.
</objective>

<execution_context>
@/home/eduardo/.claude/get-shit-done/workflows/execute-plan.md
@/home/eduardo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-interop-engine-foundation/02-RESEARCH.md

Key context:
- DebuggerNetMcp.Core.csproj is at src/DebuggerNetMcp.Core/DebuggerNetMcp.Core.csproj (net10.0, no packages yet)
- Class1.cs placeholder exists in src/DebuggerNetMcp.Core/ — delete it when adding Engine/Models.cs
- DebugEvent hierarchy must use abstract base + sealed subclasses for C# pattern matching (per RESEARCH.md ENGINE-01)
- Channel<DebugEvent> in Phase 3 is the consumer of DebugEvent subclasses — the hierarchy must be pattern-matchable
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Engine/Models.cs with all debug model types</name>
  <files>src/DebuggerNetMcp.Core/Engine/Models.cs</files>
  <action>
    Create the directory src/DebuggerNetMcp.Core/Engine/ and write Models.cs.

    Delete src/DebuggerNetMcp.Core/Class1.cs (placeholder from Phase 1 scaffold).

    Models.cs must define the following in namespace DebuggerNetMcp.Core.Engine:

    **BreakpointInfo** (record):
    - int Id
    - string File
    - int Line
    - bool IsEnabled

    **StackFrameInfo** (record):
    - int Index
    - string MethodName
    - string? File
    - int? Line
    - int ILOffset

    **VariableInfo** (record):
    - string Name
    - string Type
    - string Value
    - IReadOnlyList<VariableInfo> Children  (empty list for primitives/strings)

    **EvalResult** (record):
    - bool Success
    - string Value
    - string? ErrorMessage

    **DebugEvent** (abstract record base class):
    - No fields — marker base type

    **StoppedEvent** (sealed record : DebugEvent):
    - string Reason  (e.g., "breakpoint", "step", "pause")
    - int ThreadId
    - StackFrameInfo? TopFrame

    **BreakpointHitEvent** (sealed record : DebugEvent):
    - int BreakpointId
    - int ThreadId
    - StackFrameInfo TopFrame

    **ExceptionEvent** (sealed record : DebugEvent):
    - string ExceptionType
    - string Message
    - int ThreadId
    - bool IsUnhandled

    **ExitedEvent** (sealed record : DebugEvent):
    - int ExitCode

    **OutputEvent** (sealed record : DebugEvent):
    - string Category  (e.g., "stdout", "stderr", "console")
    - string Output

    Use C# record syntax throughout. Use `IReadOnlyList<VariableInfo>` for Children (not List<>) to enforce immutability at the interface. Add `using System.Collections.Generic;` if needed (or rely on implicit usings since the project has ImplicitUsings enabled).

    File header: namespace DebuggerNetMcp.Core.Engine;
    File-scoped namespace (not block-scoped).
  </action>
  <verify>
    cd /home/eduardo/Projects/DebuggerNetMcp && dotnet build src/DebuggerNetMcp.Core/DebuggerNetMcp.Core.csproj -c Release --nologo -v q
    Expected: Build succeeded. 0 Warning(s). 0 Error(s).
  </verify>
  <done>
    src/DebuggerNetMcp.Core/Engine/Models.cs exists with all 9 types (4 data records + DebugEvent base + 5 event subclasses). dotnet build passes with 0 errors. Class1.cs is deleted.
  </done>
</task>

</tasks>

<verification>
After task completion:
1. `dotnet build src/DebuggerNetMcp.Core/DebuggerNetMcp.Core.csproj -c Release --nologo` exits 0
2. `grep -r "BreakpointInfo\|StackFrameInfo\|VariableInfo\|EvalResult\|DebugEvent\|StoppedEvent\|BreakpointHitEvent\|ExceptionEvent\|ExitedEvent\|OutputEvent" src/DebuggerNetMcp.Core/Engine/Models.cs | wc -l` returns >= 10
3. `ls src/DebuggerNetMcp.Core/Class1.cs` returns "No such file" (placeholder removed)
</verification>

<success_criteria>
All 9 model types compile cleanly in DebuggerNetMcp.Core. No Class1.cs placeholder remains. The DebugEvent hierarchy uses abstract + sealed record pattern suitable for exhaustive switch expressions in Phase 3.
</success_criteria>

<output>
After completion, create .planning/phases/02-interop-engine-foundation/02-01-SUMMARY.md
</output>
