---
phase: 02-interop-engine-foundation
plan: 03
type: execute
wave: 2
depends_on:
  - 02-01
  - 02-02
files_modified:
  - src/DebuggerNetMcp.Core/Engine/PdbReader.cs
  - src/DebuggerNetMcp.Core/Engine/VariableReader.cs
autonomous: true
requirements:
  - ENGINE-02
  - ENGINE-03

must_haves:
  truths:
    - "PdbReader.FindLocation(dllPath, sourceFile, line) returns a valid (methodToken, ilOffset) tuple for a source line in HelloDebug"
    - "VariableReader.ReadValue(ICorDebugValue, depth) correctly dispatches to primitive, string, array, and object readers without throwing for any CorElementType defined in ENGINE-03"
    - "dotnet build completes without errors after PdbReader.cs and VariableReader.cs are added"
  artifacts:
    - path: "src/DebuggerNetMcp.Core/Engine/PdbReader.cs"
      provides: "Source-line to (methodToken, ilOffset) mapping using System.Reflection.Metadata"
      exports: ["PdbReader"]
    - path: "src/DebuggerNetMcp.Core/Engine/VariableReader.cs"
      provides: "Recursive ICorDebugValue inspection returning VariableInfo with depth limit 3"
      exports: ["VariableReader"]
  key_links:
    - from: "src/DebuggerNetMcp.Core/Engine/PdbReader.cs"
      to: "ICorDebug (Phase 3, DotnetDebugger.SetBreakpointAsync)"
      via: "Returns (methodToken, ilOffset) consumed by ICorDebugFunction.CreateBreakpoint"
      pattern: "methodToken.*0x06000000"
    - from: "src/DebuggerNetMcp.Core/Engine/VariableReader.cs"
      to: "src/DebuggerNetMcp.Core/Interop/ICorDebug.cs"
      via: "ICorDebugValue, ICorDebugGenericValue, ICorDebugStringValue, ICorDebugObjectValue, ICorDebugArrayValue, ICorDebugReferenceValue casts"
      pattern: "ICorDebugValue"
    - from: "src/DebuggerNetMcp.Core/Engine/VariableReader.cs"
      to: "src/DebuggerNetMcp.Core/Engine/Models.cs"
      via: "Returns VariableInfo records"
      pattern: "VariableInfo"
---

<objective>
Implement PdbReader (source-line to IL-offset mapping) and VariableReader (recursive ICorDebugValue inspection returning VariableInfo).

Purpose: These are the two algorithmic workhorses of the debug engine. PdbReader enables breakpoint placement and stack frame annotation. VariableReader enables variables/locals inspection. Phase 3 (DotnetDebugger.cs) calls both directly.
Output: Engine/PdbReader.cs and Engine/VariableReader.cs — both compile against the ICorDebug interfaces from Plan 02-02 and the model types from Plan 02-01.
</objective>

<execution_context>
@/home/eduardo/.claude/get-shit-done/workflows/execute-plan.md
@/home/eduardo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-interop-engine-foundation/02-RESEARCH.md
@.planning/phases/02-interop-engine-foundation/02-01-SUMMARY.md
@.planning/phases/02-interop-engine-foundation/02-02-SUMMARY.md

Key context from research (ENGINE-02 and ENGINE-03):
- System.Reflection.Metadata is in-box in .NET 10 — no NuGet package needed
- PEReader + MetadataReaderProvider API is the correct way to open both embedded and separate PDB
- methodToken = 0x06000000 | MetadataTokens.GetRowNumber(methodDebugHandle) (1-based row number, not 0-based)
- Try embedded PDB first (ReadEmbeddedPortablePdbDebugDirectoryData), then TryOpenAssociatedPortablePdb
- DocumentNameBlobHandle: use MetadataReader.GetString on the DocumentName for path matching
- For reference types (ELEMENT_TYPE_OBJECT/CLASS): first cast to ICorDebugReferenceValue, call Dereference(), then cast to ICorDebugObjectValue
- Depth limit 3: return VariableInfo { Name=name, Type="...", Value="...", Children=[] } with Value="..." when depth >= 3
- Anti-pattern: do NOT cast ICorDebugValue directly to ICorDebugObjectValue for reference types — must dereference first
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PdbReader.cs — source line to IL offset mapping</name>
  <files>src/DebuggerNetMcp.Core/Engine/PdbReader.cs</files>
  <action>
    Create src/DebuggerNetMcp.Core/Engine/PdbReader.cs.

    Namespace: DebuggerNetMcp.Core.Engine (file-scoped)
    Usings: System.Reflection.Metadata, System.Reflection.Metadata.Ecma335, System.Reflection.PortableExecutable, System.IO

    Implement `internal static class PdbReader` with:

    **public static (int methodToken, int ilOffset) FindLocation(string dllPath, string sourceFile, int line)**

    Algorithm:
    1. Open dllPath with `new PEReader(File.OpenRead(dllPath))` (wrap in using)
    2. Call `peReader.ReadDebugDirectory()` to get debug directory entries
    3. Try embedded PDB first:
       - `var embeddedEntry = debugDir.FirstOrDefault(e => e.Type == DebugDirectoryEntryType.EmbeddedPortablePdb)`
       - If `embeddedEntry.Type == DebugDirectoryEntryType.EmbeddedPortablePdb`, use `peReader.ReadEmbeddedPortablePdbDebugDirectoryData(embeddedEntry)`
    4. If no embedded PDB, try associated file:
       - `peReader.TryOpenAssociatedPortablePdb(dllPath, path => File.OpenRead(path), out var pdbProvider, out _)`
    5. If both fail, throw `FileNotFoundException($"PDB not found for {dllPath}")`
    6. Using the pdbProvider, get `pdbProvider.GetMetadataReader()`
    7. Iterate ALL `pdbReader.MethodDebugInformation` handles:
       ```
       foreach (var methodDebugHandle in pdbReader.MethodDebugInformation)
       {
           var debugInfo = pdbReader.GetMethodDebugInformation(methodDebugHandle);
           foreach (var sp in debugInfo.GetSequencePoints())
           {
               if (sp.IsHidden) continue;
               var doc = pdbReader.GetDocument(sp.Document);
               var docName = pdbReader.GetString(doc.Name);  // full path or relative path
               if (MatchesSourceFile(docName, sourceFile) && sp.StartLine == line)
               {
                   int rowNumber = MetadataTokens.GetRowNumber(methodDebugHandle);
                   int methodToken = 0x06000000 | rowNumber;
                   return (methodToken, sp.Offset);
               }
           }
       }
       throw new InvalidOperationException($"No sequence point found at {sourceFile}:{line}");
       ```
    8. **MatchesSourceFile helper**: `private static bool MatchesSourceFile(string docName, string sourceFile)` — returns true if `docName.EndsWith(sourceFile, StringComparison.OrdinalIgnoreCase)` OR if `Path.GetFileName(docName).Equals(Path.GetFileName(sourceFile), StringComparison.OrdinalIgnoreCase)`. This handles both full path and filename-only comparisons from ICorDebug callers.

    **Also implement:**

    **public static List<(int methodToken, int ilOffset)> FindAllLocations(string dllPath, string sourceFile, int line)**
    Same as FindLocation but returns all matches (some source lines map to multiple sequence points — common in async methods). Returns empty list (not throw) if no matches found.

    **Note on document name decoding:** `MetadataReader.GetString(DocumentNameBlobHandle)` returns the decoded path including the separator. On Linux, this will be the full absolute or relative path from the compilation. No manual blob decoding needed.
  </action>
  <verify>
    cd /home/eduardo/Projects/DebuggerNetMcp && dotnet build src/DebuggerNetMcp.Core/DebuggerNetMcp.Core.csproj -c Release --nologo -v q
    Expected: Build succeeded. 0 Warning(s). 0 Error(s).
  </verify>
  <done>
    PdbReader.cs exists with FindLocation() and FindAllLocations(). dotnet build passes. The methodToken computation uses 0x06000000 | rowNumber (1-based).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create VariableReader.cs — recursive ICorDebugValue inspection</name>
  <files>src/DebuggerNetMcp.Core/Engine/VariableReader.cs</files>
  <action>
    Create src/DebuggerNetMcp.Core/Engine/VariableReader.cs.

    Namespace: DebuggerNetMcp.Core.Engine (file-scoped)
    Usings: DebuggerNetMcp.Core.Interop, System.Collections.Generic, System.Text, System

    Implement `internal static class VariableReader` with:

    **public static VariableInfo ReadValue(string name, ICorDebugValue value, int depth = 0)**

    Algorithm:
    1. If depth > 3: return `new VariableInfo(name, "...", "...", Array.Empty<VariableInfo>())`
    2. Call `value.GetType(out uint elementTypeRaw)` to get the CorElementType
    3. Dispatch via switch on `(CorElementType)elementTypeRaw`:

       **ELEMENT_TYPE_BOOLEAN (0x02):**
       - Cast: `var generic = (ICorDebugGenericValue)value`
       - `value.GetSize(out uint size)` — size should be 1
       - `byte[] buf = new byte[size]; generic.GetValue(buf);`
       - Value string: `buf[0] != 0 ? "true" : "false"`
       - Return `new VariableInfo(name, "bool", valueStr, Array.Empty<VariableInfo>())`

       **ELEMENT_TYPE_CHAR (0x03):**
       - Similar to I2: `generic.GetValue(buf)` → `BitConverter.ToChar(buf, 0).ToString()`
       - Type: "char"

       **ELEMENT_TYPE_I1 (0x04), U1 (0x05):**
       - `buf[0]` as sbyte/byte, type "sbyte"/"byte"

       **ELEMENT_TYPE_I2 (0x06), U2 (0x07):**
       - `BitConverter.ToInt16/ToUInt16(buf, 0)`, type "short"/"ushort"

       **ELEMENT_TYPE_I4 (0x08), U4 (0x09):**
       - `BitConverter.ToInt32/ToUInt32(buf, 0)`, type "int"/"uint"

       **ELEMENT_TYPE_I8 (0x0A), U8 (0x0B):**
       - `BitConverter.ToInt64/ToUInt64(buf, 0)`, type "long"/"ulong"

       **ELEMENT_TYPE_R4 (0x0C):**
       - `BitConverter.ToSingle(buf, 0)`, type "float"

       **ELEMENT_TYPE_R8 (0x0D):**
       - `BitConverter.ToDouble(buf, 0)`, type "double"

       **ELEMENT_TYPE_STRING (0x0E):**
       - Cast: `var strVal = (ICorDebugStringValue)value`
       - `strVal.GetLength(out uint len)`
       - `char[] chars = new char[len]; strVal.GetString(len, out _, chars);`
       - Value: `new string(chars)` — wrap in quotes: `$"\"{new string(chars)}\""`
       - Type: "string"
       - Return with empty Children

       **ELEMENT_TYPE_SZARRAY (0x1D), ELEMENT_TYPE_ARRAY (0x14):**
       - Cast: `var arrVal = (ICorDebugArrayValue)value`
       - `arrVal.GetCount(out uint count)`
       - `arrVal.GetElementType(out uint elemType)`
       - If depth < 3: iterate elements up to min(count, 10):
         `arrVal.GetElementAtPosition(i, out var elem); children.Add(ReadValue($"[{i}]", elem, depth + 1));`
       - Value string: `$"[{count} elements]"`
       - Type: `$"{(CorElementType)elemType}[]"` (simplified type name)
       - Return with children list

       **ELEMENT_TYPE_OBJECT (0x1C), ELEMENT_TYPE_CLASS (0x12), ELEMENT_TYPE_VALUETYPE (0x11):**
       - First try reference dereference:
         ```csharp
         ICorDebugValue actualValue = value;
         try
         {
             var refVal = (ICorDebugReferenceValue)value;
             refVal.IsNull(out int isNull);
             if (isNull != 0) return new VariableInfo(name, "object", "null", Array.Empty<VariableInfo>());
             refVal.Dereference(out actualValue);
         }
         catch (InvalidCastException) { /* value type — use as-is */ }
         catch (Exception) { /* dereference failed — use as-is */ }
         ```
       - Then enumerate fields if depth < 3:
         ```csharp
         var objVal = (ICorDebugObjectValue)actualValue;
         objVal.GetClass(out var cls);
         // Get ICorDebugClass → module → metadata to enumerate fields
         // For Phase 2 (compilation only), implement basic field enumeration:
         // Use ICorDebugObjectValue.GetClass() → ICorDebugClass
         // In Phase 3, DotnetDebugger will provide richer field enumeration via metadata
         // For now: return object with Value="<object>" and empty children if field enumeration fails
         ```
       - IMPORTANT: Field enumeration via ICorDebugObjectValue requires knowing field tokens from metadata. Full implementation requires the ICorDebugModule to get the MetadataToken, then System.Reflection.Metadata to list fields. This is the Phase 3 integration point. For Phase 2, implement the method to:
         (a) Successfully dereference reference types
         (b) Return `new VariableInfo(name, "object", "<object>", Array.Empty<VariableInfo>())` as placeholder
         (c) This placeholder is acceptable for Phase 2 — Phase 3 will add metadata-driven field enumeration
       - For VALUETYPE (struct): same as OBJECT but no dereference needed; type is "struct"

       **Default case:**
       - Return `new VariableInfo(name, $"<{(CorElementType)elementTypeRaw}>", "?", Array.Empty<VariableInfo>())`

    **Define CorElementType enum** in this file (or in ICorDebug.cs from Plan 02-02 — check if it exists there first; if yes, just use it without redefinition):
    ```csharp
    internal enum CorElementType : uint
    {
        End = 0x00, Void = 0x01, Boolean = 0x02, Char = 0x03,
        I1 = 0x04, U1 = 0x05, I2 = 0x06, U2 = 0x07,
        I4 = 0x08, U4 = 0x09, I8 = 0x0A, U8 = 0x0B,
        R4 = 0x0C, R8 = 0x0D, String = 0x0E,
        Ptr = 0x0F, ByRef = 0x10, ValueType = 0x11, Class = 0x12,
        Var = 0x13, Array = 0x14, GenericInst = 0x15,
        TypedByRef = 0x16, I = 0x18, U = 0x19, FnPtr = 0x1B,
        Object = 0x1C, SzArray = 0x1D, MVar = 0x1E,
        CModReqd = 0x1F, CModOpt = 0x20, Internal = 0x21, Max = 0x22,
        Modifier = 0x40, Sentinel = 0x41, Pinned = 0x45
    }
    ```
    (Only define this enum in VariableReader.cs if it is NOT already defined in ICorDebug.cs from Plan 02-02.)

    **Error handling throughout:** Wrap each CorElementType handler in try/catch; on exception, return `new VariableInfo(name, "?", $"<error: {ex.Message}>", Array.Empty<VariableInfo>())` so one bad variable doesn't crash the entire locals enumeration.
  </action>
  <verify>
    cd /home/eduardo/Projects/DebuggerNetMcp && dotnet build src/DebuggerNetMcp.Core/DebuggerNetMcp.Core.csproj -c Release --nologo -v q
    Expected: Build succeeded. 0 Warning(s). 0 Error(s).

    Also verify VariableReader references ICorDebugValue:
    grep "ICorDebugValue" src/DebuggerNetMcp.Core/Engine/VariableReader.cs | wc -l
    Expected: >= 3 (at least parameter type, and array/object casts)
  </verify>
  <done>
    VariableReader.cs exists with ReadValue() dispatching all 11+ CorElementType cases. Reference types are dereferenced before object cast. Depth limit returns "..." at depth >= 3. dotnet build passes with 0 errors.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `dotnet build src/DebuggerNetMcp.Core/DebuggerNetMcp.Core.csproj -c Release --nologo` exits 0
2. `ls src/DebuggerNetMcp.Core/Engine/` shows: Models.cs, PdbReader.cs, VariableReader.cs
3. `grep "0x06000000" src/DebuggerNetMcp.Core/Engine/PdbReader.cs` confirms methodToken computation
4. `grep "Dereference" src/DebuggerNetMcp.Core/Engine/VariableReader.cs` confirms reference type handling
5. `grep "depth > 3\|depth >= 3" src/DebuggerNetMcp.Core/Engine/VariableReader.cs` confirms depth limit guard
6. Full solution build: `dotnet build DebuggerNetMcp.sln -c Release --nologo` exits 0
</verification>

<success_criteria>
PdbReader.cs correctly implements the (file, line) → (methodToken=0x06000000|rowNumber, ilOffset) mapping using System.Reflection.Metadata with embedded-PDB-first fallback. VariableReader.cs handles all primitive types, strings, arrays, and objects with reference dereference + depth limit 3. Both compile cleanly as part of DebuggerNetMcp.Core.
</success_criteria>

<output>
After completion, create .planning/phases/02-interop-engine-foundation/02-03-SUMMARY.md
</output>
