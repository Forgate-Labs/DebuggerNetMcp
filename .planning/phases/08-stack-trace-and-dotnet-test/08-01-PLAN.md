---
phase: 08-stack-trace-and-dotnet-test
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/DebuggerNetMcp.Core/Engine/PdbReader.cs
  - src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs
autonomous: true
requirements: [STKT-01, STKT-02]

must_haves:
  truths:
    - "debug_stacktrace returns frames with human-readable 'Program.cs:57' locations instead of hex tokens for user project frames"
    - "PdbReader.ReverseLookup(dllPath, methodToken, ilOffset) returns (sourceFile, line) when a PDB is available"
    - "Frames from BCL/framework assemblies (no PDB available) fall back gracefully to hex token without crashing"
    - "Method names in stack frames show the actual method name (e.g. 'Main') not '0x06000001'"
  artifacts:
    - path: "src/DebuggerNetMcp.Core/Engine/PdbReader.cs"
      provides: "ReverseLookup static method"
      contains: "public static (string sourceFile, int line)? ReverseLookup"
    - path: "src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs"
      provides: "Updated GetStackFramesForThread with source location population"
      contains: "PdbReader.ReverseLookup"
  key_links:
    - from: "src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs"
      to: "src/DebuggerNetMcp.Core/Engine/PdbReader.cs"
      via: "PdbReader.ReverseLookup call in GetStackFramesForThread"
      pattern: "PdbReader\\.ReverseLookup"
    - from: "GetStackFramesForThread"
      to: "StackFrameInfo"
      via: "File and Line fields populated from PDB lookup"
      pattern: "sourceFile.*sourceLine"
---

<objective>
Implement PdbReader.ReverseLookup (STKT-01) and wire it into GetStackFramesForThread (STKT-02) so debug_stacktrace shows "Program.cs:57" style locations and real method names instead of hex tokens.

Purpose: Stack frames are currently unreadable (hex tokens). Claude Code needs human-readable source locations to navigate code during debugging sessions.
Output: PdbReader.ReverseLookup method + updated GetStackFramesForThread populating StackFrameInfo.File, Line, and MethodName.
</objective>

<execution_context>
@/home/eduardo/.claude/get-shit-done/workflows/execute-plan.md
@/home/eduardo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-stack-trace-and-dotnet-test/08-RESEARCH.md

Key existing code:
@src/DebuggerNetMcp.Core/Engine/PdbReader.cs
@src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add PdbReader.ReverseLookup</name>
  <files>src/DebuggerNetMcp.Core/Engine/PdbReader.cs</files>
  <action>
Add a new public static method `ReverseLookup` to `PdbReader`. Place it after `FindAllLocations` (around line 105) and before `GetMethodTypeFields`.

Follow the exact same pattern as `GetLocalNames` and `FindLocation` — use `OpenPdbProvider`, `MetadataTokens.MethodDefinitionHandle`, `ToDebugInformationHandle`, and `GetSequencePoints`.

The implementation:
```csharp
public static (string sourceFile, int line)? ReverseLookup(string dllPath, int methodToken, int ilOffset)
{
    try
    {
        using var peReader = new PEReader(File.OpenRead(dllPath));
        using var pdbProvider = OpenPdbProvider(peReader, dllPath);
        var pdbMetadata = pdbProvider.GetMetadataReader();

        int rowNumber = methodToken & 0x00FFFFFF;
        var methodHandle = MetadataTokens.MethodDefinitionHandle(rowNumber);
        var debugHandle = methodHandle.ToDebugInformationHandle();
        var debugInfo = pdbMetadata.GetMethodDebugInformation(debugHandle);

        // Find last sequence point with Offset <= ilOffset (sequence points are in ascending offset order)
        SequencePoint? best = null;
        foreach (var sp in debugInfo.GetSequencePoints())
        {
            if (sp.IsHidden) continue;
            if (sp.Offset <= ilOffset)
                best = sp;
            else
                break; // ascending order guaranteed per Portable PDB spec
        }

        if (best is null) return null;

        var doc = pdbMetadata.GetDocument(best.Value.Document);
        string docName = pdbMetadata.GetString(doc.Name);
        return (docName, best.Value.StartLine);
    }
    catch { return null; }
}
```

IMPORTANT: `sp.IsHidden` checks if StartLine == 0xFEEFEE (hidden sequence point marker) — this is already handled by the `IsHidden` property of `SequencePoint`. The `break` optimization is safe because Portable PDB spec guarantees ascending order.
  </action>
  <verify>dotnet build src/DebuggerNetMcp.Core/ -c Release 2>&1 | tail -5</verify>
  <done>Build succeeds; PdbReader.ReverseLookup method exists in the file.</done>
</task>

<task type="auto">
  <name>Task 2: Wire ReverseLookup into GetStackFramesForThread + resolve method name</name>
  <files>src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs</files>
  <action>
Update `GetStackFramesForThread` (currently at lines 738-768) to:
1. Call `fn.GetModule(out ICorDebugModule module)` after `fn.GetToken`
2. Call `VariableReader.GetModulePath(module)` to get the DLL path
3. Call `PdbReader.ReverseLookup(dllPath, (int)methodToken, (int)ip)` to get source location
4. Call `PdbReader.GetMethodTypeFields(dllPath, (int)methodToken)` to get the method name
5. Populate `StackFrameInfo` with real method name and source location

Replace the current IL frame branch body:
```csharp
// BEFORE:
frames.Add(new StackFrameInfo(frameIndex++, $"0x{methodToken:X8}", null, null, (int)ip));

// AFTER:
string? sourceFile = null;
int? sourceLine = null;
string methodName = $"0x{methodToken:X8}"; // fallback

try
{
    fn.GetModule(out ICorDebugModule module);
    string dllPath = VariableReader.GetModulePath(module);
    if (!string.IsNullOrEmpty(dllPath))
    {
        // Resolve source location via PDB reverse lookup
        var loc = PdbReader.ReverseLookup(dllPath, (int)methodToken, (int)ip);
        if (loc.HasValue)
        {
            sourceFile = Path.GetFileName(loc.Value.sourceFile);
            sourceLine = loc.Value.line;
        }

        // Resolve method name from PE metadata
        var (resolvedName, _) = PdbReader.GetMethodTypeFields(dllPath, (int)methodToken);
        if (!string.IsNullOrEmpty(resolvedName))
            methodName = resolvedName;
    }
}
catch { /* non-fatal: framework frames have no PDB; fall back to hex token */ }

frames.Add(new StackFrameInfo(frameIndex++, methodName, sourceFile, sourceLine, (int)ip));
```

IMPORTANT: Wrap the entire module path + PDB lookup in try/catch — BCL frames (System.Private.CoreLib, etc.) ship without PDB in typical installs. This must never crash. The `sourceFile` stored in `StackFrameInfo.File` is the full path from PDB; the display uses `Path.GetFileName()`.

Also increment the MCP ServerVersion from its current value (check `DebuggerTools.cs` line 11) to the next patch version.

After editing DotnetDebugger.cs, also update `ServerVersion` in `src/DebuggerNetMcp.Mcp/DebuggerTools.cs` — increment to next patch (e.g. 0.7.9 → 0.8.0 since this is a feature). Check current value first.
  </action>
  <verify>dotnet build src/DebuggerNetMcp.Mcp/ -c Release 2>&1 | tail -5</verify>
  <done>Release build succeeds; GetStackFramesForThread calls PdbReader.ReverseLookup; StackFrameInfo populated with sourceFile and sourceLine for user project frames; ServerVersion incremented.</done>
</task>

</tasks>

<verification>
After both tasks:
1. `dotnet build src/DebuggerNetMcp.Mcp/ -c Release` completes without errors
2. Inspect `GetStackFramesForThread` in DotnetDebugger.cs — confirm it calls `PdbReader.ReverseLookup` and `PdbReader.GetMethodTypeFields`
3. Inspect `PdbReader.cs` — confirm `ReverseLookup` method exists with `SequencePoint? best = null` pattern
4. Manual smoke test (optional): launch HelloDebug, set a BP, continue, call debug_stacktrace — verify frames show "Program.cs:N" for HelloDebug frames
</verification>

<success_criteria>
- PdbReader.ReverseLookup(dllPath, methodToken, ilOffset) exists and follows the nearest-sequence-point pattern
- GetStackFramesForThread populates StackFrameInfo.File (basename) and StackFrameInfo.Line from PDB
- BCL frames (no PDB) fail silently and display as hex token fallback — no crash
- Method names show real names (e.g. "MoveNext", "Main") not hex tokens where PDB is available
- Release build passes
</success_criteria>

<output>
After completion, create `.planning/phases/08-stack-trace-and-dotnet-test/08-01-SUMMARY.md`
</output>
