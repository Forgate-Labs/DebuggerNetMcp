---
phase: 03-debug-engine
plan: 02
type: execute
wave: 2
depends_on:
  - "03-01"
files_modified:
  - src/DebuggerNetMcp.Core/Engine/ManagedCallbackHandler.cs
autonomous: true
requirements:
  - ENGINE-08

must_haves:
  truths:
    - "ManagedCallbackHandler implements all 26 ICorDebugManagedCallback methods and all 8 ICorDebugManagedCallback2 methods"
    - "Every callback method calls pAppDomain.Continue(0) (or pProcess.Continue(0)) — no method returns without continuing"
    - "ExitProcess does NOT call Continue; it writes ExitedEvent and completes the channel writer"
    - "Breakpoint callback writes BreakpointHitEvent; StepComplete writes StoppedEvent with reason 'step'"
    - "ManagedCallbackHandler compiles with [GeneratedComClass] and 0 warnings"
  artifacts:
    - path: "src/DebuggerNetMcp.Core/Engine/ManagedCallbackHandler.cs"
      provides: "COM callback sink for all ICorDebug debug events"
      min_lines: 120
      contains: "[GeneratedComClass]"
  key_links:
    - from: "src/DebuggerNetMcp.Core/Engine/ManagedCallbackHandler.cs"
      to: "src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs"
      via: "Instantiated in DotnetDebugger constructor, passed to ICorDebug.SetManagedHandler"
      pattern: "new ManagedCallbackHandler"
    - from: "src/DebuggerNetMcp.Core/Engine/ManagedCallbackHandler.cs"
      to: "System.Threading.Channels.ChannelWriter<DebugEvent>"
      via: "Constructor injection; TryWrite called in Breakpoint, StepComplete, ExitProcess"
      pattern: "_events.TryWrite"
---

<objective>
Implement `ManagedCallbackHandler` — the `[GeneratedComClass]`-attributed COM callback sink that receives all ICorDebug debug events. This class bridges the native ICorDebug callback thread to the managed `Channel<DebugEvent>` that async callers consume.

Purpose: ICorDebug delivers all debug events (breakpoints, steps, module loads, exceptions, process exit) by calling methods on this class. Every method MUST call `Continue()` or the debuggee freezes permanently. This class is the single most dangerous piece of the engine — one missing `Continue()` call causes a silent deadlock.

Output: `ManagedCallbackHandler.cs` with all 34 callback methods, compiling clean.
</objective>

<execution_context>
@/home/eduardo/.claude/get-shit-done/workflows/execute-plan.md
@/home/eduardo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-debug-engine/03-RESEARCH.md
@.planning/phases/02-interop-engine-foundation/02-02-SUMMARY.md
@src/DebuggerNetMcp.Core/Interop/ICorDebug.cs
@src/DebuggerNetMcp.Core/Engine/Models.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ManagedCallbackHandler.cs with all 34 callback methods</name>
  <files>src/DebuggerNetMcp.Core/Engine/ManagedCallbackHandler.cs</files>
  <action>
Create `src/DebuggerNetMcp.Core/Engine/ManagedCallbackHandler.cs`.

**Key design invariants (from research — enforce all of them):**

1. `[GeneratedComClass]` attribute on the class — required for COM vtable generation
2. Class is `internal sealed partial` — partial required by source generator
3. Constructor accepts `ChannelWriter<DebugEvent> events` — injected by DotnetDebugger
4. EVERY ICorDebugManagedCallback method MUST call `pAppDomain.Continue(0)` before returning — use `finally` blocks to guarantee this even if an exception occurs during event construction
5. `ExitProcess` is the ONLY exception — do NOT call Continue there; instead write `ExitedEvent` and call `_events.TryComplete()`
6. `_process` field is set from the `CreateProcess` callback — this is how DotnetDebugger gets the ICorDebugProcess reference
7. Use `AllowPendingBreakpointCallback` action to signal the launch TCS — see DotnetDebugger plan for how this is consumed
8. `Channel<DebugEvent>` writer uses `TryWrite` (fire-and-forget, never blocks) — channel is unbounded so TryWrite always returns true

**Full implementation:**

```csharp
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;
using System.Threading.Channels;
using DebuggerNetMcp.Core.Interop;

namespace DebuggerNetMcp.Core.Engine;

/// <summary>
/// COM callback sink for all ICorDebug debug events.
/// Implements ICorDebugManagedCallback (26 methods) and ICorDebugManagedCallback2 (8 methods).
///
/// INVARIANT: Every method in ICorDebugManagedCallback MUST call pAppDomain.Continue(0)
/// before returning, or the debuggee process will freeze permanently.
/// ExitProcess is the sole exception — Continue must NOT be called after the process exits.
/// </summary>
[GeneratedComClass]
internal sealed partial class ManagedCallbackHandler
    : ICorDebugManagedCallback, ICorDebugManagedCallback2
{
    private readonly ChannelWriter<DebugEvent> _events;

    // Set from CreateProcess callback; used by DotnetDebugger for ICorDebugProcess access
    internal ICorDebugProcess? Process { get; private set; }

    // Action invoked when CreateProcess fires — DotnetDebugger sets this before launch
    internal Action<ICorDebugProcess>? OnProcessCreated { get; set; }

    // Tracks ICorDebugFunctionBreakpoint instances by breakpoint ID (set by DotnetDebugger)
    // Maps ICorDebugFunctionBreakpoint.GetFunction token → breakpoint ID for hit reporting
    internal Dictionary<nint, int> BreakpointTokenToId { get; } = new();

    public ManagedCallbackHandler(ChannelWriter<DebugEvent> events)
    {
        _events = events;
    }

    // -----------------------------------------------------------------------
    // ICorDebugManagedCallback — 26 methods
    // All MUST end with pAppDomain.Continue(0)
    // -----------------------------------------------------------------------

    public void Breakpoint(ICorDebugAppDomain pAppDomain, ICorDebugThread pThread,
        ICorDebugBreakpoint pBreakpoint)
    {
        try
        {
            pThread.GetID(out uint tid);
            // Try to find the breakpoint ID
            int bpId = -1;
            if (pBreakpoint is ICorDebugFunctionBreakpoint fbp)
            {
                var ptr = (nint)Marshal.GetIUnknownForObject(fbp);
                BreakpointTokenToId.TryGetValue(ptr, out bpId);
                Marshal.Release(ptr);
            }
            var frame = TryGetTopFrame(pThread);
            _events.TryWrite(bpId >= 0
                ? new BreakpointHitEvent(bpId, (int)tid, frame ?? new StackFrameInfo(0, "<unknown>", null, null, 0))
                : new StoppedEvent("breakpoint", (int)tid, frame));
        }
        finally { pAppDomain.Continue(0); }
    }

    public void StepComplete(ICorDebugAppDomain pAppDomain, ICorDebugThread pThread,
        ICorDebugStepper pStepper, CorDebugStepReason reason)
    {
        try
        {
            pThread.GetID(out uint tid);
            var frame = TryGetTopFrame(pThread);
            _events.TryWrite(new StoppedEvent("step", (int)tid, frame));
        }
        finally { pAppDomain.Continue(0); }
    }

    public void Break(ICorDebugAppDomain pAppDomain, ICorDebugThread pThread)
    {
        try
        {
            pThread.GetID(out uint tid);
            _events.TryWrite(new StoppedEvent("pause", (int)tid, null));
        }
        finally { pAppDomain.Continue(0); }
    }

    public void Exception(ICorDebugAppDomain pAppDomain, ICorDebugThread pThread, int bUnhandled)
    {
        try
        {
            pThread.GetID(out uint tid);
            _events.TryWrite(new ExceptionEvent("<unknown>", "<exception>", (int)tid, bUnhandled != 0));
        }
        finally { pAppDomain.Continue(0); }
    }

    public void EvalComplete(ICorDebugAppDomain pAppDomain, ICorDebugThread pThread,
        ICorDebugEval pEval)
        => pAppDomain.Continue(0);

    public void EvalException(ICorDebugAppDomain pAppDomain, ICorDebugThread pThread,
        ICorDebugEval pEval)
        => pAppDomain.Continue(0);

    public void CreateProcess(ICorDebugProcess pProcess)
    {
        try
        {
            Process = pProcess;
            OnProcessCreated?.Invoke(pProcess);
        }
        finally { pProcess.Continue(0); }
    }

    public void ExitProcess(ICorDebugProcess pProcess)
    {
        // DO NOT call Continue after ExitProcess — process is gone
        int exitCode = 0;
        try { pProcess.GetID(out uint pid); } catch { /* ignore */ }
        _events.TryWrite(new ExitedEvent(exitCode));
        _events.TryComplete();
    }

    public void CreateThread(ICorDebugAppDomain pAppDomain, ICorDebugThread pThread)
        => pAppDomain.Continue(0);

    public void ExitThread(ICorDebugAppDomain pAppDomain, ICorDebugThread pThread)
        => pAppDomain.Continue(0);

    public void LoadModule(ICorDebugAppDomain pAppDomain, ICorDebugModule pModule)
    {
        try
        {
            // DotnetDebugger hooks this via OnModuleLoaded to resolve pending breakpoints
            OnModuleLoaded?.Invoke(pModule);
        }
        finally { pAppDomain.Continue(0); }
    }

    // Action invoked when a module loads — set by DotnetDebugger for pending breakpoint resolution
    internal Action<ICorDebugModule>? OnModuleLoaded { get; set; }

    public void UnloadModule(ICorDebugAppDomain pAppDomain, ICorDebugModule pModule)
        => pAppDomain.Continue(0);

    public void LoadClass(ICorDebugAppDomain pAppDomain, ICorDebugClass pClass)
        => pAppDomain.Continue(0);

    public void UnloadClass(ICorDebugAppDomain pAppDomain, ICorDebugClass pClass)
        => pAppDomain.Continue(0);

    public void DebuggerError(ICorDebugProcess pProcess, int errorHR, uint errorCode)
    {
        _events.TryWrite(new ExceptionEvent("DebuggerError",
            $"HRESULT 0x{errorHR:X8} code {errorCode}", 0, true));
        // pProcess.Continue(0) — process may be in an error state, attempt continue anyway
        try { pProcess.Continue(0); } catch { /* ignore if process is gone */ }
    }

    public void LogMessage(ICorDebugAppDomain pAppDomain, ICorDebugThread pThread,
        int lLevel, IntPtr pLogSwitchName, IntPtr pMessage)
        => pAppDomain.Continue(0);

    public void LogSwitch(ICorDebugAppDomain pAppDomain, ICorDebugThread pThread,
        int lLevel, uint ulReason, IntPtr pLogSwitchName, IntPtr pParentName)
        => pAppDomain.Continue(0);

    public void CreateAppDomain(ICorDebugProcess pProcess, ICorDebugAppDomain pAppDomain)
        => pAppDomain.Continue(0);

    public void ExitAppDomain(ICorDebugProcess pProcess, ICorDebugAppDomain pAppDomain)
        => pAppDomain.Continue(0);

    public void LoadAssembly(ICorDebugAppDomain pAppDomain, ICorDebugAssembly pAssembly)
        => pAppDomain.Continue(0);

    public void UnloadAssembly(ICorDebugAppDomain pAppDomain, ICorDebugAssembly pAssembly)
        => pAppDomain.Continue(0);

    public void ControlCTrap(ICorDebugProcess pProcess)
    {
        try { pProcess.Continue(0); } catch { /* ignore */ }
    }

    public void NameChange(ICorDebugAppDomain pAppDomain, ICorDebugThread pThread)
        => pAppDomain.Continue(0);

    public void UpdateModuleSymbols(ICorDebugAppDomain pAppDomain, ICorDebugModule pModule,
        IntPtr pSymbolStream)
        => pAppDomain.Continue(0);

    public void EditAndContinueRemap(ICorDebugAppDomain pAppDomain, ICorDebugThread pThread,
        ICorDebugFunction pFunction, int fAccurate)
        => pAppDomain.Continue(0);

    public void BreakpointSetError(ICorDebugAppDomain pAppDomain, ICorDebugThread pThread,
        ICorDebugBreakpoint pBreakpoint, uint dwError)
        => pAppDomain.Continue(0);

    // -----------------------------------------------------------------------
    // ICorDebugManagedCallback2 — 8 methods
    // All MUST end with pAppDomain.Continue(0) except MDANotification
    // -----------------------------------------------------------------------

    public void FunctionRemapOpportunity(ICorDebugAppDomain pAppDomain,
        ICorDebugThread pThread, ICorDebugFunction pOldFunction,
        ICorDebugFunction pNewFunction, uint oldILOffset)
        => pAppDomain.Continue(0);

    public void CreateConnection(ICorDebugProcess pProcess, uint dwConnectionId,
        IntPtr pConnName)
    {
        try { pProcess.Continue(0); } catch { /* ignore */ }
    }

    public void ChangeConnection(ICorDebugProcess pProcess, uint dwConnectionId)
    {
        try { pProcess.Continue(0); } catch { /* ignore */ }
    }

    public void DestroyConnection(ICorDebugProcess pProcess, uint dwConnectionId)
    {
        try { pProcess.Continue(0); } catch { /* ignore */ }
    }

    public void Exception(ICorDebugAppDomain pAppDomain, ICorDebugThread pThread,
        ICorDebugFrame? pFrame, uint nOffset,
        CorDebugExceptionCallbackType dwEventType, uint dwFlags)
    {
        try
        {
            if (dwEventType == CorDebugExceptionCallbackType.DEBUG_EXCEPTION_UNHANDLED ||
                dwEventType == CorDebugExceptionCallbackType.DEBUG_EXCEPTION_FIRST_CHANCE)
            {
                pThread.GetID(out uint tid);
                bool isUnhandled = dwEventType == CorDebugExceptionCallbackType.DEBUG_EXCEPTION_UNHANDLED;
                _events.TryWrite(new ExceptionEvent("<exception>", "<exception occurred>",
                    (int)tid, isUnhandled));
            }
        }
        finally { pAppDomain.Continue(0); }
    }

    public void ExceptionUnwind(ICorDebugAppDomain pAppDomain, ICorDebugThread pThread,
        CorDebugExceptionUnwindCallbackType dwEventType, uint dwFlags)
        => pAppDomain.Continue(0);

    public void FunctionRemapComplete(ICorDebugAppDomain pAppDomain, ICorDebugThread pThread,
        ICorDebugFunction pFunction)
        => pAppDomain.Continue(0);

    public void MDANotification(ICorDebugController pController, ICorDebugThread pThread,
        ICorDebugMDA pMDA)
    {
        try { pController.Continue(0); } catch { /* ignore */ }
    }

    // -----------------------------------------------------------------------
    // Helper: get the top managed IL frame for StoppedEvent
    // -----------------------------------------------------------------------
    private static StackFrameInfo? TryGetTopFrame(ICorDebugThread pThread)
    {
        try
        {
            pThread.GetActiveFrame(out ICorDebugFrame frame);
            if (frame is ICorDebugILFrame ilFrame)
            {
                ilFrame.GetIP(out uint ip, out _);
                frame.GetFunction(out ICorDebugFunction fn);
                fn.GetToken(out uint token);
                return new StackFrameInfo(0, $"0x{token:X8}", null, null, (int)ip);
            }
        }
        catch { /* native frame or prolog — no IL frame available */ }
        return null;
    }
}
```

**Signature constraints from ICorDebug.cs:**

Check `src/DebuggerNetMcp.Core/Interop/ICorDebug.cs` for the exact signatures of `ICorDebugManagedCallback` and `ICorDebugManagedCallback2` — every method in `ManagedCallbackHandler` must match the interface declaration exactly (same parameter types, same order). If the ICorDebug.cs interfaces use `IntPtr` for some parameters (due to SYSLIB1051/1052 fixes from Plan 02-02), use the same `IntPtr` type in the implementations.

After building, if there are signature mismatches, fix the ManagedCallbackHandler signatures to match the interface — do NOT change ICorDebug.cs.
  </action>
  <verify>
    Run: `dotnet build /home/eduardo/Projects/DebuggerNetMcp/DebuggerNetMcp.sln`
    Expected: Exit code 0, 0 errors, 0 warnings
    Run: `grep -c "Continue(0)" /home/eduardo/Projects/DebuggerNetMcp/src/DebuggerNetMcp.Core/Engine/ManagedCallbackHandler.cs`
    Expected: at least 25 (one per non-ExitProcess callback)
    Run: `grep "\[GeneratedComClass\]" /home/eduardo/Projects/DebuggerNetMcp/src/DebuggerNetMcp.Core/Engine/ManagedCallbackHandler.cs`
    Expected: one match
    Run: `grep "ExitProcess" /home/eduardo/Projects/DebuggerNetMcp/src/DebuggerNetMcp.Core/Engine/ManagedCallbackHandler.cs`
    Expected: implementation exists and does NOT contain Continue(0)
  </verify>
  <done>
    ManagedCallbackHandler.cs exists with [GeneratedComClass], implements both callback interfaces.
    All 26 ICorDebugManagedCallback methods implemented.
    All 8 ICorDebugManagedCallback2 methods implemented.
    ExitProcess writes ExitedEvent + calls TryComplete; does not call Continue.
    Breakpoint writes BreakpointHitEvent; StepComplete writes StoppedEvent("step").
    dotnet build exits 0 with 0 errors.
  </done>
</task>

</tasks>

<verification>
- `dotnet build DebuggerNetMcp.sln` exits 0
- ManagedCallbackHandler.cs has [GeneratedComClass] attribute
- grep -c "Continue(0)" in file returns >= 25
- ExitProcess implementation does not call Continue(0)
- File has >= 120 lines
</verification>

<success_criteria>
- All 34 callback methods implemented (26 + 8)
- Every non-ExitProcess method calls Continue inside a finally block or inline
- Breakpoint and StepComplete write correct event types to the channel
- LoadModule invokes the OnModuleLoaded hook for pending breakpoint resolution
- Clean build with 0 warnings
</success_criteria>

<output>
After completion, create `.planning/phases/03-debug-engine/03-02-SUMMARY.md`
</output>
