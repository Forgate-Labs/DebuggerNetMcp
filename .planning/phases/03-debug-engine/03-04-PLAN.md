---
phase: 03-debug-engine
plan: 04
type: execute
wave: 4
depends_on:
  - "03-03"
files_modified:
  - src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs
autonomous: true
requirements:
  - ENGINE-05
  - ENGINE-06

must_haves:
  truths:
    - "SetBreakpointAsync(file, line) resolves to (methodToken, ilOffset) via PdbReader and activates the breakpoint"
    - "If the module is not yet loaded, the breakpoint is stored in _pendingBreakpoints and resolved in LoadModule callback"
    - "RemoveBreakpointAsync deactivates and removes the ICorDebugFunctionBreakpoint"
    - "ContinueAsync resumes the debuggee process"
    - "StepOverAsync, StepIntoAsync, StepOutAsync create an ICorDebugStepper with INTERCEPT_NONE and STOP_NONE, then call Continue"
    - "PauseAsync calls ICorDebugProcess.Stop(0)"
  artifacts:
    - path: "src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs"
      provides: "Execution control + breakpoint management methods"
      contains: "SetBreakpointAsync"
  key_links:
    - from: "src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs"
      to: "src/DebuggerNetMcp.Core/Engine/PdbReader.cs"
      via: "PdbReader.FindLocation(dllPath, file, line) called in SetBreakpointAsync"
      pattern: "PdbReader\\.FindLocation"
    - from: "src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs"
      to: "src/DebuggerNetMcp.Core/Interop/ICorDebug.cs"
      via: "ICorDebugFunction.CreateBreakpoint + ICorDebugFunctionBreakpoint.Activate(1)"
      pattern: "CreateBreakpoint"
    - from: "src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs"
      to: "src/DebuggerNetMcp.Core/Interop/ICorDebug.cs"
      via: "ICorDebugThread.CreateStepper + stepper.Step/StepOut + _process.Continue"
      pattern: "CreateStepper"
---

<objective>
Add execution control and breakpoint management to `DotnetDebugger.cs`: SetBreakpointAsync, RemoveBreakpointAsync, ContinueAsync, StepOverAsync, StepIntoAsync, StepOutAsync, PauseAsync. These extend the engine core from Plan 03-03.

Purpose: Breakpoints and stepping are the core debug experience. The pending-breakpoint pattern (pre-LoadModule) and the ICorDebugStepper lifecycle are the two tricky pieces; the research doc has exact verified sequences for both.

Output: DotnetDebugger.cs extended with 7 new async public methods; solution builds clean.
</objective>

<execution_context>
@/home/eduardo/.claude/get-shit-done/workflows/execute-plan.md
@/home/eduardo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-debug-engine/03-RESEARCH.md
@src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs
@src/DebuggerNetMcp.Core/Engine/PdbReader.cs
@src/DebuggerNetMcp.Core/Interop/ICorDebug.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add SetBreakpointAsync, RemoveBreakpointAsync, and ResolveBreakpoint to DotnetDebugger.cs</name>
  <files>src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs</files>
  <action>
Add the following methods to `DotnetDebugger.cs`. Open the file and append these methods inside the class body (before the closing brace). Do NOT replace any existing code.

**SetBreakpointAsync + ResolveBreakpoint:**

```csharp
/// <summary>
/// Sets a breakpoint at the given source file and line number.
/// Returns the breakpoint ID. If the module is not yet loaded, queues as pending.
/// </summary>
public async Task<int> SetBreakpointAsync(string dllPath, string sourceFile, int line,
    CancellationToken ct = default)
{
    var tcs = new TaskCompletionSource<int>(TaskCreationOptions.RunContinuationsAsynchronously);

    await DispatchAsync(() =>
    {
        try
        {
            int id = _nextBreakpointId++;

            // Resolve (methodToken, ilOffset) from the PDB
            var location = PdbReader.FindLocation(dllPath, sourceFile, line);
            if (location is null)
            {
                tcs.SetException(new InvalidOperationException(
                    $"Cannot find source location {sourceFile}:{line} in {dllPath}"));
                return;
            }

            var (methodToken, ilOffset) = location.Value;
            string dllName = Path.GetFileName(dllPath);

            // Look for the loaded module
            var module = _loadedModules.Values.FirstOrDefault(m =>
            {
                m.GetName(256, out _, out IntPtr namePtr);
                string name = Marshal.PtrToStringUni(namePtr) ?? string.Empty;
                return name.EndsWith(dllName, StringComparison.OrdinalIgnoreCase);
            });

            if (module is not null)
            {
                ResolveBreakpoint(module, id, methodToken, ilOffset);
            }
            else
            {
                // Module not loaded yet — queue as pending
                _pendingBreakpoints.Add(new PendingBreakpoint(id, dllName, methodToken, ilOffset));
            }

            tcs.SetResult(id);
        }
        catch (Exception ex) { tcs.SetException(ex); }
    }, ct);

    return await tcs.Task.WaitAsync(ct);
}

/// <summary>
/// Deactivates and removes a breakpoint by ID.
/// </summary>
public async Task RemoveBreakpointAsync(int breakpointId, CancellationToken ct = default)
{
    await DispatchAsync(() =>
    {
        // Remove from active breakpoints
        if (_activeBreakpoints.TryGetValue(breakpointId, out var bp))
        {
            try { bp.Activate(0); } catch { /* ignore if process is gone */ }
            _activeBreakpoints.Remove(breakpointId);
        }

        // Remove from pending breakpoints
        _pendingBreakpoints.RemoveAll(p => p.Id == breakpointId);
    }, ct);
}
```

**Replace (or implement) the ResolveBreakpoint stub from Plan 03-03:**

If Plan 03-03 left `ResolveBreakpoint` as a partial method stub, replace that declaration with the full implementation. If it was left as a `throw new NotImplementedException()` stub, replace the body:

```csharp
private void ResolveBreakpoint(ICorDebugModule module, int id, int methodToken, int ilOffset)
{
    module.GetFunctionFromToken((uint)methodToken, out ICorDebugFunction fn);
    fn.CreateBreakpoint(out ICorDebugFunctionBreakpoint bp);
    bp.Activate(1);  // 1 = enabled
    _activeBreakpoints[id] = bp;

    // Register for hit reporting in ManagedCallbackHandler
    // The handler uses a COM identity pointer to map breakpoint hits → IDs
    // For simplicity, store the COM pointer → ID mapping on the handler
    var bpPtr = (nint)Marshal.GetIUnknownForObject(bp);
    _callbackHandler.BreakpointTokenToId[bpPtr] = id;
    Marshal.Release(bpPtr);  // AddRef was called by GetIUnknownForObject; release our reference
}
```

If `_callbackHandler` does not have access to `BreakpointTokenToId` (because it is `internal`), add a public `RegisterBreakpoint(nint ptr, int id)` method to `ManagedCallbackHandler` that writes to the dictionary, and call that instead.
  </action>
  <verify>
    Run: `dotnet build /home/eduardo/Projects/DebuggerNetMcp/DebuggerNetMcp.sln`
    Expected: Exit code 0, 0 errors
    Run: `grep "SetBreakpointAsync" /home/eduardo/Projects/DebuggerNetMcp/src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs`
    Expected: at least 1 match
    Run: `grep "PdbReader.FindLocation" /home/eduardo/Projects/DebuggerNetMcp/src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs`
    Expected: 1 match
    Run: `grep "CreateBreakpoint" /home/eduardo/Projects/DebuggerNetMcp/src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs`
    Expected: 1 match in ResolveBreakpoint
  </verify>
  <done>
    SetBreakpointAsync resolves via PdbReader.FindLocation, activates if module loaded, queues if not.
    RemoveBreakpointAsync calls bp.Activate(0) and cleans up both dictionaries.
    ResolveBreakpoint calls GetFunctionFromToken → CreateBreakpoint → Activate(1).
    dotnet build exits 0.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add ContinueAsync, PauseAsync, StepOverAsync, StepIntoAsync, StepOutAsync to DotnetDebugger.cs</name>
  <files>src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs</files>
  <action>
Append the following methods to `DotnetDebugger.cs` inside the class body.

**Stepping invariants (from research — MUST follow exactly):**
- `stepper.SetInterceptMask(CorDebugIntercept.INTERCEPT_NONE)` — do not stop at class init, exception filters, etc.
- `stepper.SetUnmappedStopMask(CorDebugUnmappedStop.STOP_NONE)` — do NOT use STOP_UNMANAGED (causes StepOut to fail)
- Call `_process!.Continue(0)` AFTER setting up the stepper — the step won't start until Continue is called
- These methods return Task; the StepComplete callback fires a StoppedEvent("step") on the channel

```csharp
/// <summary>
/// Resumes execution of the debuggee process.
/// </summary>
public async Task ContinueAsync(CancellationToken ct = default)
{
    await DispatchAsync(() =>
    {
        _process?.Continue(0);
    }, ct);
}

/// <summary>
/// Pauses the debuggee process.
/// </summary>
public async Task PauseAsync(CancellationToken ct = default)
{
    await DispatchAsync(() =>
    {
        _process?.Stop(0);
    }, ct);
}

/// <summary>
/// Steps over the current source line (does not enter called methods).
/// Returns when the StepComplete event is enqueued in the event channel.
/// </summary>
public async Task StepOverAsync(CancellationToken ct = default)
    => await StepAsync(stepIn: false, ct: ct);

/// <summary>
/// Steps into the current source line (enters called methods).
/// </summary>
public async Task StepIntoAsync(CancellationToken ct = default)
    => await StepAsync(stepIn: true, ct: ct);

/// <summary>
/// Steps out of the current method (runs until the current method returns).
/// </summary>
public async Task StepOutAsync(CancellationToken ct = default)
{
    await DispatchAsync(() =>
    {
        if (_process is null) return;

        // Get the current (first) thread
        ICorDebugThread thread = GetCurrentThread();

        thread.CreateStepper(out ICorDebugStepper stepper);
        stepper.SetInterceptMask(CorDebugIntercept.INTERCEPT_NONE);
        stepper.SetUnmappedStopMask(CorDebugUnmappedStop.STOP_NONE);  // NOT STOP_UNMANAGED
        stepper.StepOut();
        _process.Continue(0);  // Must continue AFTER setting up step
    }, ct);
}

private async Task StepAsync(bool stepIn, CancellationToken ct)
{
    await DispatchAsync(() =>
    {
        if (_process is null) return;

        ICorDebugThread thread = GetCurrentThread();

        thread.CreateStepper(out ICorDebugStepper stepper);
        stepper.SetInterceptMask(CorDebugIntercept.INTERCEPT_NONE);
        stepper.SetUnmappedStopMask(CorDebugUnmappedStop.STOP_NONE);
        stepper.Step(stepIn ? 1 : 0);  // 1=step-into, 0=step-over
        _process.Continue(0);  // Must continue AFTER setting up step
    }, ct);
}

/// <summary>
/// Gets the first thread from the process thread enumeration.
/// Must be called on the debug thread.
/// </summary>
private ICorDebugThread GetCurrentThread()
{
    _process!.EnumerateThreads(out ICorDebugThreadEnum threadEnum);
    var threads = new ICorDebugThread[1];
    threadEnum.Next(1, threads, out uint fetched);
    if (fetched == 0)
        throw new InvalidOperationException("No threads found in process");
    return threads[0];
}
```

**Note:** `ICorDebugThreadEnum.Next` — check `ICorDebug.cs` for the exact signature. If `ICorDebugThreadEnum` is a stub with no methods, add `void Next(uint celt, ICorDebugThread[] objects, out uint pceltFetched)` to it in `ICorDebug.cs`. If the enum interface inherits from `ICorDebugEnum`, check if `ICorDebugEnum` has `Next`. Adapt the `GetCurrentThread` implementation to match the actual interface.

After writing, build and fix any type/signature mismatches.
  </action>
  <verify>
    Run: `dotnet build /home/eduardo/Projects/DebuggerNetMcp/DebuggerNetMcp.sln`
    Expected: Exit code 0, 0 errors
    Run: `grep "StepOutAsync\|StepOverAsync\|StepIntoAsync\|ContinueAsync\|PauseAsync" /home/eduardo/Projects/DebuggerNetMcp/src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs`
    Expected: 5 matches (one per method)
    Run: `grep "STOP_NONE" /home/eduardo/Projects/DebuggerNetMcp/src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs`
    Expected: at least 2 matches (StepAsync + StepOutAsync)
    Run: `grep "INTERCEPT_NONE" /home/eduardo/Projects/DebuggerNetMcp/src/DebuggerNetMcp.Core/Engine/DotnetDebugger.cs`
    Expected: at least 2 matches
  </verify>
  <done>
    ContinueAsync calls _process.Continue(0).
    PauseAsync calls _process.Stop(0).
    StepOverAsync: stepper with INTERCEPT_NONE + STOP_NONE, Step(0), then Continue.
    StepIntoAsync: same but Step(1).
    StepOutAsync: stepper with INTERCEPT_NONE + STOP_NONE, StepOut(), then Continue.
    dotnet build exits 0 with 0 errors.
  </done>
</task>

</tasks>

<verification>
- `dotnet build DebuggerNetMcp.sln` exits 0 with 0 errors
- grep for SetBreakpointAsync, RemoveBreakpointAsync, ContinueAsync, PauseAsync, StepOverAsync, StepIntoAsync, StepOutAsync — all present
- grep "PdbReader.FindLocation" — 1 match
- grep "STOP_NONE" — at least 2 matches (not STOP_UNMANAGED)
- grep "CreateBreakpoint" — 1 match in ResolveBreakpoint
</verification>

<success_criteria>
- SetBreakpointAsync: PdbReader.FindLocation → CreateBreakpoint + Activate(1) if loaded; PendingBreakpoint if not
- RemoveBreakpointAsync: Activate(0) + removes from dictionaries
- ContinueAsync/PauseAsync: delegate to _process.Continue/Stop
- StepOverAsync/StepIntoAsync/StepOutAsync: ICorDebugStepper with INTERCEPT_NONE + STOP_NONE, then Continue
- All methods dispatch to debug thread via DispatchAsync
- Clean build 0 warnings
</success_criteria>

<output>
After completion, create `.planning/phases/03-debug-engine/03-04-SUMMARY.md`
</output>
